package chiselTests.simulator

import chisel3._
import chisel3.util._
import chisel3.simulator._

import org.scalatest.funspec.AnyFunSpec
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.must.Matchers

import scala.concurrent._

import java.util.concurrent.Phaser

class StepBarrier() {
  private final val preStep = new Phaser(0)
  private final val postStep = new Phaser(0)

  def register(): Unit = synchronized {
    preStep.register()
    postStep.register()
  }

  def bulkRegister(n: Int): Unit = synchronized {
    preStep.bulkRegister(n)
    postStep.bulkRegister(n)
  }

  def isDone: Boolean = synchronized {
    preStep.getRegisteredParties() <= 1 || postStep
      .getRegisteredParties() <= 1 || preStep.isTerminated || postStep.isTerminated
  }

  def deRegister(): Unit = {
    /// or awaitAdvance(arriveAndDeregister()) ???
    preStep.awaitAdvance(preStep.arriveAndDeregister())
    postStep.awaitAdvance(postStep.arriveAndDeregister())
    // preStep.arriveAndDeregister()
    // postStep.arriveAndDeregister() /// ?????
  }

  def step(): Unit = { // synchronization ???? (should not block after first advance)
    preStep.arriveAndAwaitAdvance()
    postStep.arriveAndAwaitAdvance()
  }

  def completeStep(): Unit = synchronized {
    postStep.arriveAndAwaitAdvance()
  }

  def await(): Unit = synchronized {
    // println(s"Scheduler: waiting ...")
    preStep.arriveAndAwaitAdvance()
  }

  def forceTermination(): Unit = {
    preStep.forceTermination()
    postStep.forceTermination()
  }
}

case class Task(runnable: () => Unit, id: Int)

object SynchContext {
  private val dynamicVariable = new scala.util.DynamicVariable[Option[StepBarrier]](None)
  def withValue[T](barrier: StepBarrier)(body: => T): T = {
    require(dynamicVariable.value.isEmpty, "StepBarrier already set. Nesting is not supported!")
    dynamicVariable.withValue(Some(barrier))(body)
  }
  def current: StepBarrier = dynamicVariable.value.get
}

class Scheduler(
  val stepClock: () => Unit
)(
  implicit ec: scala.concurrent.ExecutionContext) {

  def stepBarrier: StepBarrier = SynchContext.current

  def worker(task: Task): Future[Unit] = Future {
    try {
      task.runnable()
    } finally {
      println(s"de-registering task ${task.id}")
      stepBarrier.deRegister()
    }
  }

  def run(tasks: Seq[Task]) = {

    SynchContext.withValue(new StepBarrier()) {

      stepBarrier.bulkRegister(tasks.length + 1)
      val workerFutures = tasks.map(worker).toSeq

      // Start worker futures
      try {

        while (!stepBarrier.isDone) {
          println(s"-- scheduler: waiting for all --")
          System.out.flush()
          stepBarrier.await()
          println(s"---- Scheduler: clock.step ----\n")
          System.out.flush()
          stepClock()
          stepBarrier.completeStep()
          println(s"---- Scheduler: clock.step DONE ----\n")
        }
      } finally {
        stepBarrier.deRegister()
      }
      stepBarrier.forceTermination()
      // Wait for all tasks to complete
      println("waiting for all tasks to complete")
      Await.result(Future.sequence(workerFutures), duration.Duration.Inf)
      println("All tasks completed.")
    }

  }

}

class ThreadedChiselSimSpec extends AnyFlatSpec with ChiselSimTester {

  sealed class ForkBuilder(
    val scheduler: Scheduler,
    tasks:         Seq[Task] = Seq.empty) {

    def fork(runnable: => Unit): ForkBuilder =
      new ForkBuilder(scheduler, tasks :+ Task(() => runnable, tasks.length + 1))

    def joinAndStep(): Unit = {
      join()
      scheduler.stepClock()
    }

    def join(): Unit = {
      scheduler.run(tasks)
    }
  }

  object fork {

    private final lazy val clock = DutContext.current.clock.get

    def apply(runnable: => Unit): ForkBuilder = {
      new ForkBuilder(
        new Scheduler(() => clock.step())(scala.concurrent.ExecutionContext.global)
      ).fork(runnable)
    }
  }

  def step() = {
    SynchContext.current.step()
  }

  val rand = scala.util.Random

  val debug = false
  val numTests = 10

  val w = 32
  val fifoDepth = 13

  behavior.of("ThreadedChiselSim")
  it should "work for a FIFO" in {

    test(
      new Queue(UInt(w.W), fifoDepth),
      ChiselSimSettings
        .verilatorBackend(
          // traceStyle = TraceStyle.Vcd()
        )
        .copy(
          // verboseRun = true,
          executionScriptEnabled = false
        )
    ) { dut =>
      for (testCase <- 1 to numTests) {

        val inputs = Seq.fill(dut.entries * 137)(BigInt(w, rand))
        val expected = inputs

        println(s"testCase #${testCase}/${numTests}")

        dut.io.deq.valid.expect(false.B)
        dut.io.enq.ready.expect(true.B)

        fork {
          for ((input, i) <- inputs.zipWithIndex) {
            // println(s"Enqueuing input #${i + 1}/${inputs.length}: ${input}")
            dut.io.enq.valid.poke(true.B)
            dut.io.enq.bits.poke(input)
            while (!dut.io.enq.ready.peek().litToBoolean) {
              // println("[enq] waiting for ready...")
              step()
            }
            step()
            dut.io.enq.valid.poke(false.B)
          }
        }.fork {
          for ((exp, i) <- expected.zipWithIndex) {
            // println(s"Expecting output #${i + 1}/${expected.length}: ${exp}")
            dut.io.deq.ready.poke(true.B)
            while (!dut.io.deq.valid.peek().litToBoolean) {
              // println("[deq] wating for valid...")
              step()
            }
            dut.io.deq.bits.expect(exp)
            step()
            dut.io.deq.ready.poke(false.B)
          }
        }.join()

        dut.io.deq.valid.expect(false.B)
        dut.io.enq.ready.expect(true.B)
        dut.io.count.expect(0)

      }
    }
  }
}
