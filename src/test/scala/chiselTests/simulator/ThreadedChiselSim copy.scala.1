package chiselTests.simulator

import chisel3._
import chisel3.util._
import chisel3.simulator._

import org.scalatest.funspec.AnyFunSpec
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.must.Matchers

import scala.concurrent._

import java.util.concurrent.Phaser

class StepBarrier() {
  final var preStep: Phaser = null
  final var postStep: Phaser = null

  // def register(): Unit = synchronized {
  //   preStep.register()
  //   postStep.register()
  // }

  def bulkRegister(n: Int): Unit = synchronized {
    preStep = new Phaser(0)
    postStep = new Phaser(0)
    preStep.bulkRegister(n)
    postStep.bulkRegister(n)
  }

  def isDone: Boolean = synchronized {
    preStep.getRegisteredParties() <= 1
    // preStep.isTerminated || postStep.isTerminated
  }

  def deRegister(): Unit = {
    // preStep.arriveAndDeregister()
    // postStep.arriveAndDeregister() /// ?????
    // println(s"de-register preStep")
    preStep.awaitAdvance(preStep.arriveAndDeregister())
    // println(s"de-register postStep")
    postStep.awaitAdvance(postStep.arriveAndDeregister())
    // println(s"de-register done")
  }

  def step(): Unit = { // synchronization ???? (should not block after first advance)
    // println(s"Thread ${Thread.currentThread().threadId()}: step wait preStep")
    preStep.arriveAndAwaitAdvance()
    // println(s"Thread ${Thread.currentThread().threadId}: step wait postStep")
    postStep.arriveAndAwaitAdvance()
    println(s"Thread ${Thread.currentThread().threadId}: step done phase:${preStep.getPhase()}-${postStep
      .getPhase()}  remaining: ${preStep.getUnarrivedParties()}/${preStep.getRegisteredParties()} - ${postStep.getUnarrivedParties()}")
  }

  def completeStep(): Unit = {
    postStep.arriveAndAwaitAdvance()
  }

  def await(): Unit = {
    // println(s"Scheduler: waiting ...")
    preStep.arriveAndAwaitAdvance()
  }

  def forceTermination(): Unit = {
    preStep.forceTermination()
    postStep.forceTermination()
  }
}

case class Task(runnable: () => Unit, id: Int)

class Scheduler(
  stepBarrier:   StepBarrier,
  val stepClock: () => Unit
)(
  implicit ec: scala.concurrent.ExecutionContext) {

  def worker(task: Task): Future[Unit] = Future {
    try {
      task.runnable()
      println(s"task ${task.id} done")
    } finally {
      //   println(s"de-registering task ${task.id}")
      //   println(s"de-registering task ${task.id} DONE!")
    }
  }

  def run(tasks: Seq[Task]) = {

    try {
      println(s"-- scheduler: registering --")
      stepBarrier.bulkRegister(tasks.length + 1)

      // stepBarrier.register()
      println(s"-- scheduler: spawning --")
      val workerFutures = tasks.map(worker).toSeq

      workerFutures.foreach(f => f.onComplete(_ => stepBarrier.step()))

      // Start worker futures
      try {

        while (!stepBarrier.isDone) {
          println(s"-- scheduler: waiting for all --")
          System.out.flush()
          stepBarrier.await()
          println(s"---- Scheduler: clock.step ----\n")
          System.out.flush()
          stepClock()
          println(
            s"---- Scheduler: completeStep   pre: ${stepBarrier.preStep.getUnarrivedParties()}/${stepBarrier.preStep
              .getRegisteredParties()} -- post: ${stepBarrier.postStep.getUnarrivedParties()}/${stepBarrier.postStep.getRegisteredParties()}  ----\n"
          )
          stepBarrier.completeStep()
          println(s"---- Scheduler: completeStep DONE ----\n")
          System.out.flush()
        }
      } finally {
        println(s"---- Scheduler: deregister ----\n")
        println(s"---- Scheduler: deregister DONE ----\n")
        System.out.flush()
      }

      // println(s"---- Scheduler: forceTermination ----\n")
      // stepBarrier.forceTermination()
      // Wait for all tasks to complete
      println(s"---- Scheduler:  Wait for ${workerFutures.count(!_.isCompleted)} tasks to complete ----\n")
      Await.result(Future.sequence(workerFutures), duration.Duration.Inf)
      println("---- All tasks completed.")
      stepBarrier.deRegister()

    } finally {
      // stepBarrier.forceTermination()
    }
  }

}

class ThreadedChiselSimSpec extends AnyFlatSpec with ChiselSimTester {

  sealed class ForkBuilder(
    scheduler: Scheduler,
    tasks:     Seq[Task] = Seq.empty) {

    def fork(runnable: => Unit): ForkBuilder =
      new ForkBuilder(scheduler, tasks :+ Task(() => runnable, tasks.length + 1))

    def joinAndStep(): Unit = {
      join()
      scheduler.stepClock()
    }

    def join(): Unit = {
      scheduler.run(tasks)
    }
  }

  object fork {

    final val barrier = new StepBarrier()

    private final lazy val clock = DutContext.current.clock.get

    def apply(runnable: => Unit): ForkBuilder =
      new ForkBuilder(
        new Scheduler(barrier, () => clock.step())(scala.concurrent.ExecutionContext.global)
      ).fork(runnable)
  }

  def step() = {
    fork.barrier.step()
  }

  val rand = scala.util.Random

  val debug = false
  val numTests = 2

  val w = 32
  val fifoDepth = 3

  behavior.of("ThreadedChiselSim")
  it should "work for a FIFO" in {

    test(
      new Queue(UInt(w.W), fifoDepth),
      ChiselSimSettings
        .verilatorBackend(
          // traceStyle = TraceStyle.Vcd()
        )
        .copy(
          // verboseRun = true,
          executionScriptEnabled = false
        )
    ) { dut =>
      for (testCase <- 1 to numTests) {

        val inputs = Seq.fill(2)(BigInt(w, rand))
        val expected = inputs.toSeq

        println(s"testCase #${testCase}/${numTests}")

        dut.io.deq.valid.expect(false.B)
        dut.io.enq.ready.expect(true.B)

        fork {
          for ((input, i) <- inputs.zipWithIndex) {
            println(s">> Enqueuing input #${i + 1}/${inputs.length}: ${input}")
            dut.io.enq.valid.poke(true.B)
            dut.io.enq.bits.poke(input)
            while (!dut.io.enq.ready.peek().litToBoolean) {
              println("!>> [enq] waiting for ready...")
              step()
            }
            step()
            dut.io.enq.valid.poke(false.B)
            println(s">> Enqueuing input #${i + 1}/ DONE")
          }
        }.fork {
          val maxCycles = 11
          for ((exp, i) <- expected.zipWithIndex) {
            println(s"<< Expecting output #${i + 1}/${expected.length}: ${exp}")
            dut.io.deq.ready.poke(true.B)
            var cycles = 0
            while (!dut.io.deq.valid.peek().litToBoolean) {
              if (cycles >= maxCycles) {
                println(s"testCase:${testCase} [deq] output #${i + 1}/${expected.length} timed out!!")
                assert(false, s"testCase:${testCase} [deq] output #${i + 1}/${expected.length} timed out!!")
              }
              cycles += 1
              println(s"[deq] output #${i + 1}/${expected.length} wating for valid...")
              step()
            }
            println("[deq] got valid --")
            dut.io.deq.bits.expect(exp)
            step()
            dut.io.deq.ready.poke(false.B)
          }
        }.join()

        dut.io.deq.valid.expect(false.B)
        dut.io.enq.ready.expect(true.B)
        dut.io.count.expect(0)

      }
    }
  }
}
