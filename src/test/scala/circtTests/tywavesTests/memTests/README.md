# Annotations for Memories

Memories are a bit more complicated than other data types. Indeed, FIRRTL has support for memory types to abstract
hardware memories (section 8.9
of [FIRRTL language specification](https://github.com/chipsalliance/firrtl-spec/releases/latest/download/spec.pdf)).
It specifically offers `mem`, `cmem` and `smem` types. Chisel on the other hand offers `SRAM`, `Mem` and `SyncMem`
abstractions which are translated to their corresponding type.
During the translation, memories have their "Def" `Command` abstraction similarly to registers and wires.

Memories can be seen as "collections" of objects similarly to vectors. However, they (except ROMs) have additional
properties such as
read/write ports. And they don't extend `Data` so the methods used to annotate `Data` won't work for memories.

> **NOTE**: by running my experiments I noted that the inner type of a memory can be annotated only if the memory is
> actually used.

[//]: # (> Even if, when a memory is instantiated, this seems to have an inner type this is actually the internal type
[//]: # (> of the memory&#41;)

## ROMs

ROMs can be defined as `Vec`s, therefore their annotation is exactly the same as the one for `Vec`s.

For this reason their annotation sample is not reported here. However, their test is included next to the other
memories.

## SyncReadMem

```scala
class TopCircuitSyncMem[T <: Data](gen: T) extends Module {
  val mem = SyncReadMem(4, gen)
}

```

### Annotation for SyncReadMem of Ground Type: UInt<8>

```fir
circuit TopCircuitSyncMem :%[[
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSyncMem|TopCircuitSyncMem",
    "typeName":"TopCircuitSyncMem"
  },
  ; .. clock and reset anno
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSyncMem|TopCircuitSyncMem>mem",
    "typeName":"SyncReadMem[UInt<8>[4]]"
  }
]]
  public module TopCircuitSyncMem : @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 250:11]
    input clock : Clock @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 250:11]
    input reset : UInt<1> @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 250:11]
    
    smem mem : UInt<8> [4] @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 251:28]
```

### Annotation of Mem of Complex Type: Bundle

This would apply also for Vecs and other data types.

When only the mem is instantiated, its "child" elements are not annotated. This is because they cannot be targets.
Indeed, it leads to an empty circuit, therefore also the final vcd file will not have the memory.
Also, this makes sense in practice since if a memory is instantiated but not used, it's pointless to show it.

```fir
  public module TopCircuitMem : @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 261:11]
    input clock : Clock @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 261:11]
    input reset : UInt<1> @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 261:11]

    cmem mem : { a : UInt<8>, b : SInt<8>, c : UInt<1>} [4] @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 262:20]
```

To have the inner type of the memory fully annotated also in the case of aggregates, the memory must be used in the
circuit.

```scala
class TopCircuitSyncMem[T <: Data](gen: T) extends Module {
  val mem = SyncReadMem(4, gen)

  val idx = IO(Input(UInt(2.W)))
  val in  = IO(Input(gen))
  val out = IO(Output(gen))
  mem.write(idx, in)
  out := mem.read(idx)
}

```

Output when gen is a Bundle:

```fir
circuit TopCircuitSyncMem :%[[
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSyncMem|TopCircuitSyncMem",
    "typeName":"TopCircuitSyncMem"
  },
  ; .. clock and reset
  ; .. other signals declared in the circuit: idx, in and out 
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSyncMem|TopCircuitSyncMem>mem",
    "typeName":"SyncReadMem[MyBundle[4]]"
  },
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSyncMem|TopCircuitSyncMem>MPORT.c",
    "typeName":"MemPort[Bool]"
  },
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSyncMem|TopCircuitSyncMem>MPORT.b",
    "typeName":"MemPort[SInt<8>]"
  },
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSyncMem|TopCircuitSyncMem>MPORT.a",
    "typeName":"MemPort[UInt<8>]"
  },
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSyncMem|TopCircuitSyncMem>MPORT",
    "typeName":"MemPort[MyBundle]"
  },
  ; autogenerated out_MPORT (same as MPORT)
]]
    public module TopCircuitSyncMem : @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 250:11]
    input clock : Clock @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 250:11]
    input reset : UInt<1> @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 250:11]
    input idx : UInt<2> @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 253:21]
    input in : { a : UInt<8>, b : SInt<8>, c : UInt<1>} @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 254:20]
    output out : { a : UInt<8>, b : SInt<8>, c : UInt<1>} @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 255:21]

    smem mem : { a : UInt<8>, b : SInt<8>, c : UInt<1>} [4] @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 251:28]
    write mport MPORT = mem[idx], clock @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 256:18]
    connect MPORT, in @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 256:18]
    wire _out_WIRE : UInt<2> @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 257:24]
    invalidate _out_WIRE @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 257:24]
    when UInt<1>(0h1) : @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 257:24]
      connect _out_WIRE, idx @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 257:24]
      read mport out_MPORT = mem[_out_WIRE], clock @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 257:24]
    connect out, out_MPORT @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 257:13]

```

## Mem

```scala
class TopCircuitMem[T <: Data](gen: T) extends Module {
  val mem = Mem(4, gen)
}

```

### Annotation of Mem of Ground Type: UInt<8>

```fir
circuit TopCircuitMem :%[[
 
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitMem|TopCircuitMem",
    "typeName":"TopCircuitMem"
  },
  ; .. clock and reset anno
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitMem|TopCircuitMem>mem",
    "typeName":"Mem[UInt<8>[4]]"
  }
]]
  public module TopCircuitMem : @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 261:11]
    input clock : Clock @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 261:11]
    input reset : UInt<1> @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 261:11]

    cmem mem : UInt<8> [4] @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 262:20]
```

### Annotation of Mem of Complex Type: Bundle

Same as `SyncReadMem`

## SRAMs

The `SRAM` is a bit more complex than the other memories. It has read, write and read-write ports. The annotation
emitted
are therefore more and each typology of port is annotated as well as each component declared inside the `SRAM`
abstraction. These ports are Vec of bundles (e.g. `MemoryReadPort`, `MemoryWritePort`, `MemoryReadWritePort`).
Therefore, their annotations follows the same pattern as the one for `Vec`s.

However, the SRAM instantiates both an `SRAMInterface` and the sram itself. The ports are part of the interface.

```scala
class TopCircuitSRAM(size: Int, numReadPorts: Int, numWritePorts: Int, numReadwritePorts: Int) extends Module {
  val mem = SRAM(size, UInt(8.W), numReadPorts, numWritePorts, numReadwritePorts)
}

```

```fir
circuit TopCircuitSRAM :%[[
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSRAM|TopCircuitSRAM",
    "typeName":"TopCircuitSRAM",
    "params":[
      {
        "name":"size",
        "typeName":"Int",
        "value":"1"
      },
      {
        "name":"numReadPorts",
        "typeName":"Int",
        "value":"1"
      },
      {
        "name":"numWritePorts",
        "typeName":"Int",
        "value":"1"
      },
      {
        "name":"numReadwritePorts",
        "typeName":"Int",
        "value":"0"
      }
    ]
  },
  ; .. clock and reset anno
  ; ..  read, write and readwrite ports annotations
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSRAM|TopCircuitSRAM>mem",
    "typeName":"Wire[SRAMInterface]",
    "params":[
      {
        "name":"tpe",
        "typeName":"T"
      },
      {
        "name":"numReadPorts",
        "typeName":"Int"
      },
      {
        "name":"numWritePorts",
        "typeName":"Int"
      },
      {
        "name":"numReadwritePorts",
        "typeName":"Int"
      },
      {
        "name":"masked",
        "typeName":"Boolean"
      }
    ]
  },
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSRAM|TopCircuitSRAM>mem_sram",
    "typeName":"SramTarget[UInt<8>[1]]"
  }
]]
  public module TopCircuitSRAM : @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 272:11]
    input clock : Clock @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 272:11]
    input reset : UInt<1> @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 272:11]

    wire mem : { readPorts : { flip address : UInt<1>, flip enable : UInt<1>, data : UInt<8>}[1], writePorts : { flip address : UInt<1>, flip enable : UInt<1>, flip data : UInt<8>}[1], readwritePorts : { flip address : UInt<1>, flip enable : UInt<1>, flip isWrite : UInt<1>, readData : UInt<8>, flip writeData : UInt<8>}[1]} @[src/main/scala/chisel3/util/SRAM.scala 481:20]
    mem mem_sram : @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 273:21]
      data-type => UInt<8>
      depth => 1
      read-latency => 1
      write-latency => 1
      reader => R0
      writer => W0
      readwriter => RW0
      read-under-write => undefined
    connect mem_sram.R0.addr, mem.readPorts[0].address @[src/main/scala/chisel3/util/SRAM.scala 528:27]
    connect mem_sram.R0.clk, clock @[src/main/scala/chisel3/util/SRAM.scala 529:26]
    connect mem.readPorts[0].data, mem_sram.R0.data @[src/main/scala/chisel3/util/SRAM.scala 530:24]
    connect mem_sram.R0.en, mem.readPorts[0].enable @[src/main/scala/chisel3/util/SRAM.scala 531:25]
    connect mem_sram.W0.addr, mem.writePorts[0].address @[src/main/scala/chisel3/util/SRAM.scala 534:28]
    connect mem_sram.W0.clk, clock @[src/main/scala/chisel3/util/SRAM.scala 535:27]
    connect mem_sram.W0.data, mem.writePorts[0].data @[src/main/scala/chisel3/util/SRAM.scala 536:47]
    connect mem_sram.W0.en, mem.writePorts[0].enable @[src/main/scala/chisel3/util/SRAM.scala 537:26]
    connect mem_sram.W0.mask, UInt<1>(0h1) @[src/main/scala/chisel3/util/SRAM.scala 576:34]
    connect mem_sram.RW0.addr, mem.readwritePorts[0].address @[src/main/scala/chisel3/util/SRAM.scala 544:32]
    connect mem_sram.RW0.clk, clock @[src/main/scala/chisel3/util/SRAM.scala 545:31]
    connect mem_sram.RW0.en, mem.readwritePorts[0].enable @[src/main/scala/chisel3/util/SRAM.scala 546:30]
    connect mem.readwritePorts[0].readData, mem_sram.RW0.rdata @[src/main/scala/chisel3/util/SRAM.scala 547:33]
    connect mem_sram.RW0.wdata, mem.readwritePorts[0].writeData @[src/main/scala/chisel3/util/SRAM.scala 548:52]
    connect mem_sram.RW0.wmode, mem.readwritePorts[0].isWrite @[src/main/scala/chisel3/util/SRAM.scala 549:33]
    connect mem_sram.RW0.wmask, UInt<1>(0h1) @[src/main/scala/chisel3/util/SRAM.scala 576:34]
```

### Annotation of SRAM of Complex Type: Bundle

Contrary to the other memories, the SRAM does not need to be connected to be fully instantiated. Therefore, also the
following example leads to bundle sub-element annotation.

```scala
class TopCircuitSRAM(size: Int, numReadPorts: Int, numWritePorts: Int, numReadwritePorts: Int) extends Module {
  val mem = SRAM(size, new MyBundle, numReadPorts, numWritePorts, numReadwritePorts)
}

```

```fir
circuit TopCircuitSRAM :%[[
  ; .. clock and reset annotations
  ; .. other control signals (same as ground types)
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSRAM|TopCircuitSRAM>mem.writePorts[0].data.c",
    "typeName":"Wire[Bool]"
  },
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSRAM|TopCircuitSRAM>mem.writePorts[0].data.b",
    "typeName":"Wire[SInt<8>]"
  },
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSRAM|TopCircuitSRAM>mem.writePorts[0].data.a",
    "typeName":"Wire[UInt<8>]"
  },
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSRAM|TopCircuitSRAM>mem.writePorts[0].data",
    "typeName":"Wire[MyBundle]"
  },
  ; .. other ports (same as ground above)
  {
    "class":"chisel3.tywaves.TywavesAnnotation",
    "target":"~TopCircuitSRAM|TopCircuitSRAM>mem",
    "typeName":"Wire[SRAMInterface]",
    "params":[
      {
        "name":"tpe",
        "typeName":"T"
      },
      {
        "name":"numReadPorts",
        "typeName":"Int"
      },
      {
        "name":"numWritePorts",
        "typeName":"Int"
      },
      {
        "name":"numReadwritePorts",
        "typeName":"Int"
      },
      {
        "name":"masked",
        "typeName":"Boolean"
      }
    ]
  },
]]
  public module TopCircuitSRAM : @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 272:11]
    input clock : Clock @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 272:11]
    input reset : UInt<1> @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 272:11]

    wire mem : { readPorts : { flip address : UInt<1>, flip enable : UInt<1>, data : { a : UInt<8>, b : SInt<8>, c : UInt<1>}}[1], writePorts : { flip address : UInt<1>, flip enable : UInt<1>, flip data : { a : UInt<8>, b : SInt<8>, c : UInt<1>}}[1], readwritePorts : { flip address : UInt<1>, flip enable : UInt<1>, flip isWrite : UInt<1>, readData : { a : UInt<8>, b : SInt<8>, c : UInt<1>}, flip writeData : { a : UInt<8>, b : SInt<8>, c : UInt<1>}}[0]} @[src/main/scala/chisel3/util/SRAM.scala 481:20]
    mem mem_sram : @[src/test/scala/circtTests/tywavesTests/TywavesAnnotationCircuits.scala 274:21]
      data-type => { a : UInt<8>, b : SInt<8>, c : UInt<1>}
      depth => 1
      read-latency => 1
      write-latency => 1
      reader => R0
      writer => W0
      read-under-write => undefined
    connect mem_sram.R0.addr, mem.readPorts[0].address @[src/main/scala/chisel3/util/SRAM.scala 528:27]
    connect mem_sram.R0.clk, clock @[src/main/scala/chisel3/util/SRAM.scala 529:26]
    connect mem.readPorts[0].data, mem_sram.R0.data @[src/main/scala/chisel3/util/SRAM.scala 530:24]
    connect mem_sram.R0.en, mem.readPorts[0].enable @[src/main/scala/chisel3/util/SRAM.scala 531:25]
    connect mem_sram.W0.addr, mem.writePorts[0].address @[src/main/scala/chisel3/util/SRAM.scala 534:28]
    connect mem_sram.W0.clk, clock @[src/main/scala/chisel3/util/SRAM.scala 535:27]
    connect mem_sram.W0.data, mem.writePorts[0].data @[src/main/scala/chisel3/util/SRAM.scala 536:47]
    connect mem_sram.W0.en, mem.writePorts[0].enable @[src/main/scala/chisel3/util/SRAM.scala 537:26]
    connect mem_sram.W0.mask.c, UInt<1>(0h1) @[src/main/scala/chisel3/util/SRAM.scala 576:34]
    connect mem_sram.W0.mask.b, UInt<1>(0h1) @[src/main/scala/chisel3/util/SRAM.scala 576:34]
    connect mem_sram.W0.mask.a, UInt<1>(0h1) @[src/main/scala/chisel3/util/SRAM.scala 576:34]
```