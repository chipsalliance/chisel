defpackage firrtl/compiler :
  import core
  import verse
  import firrtl/passes
  ;import firrtl/errors
  ;import firrtl/flo
  ;import firrtl/verilog
  import firrtl/ir2
  import firrtl/ir-utils

;public defstruct StandardFlo <: Compiler :
;   with-output : (() -> False) -> False with: (as-method => true)
;public defmethod passes (c:StandardFlo) -> List<Pass> :
;   to-list $ [
;      RemoveSpecialChars()
;      RemoveScopes()
;      CheckHighForm()
;      ;; TempElimination()
;      ToWorkingIR()
;      ResolveKinds()
;      CheckKinds()
;      InferTypes()
;      CheckTypes()
;      ResolveGenders()
;      CheckGenders()
;      ExpandAccessors()
;      LowerToGround()
;      InlineIndexed()
;      ExpandWhens()
;      InferWidths()
;      Pad()
;      Inline()
;      SplitExp()
;      ToRealIR()
;      CheckWidths()
;      ;RemoveSpecialChars()
;      CheckHighForm()
;      CheckLowForm()
;      Flo(with-output(c))
;   ]

public defstruct StandardVerilog <: Compiler :
   with-output : (() -> False) -> False with: (as-method => true)
public defmethod backend (c:StandardVerilog) -> List<Pass> :
  to-list $ [ Verilog(with-output(c)) ]
public defmethod passes (c:StandardVerilog) -> List<Pass> :
   to-list $ [
      ;RemoveSpecialChars()     ;R
      ;RemoveScopes()           ;R
      ;CheckHighForm()          ;R
      ;TempElimination()        ;R         ; Needs to check number of uses
      ToWorkingIR()            ;R -> W
      ResolveKinds()           ;W
      InferTypes()             ;R
      ResolveGenders()         ;W
      ;CheckGenders()           ;W
      ;CheckKinds()             ;W
      ;CheckTypes()             ;R
      ;ExpandAccesses()        ;W
      ExpandConnects()        ;W
      RemoveAccesses()
      ResolveKinds()           ;W
      InferTypes()             ;R
      ResolveGenders()         ;W
      ;LowerToGround()          ;W
      ;ExpandIndexedConnects()  ;W
      ;InferTypes()             ;R
      ;CheckGenders()           ;W
      ExpandWhens()            ;W
      ResolveKinds()           ;W
      InferTypes()             ;R
      ResolveGenders()         ;W
      InferWidths()            ;R
      ;ToRealIR()               ;W -> R
      ;CheckWidths()            ;R
      ;Pad()                    ;R
      ConstProp()              ;R
      SplitExp()               ;R
      LowerTypes()               ;R
      ResolveKinds()           ;W
      InferTypes()             ;R
      ResolveGenders()         ;W
      ;CheckWidths()            ;R
      ;CheckHighForm()          ;R
      ;CheckLowForm()           ;R
      ;CheckInitialization()    ;R
      Verilog(with-output(c))  ;R
   ]

public defstruct StandardFIRRTL <: Compiler :
   with-output : (() -> False) -> False with: (as-method => true)
public defmethod backend (c:StandardFIRRTL) -> List<Pass> :
  to-list $ [ FIRRTL(with-output(c)) ]
public defmethod passes (c:StandardFIRRTL) -> List<Pass> :
   to-list $ [
      CheckHighForm()
      FIRRTL(with-output(c))
    ]


public defstruct StandardLoFIRRTL <: Compiler :
   with-output : (() -> False) -> False with: (as-method => true)
public defmethod backend (c:StandardLoFIRRTL) -> List<Pass> :
  to-list $ [ FIRRTL(with-output(c)) ]
public defmethod passes (c:StandardLoFIRRTL) -> List<Pass> :
   to-list $ [
      RemoveSpecialChars()     ;R
      ;RemoveScopes()           ;R
      CheckHighForm()          ;R
      TempElimination()        ;R
      ToWorkingIR()            ;R -> W
      ResolveKinds()           ;W
      InferTypes()             ;R
      ResolveGenders()         ;W
      CheckGenders()           ;W
      CheckKinds()             ;W
      CheckTypes()             ;R
      ExpandAccessors()        ;W
      LowerToGround()          ;W
      ;ExpandIndexedConnects()  ;W
      InlineIndexed()
      InferTypes()             ;R
      CheckGenders()           ;W
      ExpandWhens()            ;W
      InferWidths()            ;R
      ToRealIR()               ;W -> R
      CheckWidths()            ;R
      Pad()                    ;R
      ConstProp()              ;R
      SplitExp()               ;R
      CheckWidths()            ;R
      CheckHighForm()          ;R
      CheckLowForm()           ;R
      CheckInitialization()    ;R
      FIRRTL(with-output(c))  ;R
   ]

;============= DRIVER ======================================
public defn run-backend (c:Circuit,comp:Compiler) :
   run-passes(c,backend(comp))
public defn run-passes (c:Circuit,comp:Compiler) -> Circuit: 
   run-passes(c,passes(comp))
public defn run-passes (c:Circuit,ls:List<Pass>) -> Circuit:
   var c*:Circuit = c
   println("Compiling!")
   if PRINT-CIRCUITS : println("Original Circuit")
   if PRINT-CIRCUITS : print(c)
   ;val start-time = current-time-us()
   val start-time = to-int(to-string(current-time-us() / to-long(1000)))
   var t = start-time
   val time-table = Vector<[String,Int]>()
   for p in ls do : 
      println-all(["Starting " name(p)])
      if PRINT-CIRCUITS : println(name(p))
      c* = pass(p)(c*)
      if PRINT-CIRCUITS : print(c*)
      val current-time = to-int(to-string(current-time-us() / to-long(1000)))
      println-all(["Finished " name(p)])
      println-all(["Milliseconds since start: " current-time - start-time])
      println-all(["Milliseconds for this pass: " current-time - t])
      println-all(["\n"])
      add(time-table,[name(p), current-time - t])
      t = current-time

   println("===== Time Breakdown =====")
   for x in time-table do :
      println-all([x[0] " --- " to-float(x[1] as Int * 100) / to-float(t - start-time) "%"])
   println("==========================")
   println("Done!")
   c*
