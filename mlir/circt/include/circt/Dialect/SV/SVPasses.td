//===-- SVPasses.td - SV pass definition file --------------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file contains definitions for passes that work on the SV dialect.
//
//===----------------------------------------------------------------------===//

#ifndef CIRCT_DIALECT_SV_SVPASSES
#define CIRCT_DIALECT_SV_SVPASSES

include "mlir/Pass/PassBase.td"

def HWCleanup : Pass<"hw-cleanup", "hw::HWModuleOp"> {
  let summary = "Cleanup transformations for operations in hw.module bodies";
  let description = [{
      This pass merges sv.alwaysff operations with the same condition, sv.ifdef
      nodes with the same condition, and perform other cleanups for the IR.
      This is a good thing to run early in the HW/SV pass pipeline to expose
      opportunities for other simpler passes (like canonicalize).
  }];

  let options = [
    Option<"mergeAlwaysBlocks", "merge-always-blocks", "bool",
           "true", "Allow always and always_ff blocks to be merged">
  ];

  let constructor = "circt::sv::createHWCleanupPass()";
}

def HWLegalizeModules : Pass<"hw-legalize-modules", "hw::HWModuleOp"> {
  let summary = "Eliminate features marked unsupported in LoweringOptions";
  let description = [{
      This pass lowers away features in the SV/Comb/HW dialects that are
      unsupported by some tools, e.g. multidimensional arrays.  This pass is
      run relatively late in the pipeline in preparation for emission.  Any
      passes run after this must be aware they cannot introduce new invalid
      constructs.
  }];

  let constructor = "circt::sv::createHWLegalizeModulesPass()";
}

def PrettifyVerilog : Pass<"prettify-verilog", "hw::HWModuleOp"> {
  let summary = "Transformations to improve quality of ExportVerilog output";
  let description = [{
      This pass contains elective transformations that improve the quality of
      SystemVerilog generated by the ExportVerilog library.  This pass is not
      compulsory: things that are required for ExportVerilog to be correct
      should be included as part of the ExportVerilog pass itself to make sure
      it is self contained.
  }];

  let constructor = "circt::sv::createPrettifyVerilogPass()";
}

def HWStubExternalModules : Pass<"hw-stub-external-modules",
                                  "mlir::ModuleOp"> {
  let summary = "transform external hw modules to empty hw modules";
  let description = [{
      This pass creates empty module bodies for external modules.  This is
      useful for linting to eliminate missing file errors.
  }];

  let constructor = "circt::sv::createHWStubExternalModulesPass()";
  let dependentDialects = ["circt::sv::SVDialect"];
}

def HWGeneratorCalloutPass : Pass<"hw-generator-callout", "ModuleOp"> {
  let summary = "Lower Generator Schema to external module";
  let description = [{
    This pass calls an external program for all the hw.module.generated nodes,
    following the description in the hw.generator.schema node.
  }];
  let constructor = "circt::sv::createHWGeneratorCalloutPass()";

  let options = [
    Option<"schemaName", "schema-name", "std::string",
                "", "Name of the schema to process">,
    Option<"genExecutable", "generator-executable", "std::string",
                "", "Generator program executable with optional full path">,
    Option<"genExecArgs", "generator-executable-arguments", "std::string",
                "", "Generator program arguments separated by ;">,
   ];
}

def HWMemSimImpl : Pass<"hw-memory-sim", "ModuleOp"> {
  let summary = "Implement FIRRTMMem memories nodes with simulation model";
  let description = [{
    This pass replaces generated module nodes of type FIRRTLMem with a model
    suitable for simulation.
  }];

  let constructor = "circt::sv::createHWMemSimImplPass()";
  let dependentDialects = ["circt::sv::SVDialect"];

  let options = [
    Option<"disableMemRandomization", "disable-mem-randomization", "bool", "false",
            "Disable emission of memory randomization code">,
    Option<"disableRegRandomization", "disable-reg-randomization", "bool", "false",
            "Disable emission of register randomization code">,
    Option<"replSeqMem", "repl-seq-mem", "bool",
                "false", "Prepare seq mems for macro replacement">,
    Option<"ignoreReadEnable", "ignore-read-enable", "bool",
                "false",
    "ignore the read enable signal, instead of assigning X on read disable">,
    Option<"addMuxPragmas", "add-mux-pragmas", "bool", "false",
            "Add mux pragmas to memory reads">,
    Option<"addVivadoRAMAddressConflictSynthesisBugWorkaround",
           "add-vivado-ram-address-conflict-synthesis-bug-workaround", "bool", "false",
            "Add a vivado attribute to specify a ram style of an array register">

   ];
}

def SVExtractTestCode : Pass<"sv-extract-test-code", "ModuleOp"> {
  let summary = "Extract simulation only constructs to modules and bind";
  let description = [{
    This pass extracts cover, assume, assert operations to a module, along with
    any ops feeding them only, to modules which are instantiated with a bind
    statement.
  }];

  let constructor = "circt::sv::createSVExtractTestCodePass()";
  let dependentDialects = ["circt::sv::SVDialect"];
  let options = [
    Option<"disableInstanceExtraction", "disable-instance-extraction", "bool",
           "false", "Disable extracting instances only that feed test code">,
    Option<"disableRegisterExtraction", "disable-register-extraction", "bool",
           "false", "Disable extracting registers only that feed test code">,
    Option<"disableModuleInlining", "disable-module-inlining", "bool",
           "false", "Disable inlining modules that only feed test code">
  ];
  let statistics = [
    Statistic<"numOpsExtracted", "num-ops-extracted", "Number of ops extracted">,
    Statistic<"numOpsErased", "num-ops-erased", "Number of ops erased">
  ];
}

def SVTraceIVerilog : Pass<"sv-trace-iverilog", "ModuleOp"> {
  let summary = "Add tracing to an iverilog simulated module";
  let description = [{
    This pass adds the necessary instrumentation to a HWModule to trigger
    tracing in an iverilog simulation.
  }];

  let constructor = "circt::sv::createSVTraceIVerilogPass()";
  let dependentDialects = ["circt::sv::SVDialect"];
  let options = [
    Option<"topOnly", "top-only", "bool", "true",
            "If true, will only add tracing to the top-level module.">,
    Option<"targetModuleName", "module", "std::string", "",
            "Module to trace. If not provided, will trace all modules">,
    Option<"directoryName", "dir-name", "std::string", "\"./\"",
            "Directory to emit into">
  ];
}

def HWExportModuleHierarchy : Pass<"hw-export-module-hierarchy",
                                   "mlir::ModuleOp"> {
  let summary = "Export module and instance hierarchy information";
  let description = [{
    This pass exports the module and instance hierarchy tree for each module
    with the firrtl.moduleHierarchyFile attribute. These are lowered to
    sv.verbatim ops with the output_file attribute.
  }];

  let constructor = "circt::sv::createHWExportModuleHierarchyPass()";
  let dependentDialects = ["circt::sv::SVDialect"];
}

def HWEliminateInOutPorts : Pass<"hw-eliminate-inout-ports",
                             "mlir::ModuleOp"> {
  let summary = "Raises usages of inout ports into explicit input and output ports";
  let description = [{
    This pass raises usages of inout ports into explicit in- and output ports.
    This is done by analyzing the usage of the inout ports and creating new
    input and output ports at the using module, and subsequently moving the
    inout read- and writes to the instantiation site.
  }];
  let constructor = "circt::sv::createHWEliminateInOutPortsPass()";
  let dependentDialects = ["circt::sv::SVDialect"];
}

#endif // CIRCT_DIALECT_SV_SVPASSES
