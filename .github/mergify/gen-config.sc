#!/usr/bin/env -S scala-cli shebang
// SPDX-License-Identifier: Apache-2.0
//> using scala "2.13"
//> using dep "io.circe::circe-yaml:0.16.0"
//> using dep "com.lihaoyi::os-lib:0.11.3"

/* Generates a Mergify config YAML (to STDOUT) based on input config
 *
 * There are built-in conditions, but different CI requires different conditions
 * Listed branches should be stable branches that we want to backport to, in ascending order
 *
 * conditions:
     - status-success=all tests passed
   branches:
     - 3.6.x
     - 5.x
     - 6.x
 *
 */

import io.circe._
import io.circe.syntax._ // for .asJson
import io.circe.yaml.parser
import io.circe.yaml.syntax._ // for .asYaml

def mergeQueue(branch: String, conditions: List[String]) = Json.obj(
  "name" -> s"$branch merge queue".asJson,
  "queue_conditions" -> (conditions ++ List(
    s"base=$branch",
    "#changes-requested-reviews-by=0",
    "label=\"Backport\"",
    "label!=\"DO NOT MERGE\"",
    "label!=\"bp-conflict\""
  )).asJson,
  "merge_conditions" -> conditions.asJson,
  "draft_bot_account" -> "chiselbot".asJson,
  "update_bot_account" -> "chiselbot".asJson,
  "merge_bot_account" -> "chiselbot".asJson
)

def makeBackportRule(branches: List[String]): Json = {
  Json.obj(
    "name" -> s"""backport to ${branches.mkString(", ")}""".asJson,
    "conditions" -> List("merged", s"milestone=${branches.head}").asJson,
    "actions" -> Json.obj(
      "backport" -> Json.obj(
        "branches" -> branches.asJson,
        "labels" -> List("Backport").asJson,
        "ignore_conflicts" -> true.asJson,
        "merge_conflict_style" -> "diff3".asJson,
        "label_conflicts" -> "bp-conflict".asJson,
        "bot_account" -> "chiselbot".asJson,
        "report_mode" -> List("comment").asJson
      ),
      "label" -> Json.obj(
        "add" -> List("Backported").asJson
      )
    )
  )
}

def backportMergeRule(conditions: List[String])(branch: String): Json = Json.obj(
  "name" -> s"queue $branch backport PRs".asJson,
  "conditions" -> (conditions ++ List(
    "#changes-requested-reviews-by=0",
    s"base=$branch",
    "label=\"Backport\"",
    "label!=\"DO NOT MERGE\"",
    "label!=\"bp-conflict\""
  )).asJson,
  "actions" -> Json.obj(
    "queue" -> Json.obj(
      "name" -> s"$branch merge queue".asJson
    )
  )
)

def error(msg: String) = throw new Exception(msg) with scala.util.control.NoStackTrace

def processTemplate(path: os.Path): (List[String], List[String]) = {
  val contents = os.read(path)
  val parsed = parser
    .parse(contents)
    .getOrElse(error(s"Invalid YAML $path"))

  val cursor: HCursor = parsed.hcursor

  val conditions = cursor
    .downField("conditions")
    .as[List[String]]
    .getOrElse(error(s"Invalid template, expected field 'conditions': List[String]"))

  val branches = cursor
    .downField("branches")
    .as[List[String]]
    .getOrElse(error(s"Invalid template, expected field 'branches': List[String]"))
  (conditions, branches)
}

require(args.size == 1, "Usage: <config yaml>")
val template = os.Path(os.RelPath(args(0)), os.pwd)

val (conditions, branches) = processTemplate(template)

val branchSets = branches.scanRight(List.empty[String])(_ :: _).init.reverse

val config = Json.obj(
  "queue_rules" -> Json.fromValues(
    branches.map(mergeQueue(_, conditions))
  ),
  "pull_request_rules" -> Json.fromValues(
    branchSets.map(makeBackportRule) :::
      branches.map(backportMergeRule(conditions))
  )
)

println(s"# Generated by $scriptPath")
val printer = io.circe.yaml.Printer(preserveOrder = true, indent = 2)
println(printer.pretty(config))
