## GUIDE TO CONTRIBUTING

1. If you need help on making a pull request, follow this [guide](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests).

2. To understand how to compile and test chisel3 from the source code, install the [required dependencies](https://www.chisel-lang.org/docs/installation).

3. In order to contribute to chisel3, you'll need to sign the CLA agreement. You will be asked to sign it upon your first pull request.

<!-- This ones helped me a lot -->

4. To introduce yourself and get help, you can join the [gitter](https://gitter.im/freechipsproject/chisel3) forum. If you have any questions or concerns, you can get help there.

5. You can peruse the [good-first-issues](https://github.com/chipsalliance/chisel3/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22) for easy tasks to start with. Another easy thing to start with is doing your own pass of the [website](https://www.chisel-lang.org/chisel3/docs/introduction.html) looking for typos, pages missing their titles, etc. The sources for the website are [here](https://github.com/chipsalliance/chisel3/tree/master/docs).

6. Please make your PRs against the `main` branch. The project admins, when reviewing your PR, will decide which stable version (if any) your change should be backported to. They will apply the appropriate `milestone` marker which controls which branches the backport will be opened to. The backports will be opened automatically on your behalf once your `main` PR is merged.

7. The PR template will require you to select "Type of Improvement." A reviewer or someone with write access will add the appropriate label to your PR based on this type of improvement which will include your PR in the correct category in the release notes.

8. If your backport PR(s) get labeled with `bp-conflict`, it means they cannot be automatically be merged. You can help get them merged by openening a PR against the already-existing backport branch (will be named something like `mergify/bp/3.5.x/pr-2512`) with the necessary cleanup changes. The admins will merge your cleanup PR and remove the `bp-conflict` label if appropriate.


### Frequently Asked Questions

#### I'm failing the formatting check. How do I make sure my code is formatted?

From the Chisel root directory, run:

```sh
# Reformat normal source files
./mill __.reformat

# Reformat mill build files
./mill --meta-level 1 mill.scalalib.scalafmt.ScalafmtModule/reformatAll sources
```

---

## Internal Documentation

This section describes the internal Chisel components for contributors.

### CIRCT Converter

There is a highly experimental component CIRCT Converter (a.k.a. Panama Converter). It is powered by [Java's Panama framework](https://openjdk.org/projects/panama/) to interact directly with CIRCT by calling the C-APIs of MLIR and CIRCT directly from Scala, enabling seamless emitting Chisel IR to CIRCT FIRRTL Dialect IR (no serialization and deserialization for FIRRTL), flexible executing Passes with PassManager, lowering to / exporting SystemVerilog, accesing OM data, and more.

#### Directory `circtpanamabinding`

Here defines the needed CIRCT items that will be processed by the Panama framework's [jextract](https://github.com/openjdk/jextract) tool for codegen FFI Java code to use in Scala.

#### Directory `panamalib`

It provides a type-safe wrapper for the FFI code generated by jextract.

#### File `PanamaCIRCTConverter.scala`

Here is the implementation of how each Chisel IR will be emitted to the CIRCT.

It needs to be highly synchronized with CIRCT upstream. When updating it, you can refer to [CIRCT's FIRRTL Dialect documentation](https://circt.llvm.org/docs/Dialects/FIRRTL/). Some dialect-specific types, conversions may require a specialized C-API function to return from CIRCT, in which case you can open a PR in CIRCT upstream to add it and use it here.

#### File `PanamaCIRCTPassManager.scala`

It provides a PassManager, which is used in place of the firtool cli.

#### File `PanamaCIRCTOM.scala`

After using PassManager to lowering the FIRRTL Dialect to the HW Dialect, you will be able to access the OM data in it.

The data types of the OM are defined here, as well as the way to access them. This is an example of printing out all the `Top_Class` fields.

```scala
val pm = converter.passManager()
assert(pm.populateFinalizeIR())
assert(pm.run())

val om = converter.om()
val evaluator = om.evaluator()

val top = evaluator.instantiate("Top_Class", Seq(om.newBasePathEmpty)).get
top.foreachField((name, value) => println(s".$name => { ${value.toString} }"))
```

#### Directory `lit`

We used llvm-lit and scala-cli to test CIRCT Converter.

To run the test, make sure the environment variables are defined first:

- `JAVA_HOME`: The directory where the Java runtime environment. The Panama framework requires Java 21 and higher.

```
mill -i lit[_].run
```

#### Debugging

When interacting with CIRCT, it is easy to get a JVM crash, which is usually due to an unexpected error inside CIRCT (e.g. an assertion failure). Checking the call stack of the crash will help you to localize the bug.
