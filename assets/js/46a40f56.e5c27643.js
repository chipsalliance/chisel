"use strict";(self.webpackChunkchisel_lang=self.webpackChunkchisel_lang||[]).push([[5497],{5155:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>o});var n=t(4848),r=t(8453);const d={layout:"docs",title:"Operators",section:"chisel3"},i="Chisel Operators",l={id:"explanations/operators",title:"Operators",description:"Chisel defines a set of hardware operators:",source:"@site/docs/explanations/operators.md",sourceDirName:"explanations",slug:"/explanations/operators",permalink:"/docs/explanations/operators",draft:!1,unlisted:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/operators.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Operators",section:"chisel3"},sidebar:"chiselSidebar",previous:{title:"Naming",permalink:"/docs/explanations/naming"},next:{title:"Polymorphism and Parameterization",permalink:"/docs/explanations/polymorphism-and-parameterization"}},c={},o=[];function a(e){const s={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"chisel-operators",children:"Chisel Operators"})}),"\n",(0,n.jsx)(s.p,{children:"Chisel defines a set of hardware operators:"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Operation"}),(0,n.jsx)(s.th,{children:"Explanation"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.strong,{children:"Bitwise operators"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.strong,{children:"Valid on:"})," SInt, UInt, Bool"]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val invertedX = ~x"})}),(0,n.jsx)(s.td,{children:"Bitwise NOT"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:'val hiBits = x & "h_ffff_0000".U'})}),(0,n.jsx)(s.td,{children:"Bitwise AND"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val flagsOut = flagsIn | overflow"})}),(0,n.jsx)(s.td,{children:"Bitwise OR"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val flagsOut = flagsIn ^ toggle"})}),(0,n.jsx)(s.td,{children:"Bitwise XOR"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.strong,{children:"Bitwise reductions."})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.strong,{children:"Valid on:"})," SInt and UInt. Returns Bool."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val allSet = x.andR"})}),(0,n.jsx)(s.td,{children:"AND reduction"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val anySet = x.orR"})}),(0,n.jsx)(s.td,{children:"OR reduction"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val parity = x.xorR"})}),(0,n.jsx)(s.td,{children:"XOR reduction"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.strong,{children:"Equality comparison."})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.strong,{children:"Valid on:"})," SInt, UInt, and Bool. Returns Bool."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val equ = x === y"})}),(0,n.jsx)(s.td,{children:"Equality"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val neq = x =/= y"})}),(0,n.jsx)(s.td,{children:"Inequality"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.strong,{children:"Shifts"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.strong,{children:"Valid on:"})," SInt and UInt"]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val twoToTheX = 1.S << x"})}),(0,n.jsx)(s.td,{children:"Logical shift left"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val hiBits = x >> 16.U"})}),(0,n.jsx)(s.td,{children:"Right shift (logical on UInt and arithmetic on SInt)."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.strong,{children:"Bitfield manipulation"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.strong,{children:"Valid on:"})," SInt, UInt, and Bool."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val xLSB = x(0)"})}),(0,n.jsx)(s.td,{children:"Extract single bit, LSB has index 0."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val xTopNibble = x(15, 12)"})}),(0,n.jsx)(s.td,{children:"Extract bit field from end to start bit position."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:'val usDebt = Fill(3, "hA".U)'})}),(0,n.jsx)(s.td,{children:"Replicate a bit string multiple times."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val float = Cat(sign, exponent, mantissa)"})}),(0,n.jsx)(s.td,{children:"Concatenates bit fields, with first argument on left."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.strong,{children:"Logical Operations"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.strong,{children:"Valid on:"})," Bool"]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val sleep = !busy"})}),(0,n.jsx)(s.td,{children:"Logical NOT"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val hit = tagMatch && valid"})}),(0,n.jsx)(s.td,{children:"Logical AND"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val stall = src1busy || src2busy"})}),(0,n.jsx)(s.td,{children:"Logical OR"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val out = Mux(sel, inTrue, inFalse)"})}),(0,n.jsx)(s.td,{children:"Two-input mux where sel is a Bool"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.strong,{children:"Arithmetic operations"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.strong,{children:"Valid on Nums:"})," SInt and UInt."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"val sum = a + b"})," ",(0,n.jsx)(s.em,{children:"or"})," ",(0,n.jsx)(s.code,{children:"val sum = a +% b"})]}),(0,n.jsx)(s.td,{children:"Addition (without width expansion)"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val sum = a +& b"})}),(0,n.jsx)(s.td,{children:"Addition (with width expansion)"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"val diff = a - b"})," ",(0,n.jsx)(s.em,{children:"or"})," ",(0,n.jsx)(s.code,{children:"val diff = a -% b"})]}),(0,n.jsx)(s.td,{children:"Subtraction (without width expansion)"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val diff = a -& b"})}),(0,n.jsx)(s.td,{children:"Subtraction (with width expansion)"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val prod = a * b"})}),(0,n.jsx)(s.td,{children:"Multiplication"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val div = a / b"})}),(0,n.jsx)(s.td,{children:"Division"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val mod = a % b"})}),(0,n.jsx)(s.td,{children:"Modulus"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.strong,{children:"Arithmetic comparisons"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.strong,{children:"Valid on Nums:"})," SInt and UInt. Returns Bool."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val gt = a > b"})}),(0,n.jsx)(s.td,{children:"Greater than"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val gte = a >= b"})}),(0,n.jsx)(s.td,{children:"Greater than or equal"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val lt = a < b"})}),(0,n.jsx)(s.td,{children:"Less than"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"val lte = a <= b"})}),(0,n.jsx)(s.td,{children:"Less than or equal"})]})]})]}),"\n",(0,n.jsxs)(s.blockquote,{children:["\n",(0,n.jsxs)(s.p,{children:["Our choice of operator names was constrained by the Scala language.\nWe have to use triple equals",(0,n.jsx)(s.code,{children:"==="})," for equality and ",(0,n.jsx)(s.code,{children:"=/="}),"\nfor inequality to allow the\nnative Scala equals operator to remain usable."]}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["The Chisel operator precedence is not directly defined as part of the Chisel language.\nPractically, it is determined by the evaluation order of the circuit,\nwhich naturally follows the ",(0,n.jsx)(s.a,{href:"https://docs.scala-lang.org/tour/operators.html",children:"Scala operator precedence"}),".\nIf in doubt of operator precedence, use parentheses."]}),"\n",(0,n.jsxs)(s.blockquote,{children:["\n",(0,n.jsx)(s.p,{children:"The Chisel/Scala operator precedence is similar but\nnot identical to precedence in Java or C. Verilog has the same operator precedence as C, but VHDL\ndoes not. Verilog has precedence ordering for logic operations, but in VHDL\nthose operators have the same precedence and are evaluated from left to right."}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>i,x:()=>l});var n=t(6540);const r={},d=n.createContext(r);function i(e){const s=n.useContext(d);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(d.Provider,{value:s},e.children)}}}]);