"use strict";(self.webpackChunkchisel_lang=self.webpackChunkchisel_lang||[]).push([[6891],{8224:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>t,default:()=>u,frontMatter:()=>l,metadata:()=>d,toc:()=>c});var s=i(4848),o=i(8453);const l={},t="Module Prefixing",d={id:"explanations/moduleprefix",title:"Module Prefixing",description:"Chisel supports a feature called module prefixing.",source:"@site/docs/explanations/moduleprefix.md",sourceDirName:"explanations",slug:"/explanations/moduleprefix",permalink:"/docs/explanations/moduleprefix",draft:!1,unlisted:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/moduleprefix.md",tags:[],version:"current",frontMatter:{},sidebar:"chiselSidebar",previous:{title:"Memories",permalink:"/docs/explanations/memories"},next:{title:"Modules",permalink:"/docs/explanations/modules"}},r={},c=[];function a(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"module-prefixing",children:"Module Prefixing"})}),"\n",(0,s.jsx)(n.p,{children:"Chisel supports a feature called module prefixing.\nModule prefixing allows you to create namespaces in the Verilog output of your design.\nThey are especially useful for when you want to name a particular subsystem of your design,\nand you want to make it easy to identify which subsystem a file belongs to by its name."}),"\n",(0,s.jsxs)(n.p,{children:["We can open a module prefix block using ",(0,s.jsx)(n.code,{children:"withModulePrefix"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  withModulePrefix("Foo") {\n    // ...\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["All modules defined inside of this block, whether an immediate submodule or a descendent, will be given a prefix ",(0,s.jsx)(n.code,{children:"Foo"}),".\n(The prefix is separated by an underscore ",(0,s.jsx)(n.code,{children:"_"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"For example, suppose we write the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  val sub = withModulePrefix("Foo") {\n    Module(new Sub)\n  }\n}\n\nclass Sub extends Module {\n  // ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The result will be a design with two module definitions: ",(0,s.jsx)(n.code,{children:"Top"})," and ",(0,s.jsx)(n.code,{children:"Foo_Sub"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that the ",(0,s.jsx)(n.code,{children:"val sub ="})," part must be pulled outside of the ",(0,s.jsx)(n.code,{children:"withModulePrefix"})," block,\nor else the module will not be accessible to the rest of the ",(0,s.jsx)(n.code,{children:"Top"})," module."]}),"\n",(0,s.jsxs)(n.p,{children:["If a generator is run in multiple prefix blocks, the result is multiple identical copies of the module definition,\neach with its own distinct prefix.\nFor example, consider if we create two instances of ",(0,s.jsx)(n.code,{children:"Sub"})," above like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  val foo_sub = withModulePrefix("Foo") {\n    Module(new Sub)\n  }\n\n  val bar_sub = withModulePrefix("Bar") {\n    Module(new Sub)\n  }\n}\n\nclass Sub extends Module {\n  // ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Then, the resulting Verilog will have three module definitions: ",(0,s.jsx)(n.code,{children:"Top"}),", ",(0,s.jsx)(n.code,{children:"Foo_Sub"}),", and ",(0,s.jsx)(n.code,{children:"Bar_Sub"}),".\nBoth ",(0,s.jsx)(n.code,{children:"Foo_Sub"})," and ",(0,s.jsx)(n.code,{children:"Bar_Sub"})," will be identical to each other."]}),"\n",(0,s.jsx)(n.p,{children:"Module prefixes can also be nested."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  val mid = withModulePrefix("Foo") {\n    Module(new Mid)\n  }\n}\n\nclass Mid extends Module {\n  val sub = withModulePrefix("Bar") {\n    Module(new Sub)\n  }\n}\n\nclass Sub extends Module {\n  // ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This results in three module definitions: ",(0,s.jsx)(n.code,{children:"Top"}),", ",(0,s.jsx)(n.code,{children:"Foo_Mid"}),", and ",(0,s.jsx)(n.code,{children:"Foo_Bar_Sub"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"withModulePrefix"})," blocks also work with the ",(0,s.jsx)(n.code,{children:"Instantiate"})," API."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.experimental.hierarchy.{instantiable, Instantiate}\n\n@instantiable\nclass Sub extends Module {\n  // ...\n}\n\nclass Top extends Module {\n  val foo_sub = withModulePrefix("Foo") {\n    Instantiate(new Sub)\n  }\n\n  val bar_sub = withModulePrefix("Bar") {\n    Instantiate(new Sub)\n  }\n\n  val noprefix_sub = Instantiate(new Sub)\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, we end up with four modules: ",(0,s.jsx)(n.code,{children:"Top"}),", ",(0,s.jsx)(n.code,{children:"Foo_Sub"}),", ",(0,s.jsx)(n.code,{children:"Bar_Sub"}),", and ",(0,s.jsx)(n.code,{children:"Sub"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When using ",(0,s.jsx)(n.code,{children:"Definition"})," and ",(0,s.jsx)(n.code,{children:"Instance"}),", all ",(0,s.jsx)(n.code,{children:"Definition"})," calls will be affected by ",(0,s.jsx)(n.code,{children:"withModulePrefix"}),".\nHowever, ",(0,s.jsx)(n.code,{children:"Instance"})," will not be effected, since it always creates an instance of the captured definition."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"BlackBox"})," and ",(0,s.jsx)(n.code,{children:"ExtModule"})," are unaffected by ",(0,s.jsx)(n.code,{children:"withModulePrefix"}),".\nIf you wish to have one that is sensitive to the module prefix,\nyou can explicitly name the module like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.experimental.hierarchy.{instantiable, Instantiate}\nimport chisel3.experimental.ExtModule\n\nclass Sub extends ExtModule {\n  override def desiredName = modulePrefix + "Sub"\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>d});var s=i(6540);const o={},l=s.createContext(o);function t(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);