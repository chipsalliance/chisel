"use strict";(self.webpackChunkchisel_lang=self.webpackChunkchisel_lang||[]).push([[5583],{1989:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var t=i(4848),l=i(8453);const s={layout:"docs",title:"Printing",section:"chisel3"},r="Printing in Chisel",a={id:"explanations/printing",title:"Printing",description:"Chisel provides the printf function for debugging purposes. It comes in two flavors:",source:"@site/docs/explanations/printing.md",sourceDirName:"explanations",slug:"/explanations/printing",permalink:"/docs/explanations/printing",draft:!1,unlisted:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/printing.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Printing",section:"chisel3"},sidebar:"chiselSidebar",previous:{title:"Ports",permalink:"/docs/explanations/ports"},next:{title:"Probes",permalink:"/docs/explanations/probes"}},c={},d=[{value:"Scala-style",id:"scala-style",level:2},{value:"Simple formatting",id:"simple-formatting",level:3},{value:"Special values",id:"special-values",level:3},{value:"Format modifiers",id:"format-modifiers",level:3},{value:"Aggregate data-types",id:"aggregate-data-types",level:3},{value:"Custom Printing",id:"custom-printing",level:3},{value:"C-Style",id:"c-style",level:2},{value:"Logging",id:"logging",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Writing Generic Code",id:"writing-generic-code",level:3},{value:"Flush",id:"flush",level:3}];function o(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"printing-in-chisel",children:"Printing in Chisel"})}),"\n",(0,t.jsxs)(n.p,{children:["Chisel provides the ",(0,t.jsx)(n.code,{children:"printf"})," function for debugging purposes. It comes in two flavors:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#scala-style",children:"Scala-style"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#c-style",children:"C-style"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:['Chisel also provides "logging" support for printing to files in addition to the default standard error, see ',(0,t.jsx)(n.a,{href:"#logging",children:"Logging"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"scala-style",children:"Scala-style"}),"\n",(0,t.jsxs)(n.p,{children:["Chisel also supports printf in a style similar to ",(0,t.jsx)(n.a,{href:"http://docs.scala-lang.org/overviews/core/string-interpolation.html",children:"Scala's String Interpolation"}),". Chisel provides a custom string interpolator ",(0,t.jsx)(n.code,{children:"cf"})," which follows C-style format specifiers (see section ",(0,t.jsx)(n.a,{href:"#c-style",children:"C-style"})," below)."]}),"\n",(0,t.jsx)(n.p,{children:"Note that the Scala s-interpolator is not supported in Chisel constructs and will throw an error:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'class MyModule extends Module {\n  val in = IO(Input(UInt(8.W)))\n  printf(s"in = $in\\n")\n}\n// error: The s-interpolator prints the Scala .toString of Data objects rather than the value of the hardware wire during simulation. Use the cf-interpolator instead. If you want an elaboration time print, use println.\n//   printf(s"in = $in\\n")\n//   ^^^^^^^^^^^^^^^^^^^^^\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Instead, use Chisel's ",(0,t.jsx)(n.code,{children:"cf"})," interpolator as in the following examples:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val myUInt = 33.U\nprintf(cf"myUInt = $myUInt") // myUInt = 33\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Note that when concatenating ",(0,t.jsx)(n.code,{children:'cf"..."'})," strings, you need to start with a ",(0,t.jsx)(n.code,{children:'cf"..."'})," string:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'// Does not interpolate the second string\nval myUInt = 33.U\nprintf("my normal string" + cf"myUInt = $myUInt")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"simple-formatting",children:"Simple formatting"}),"\n",(0,t.jsx)(n.p,{children:"Other formats are available as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val myUInt = 33.U\n// Hexadecimal\nprintf(cf"myUInt = 0x$myUInt%x") // myUInt = 0x21\n// Binary\nprintf(cf"myUInt = $myUInt%b") // myUInt = 100001\n// Character\nprintf(cf"myUInt = $myUInt%c") // myUInt = !\n'})}),"\n",(0,t.jsx)(n.h3,{id:"special-values",children:"Special values"}),"\n",(0,t.jsxs)(n.p,{children:["There are special values you can include in your ",(0,t.jsx)(n.code,{children:"cf"})," interpolated string:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"HierarchicalModuleName"})," (",(0,t.jsx)(n.code,{children:"%m"}),"): The hierarchical name of the current module"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SimulationTime"})," (",(0,t.jsx)(n.code,{children:"%T"}),"): The current simulation time (unlike Verilog's ",(0,t.jsx)(n.code,{children:"%t"}),", this does not take an argument)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Percent"})," (",(0,t.jsx)(n.code,{children:"%%"}),"): A literal ",(0,t.jsx)(n.code,{children:"%"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'printf(cf"hierarchical path = $HierarchicalModuleName\\n") // hierarchical path = <verilog.module.path>\nprintf(cf"hierarchical path = %m\\n") // equivalent to the above\n\nprintf(cf"simulation time = $SimulationTime\\n") // simulation time = <simulation.time>\nprintf(cf"simulation time = %T\\n") // equivalent to the above\n\nprintf(cf"100$Percent\\n") // 100%\nprintf(cf"100%%\\n") // equivalent to the above\n'})}),"\n",(0,t.jsx)(n.h3,{id:"format-modifiers",children:"Format modifiers"}),"\n",(0,t.jsxs)(n.p,{children:["Chisel supports standard Verilog-style modifiers for ",(0,t.jsx)(n.code,{children:"%d"}),", ",(0,t.jsx)(n.code,{children:"%x"}),", and ",(0,t.jsx)(n.code,{children:"%b"})," between the ",(0,t.jsx)(n.code,{children:"%"})," and the format specifier."]}),"\n",(0,t.jsxs)(n.p,{children:["Verilog simulators will pad values out to the width of the signal.\nWith decimal formatting, space is used for padding.\nFor all other formats, ",(0,t.jsx)(n.code,{children:"0"})," is used for padding."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A non-negative field width will override the default Verilog sizing of the value."}),"\n",(0,t.jsxs)(n.li,{children:["Specifying a field width of ",(0,t.jsx)(n.code,{children:"0"})," will always display the value with the minimum width (no zero nor space padding)."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val foo = WireInit(UInt(32.W), 33.U)\nprintf(cf"foo = $foo%d!\\n")  // foo =         33!\nprintf(cf"foo = $foo%0d!\\n") // foo = 33!\nprintf(cf"foo = $foo%4d!\\n") // foo =   33!\nprintf(cf"foo = $foo%x!\\n")  // foo = 00000021!\nprintf(cf"foo = $foo%0x!\\n") // foo = 21!\nprintf(cf"foo = $foo%4x!\\n") // foo = 0021!\nval bar = WireInit(UInt(8.W), 5.U)\nprintf(cf"bar = $bar%b!\\n")  // foo = 00000101!\nprintf(cf"bar = $bar%0b!\\n") // foo = 101!\nprintf(cf"bar = $bar%4b!\\n") // foo = 0101!\n'})}),"\n",(0,t.jsx)(n.h3,{id:"aggregate-data-types",children:"Aggregate data-types"}),"\n",(0,t.jsx)(n.p,{children:'Chisel provides default custom "pretty-printing" for Vecs and Bundles. The default printing of a Vec is similar to printing a Seq or List in Scala while printing a Bundle is similar to printing a Scala Map.'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val myVec = VecInit(5.U, 10.U, 13.U)\nprintf(cf"myVec = $myVec") // myVec = Vec(5, 10, 13)\n\nval myBundle = Wire(new Bundle {\n  val foo = UInt()\n  val bar = UInt()\n})\nmyBundle.foo := 3.U\nmyBundle.bar := 11.U\nprintf(cf"myBundle = $myBundle") // myBundle = Bundle(a -> 3, b -> 11)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"custom-printing",children:"Custom Printing"}),"\n",(0,t.jsxs)(n.p,{children:["Chisel also provides the ability to specify ",(0,t.jsx)(n.em,{children:"custom"})," printing for user-defined Bundles."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'class Message extends Bundle {\n  val valid = Bool()\n  val addr = UInt(32.W)\n  val length = UInt(4.W)\n  val data = UInt(64.W)\n  override def toPrintable: Printable = {\n    val char = Mux(valid, \'v\'.U, \'-\'.U)\n    cf"Message:\\n" +\n    cf"  valid  : $char%c\\n" +\n    cf"  addr   : $addr%x\\n" +\n    cf"  length : $length\\n" +\n    cf"  data   : $data%x\\n"\n  }\n}\n\nval myMessage = Wire(new Message)\nmyMessage.valid := true.B\nmyMessage.addr := "h1234".U\nmyMessage.length := 10.U\nmyMessage.data := "hdeadbeef".U\n\nprintf(cf"$myMessage")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Which prints the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Message:\n  valid  : v\n  addr   : 0x00001234\n  length : 10\n  data   : 0x00000000deadbeef\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Notice the use of ",(0,t.jsx)(n.code,{children:"+"})," between ",(0,t.jsx)(n.code,{children:"cf"}),' interpolated "strings". The results of ',(0,t.jsx)(n.code,{children:"cf"})," interpolation can be concatenated by using the ",(0,t.jsx)(n.code,{children:"+"})," operator."]}),"\n",(0,t.jsx)(n.h2,{id:"c-style",children:"C-Style"}),"\n",(0,t.jsxs)(n.p,{children:["Chisel provides ",(0,t.jsx)(n.code,{children:"printf"})," in a similar style to its C namesake. It accepts a double-quoted format string and a variable number of arguments which will then be printed on rising clock edges. Chisel supports the following format specifiers:"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Format Specifier"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Meaning"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"%d"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"decimal number"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"%x"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"hexadecimal number"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"%b"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"binary number"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"%c"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"8-bit ASCII character"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"%n"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"name of signal"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"%N"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"full name of signal"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"%%"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"literal percent"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"%m"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"hierarchical name"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"%T"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"simulation time"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"%d"}),", ",(0,t.jsx)(n.code,{children:"%x"}),", and ",(0,t.jsx)(n.code,{children:"%b"})," support the modifiers described in the ",(0,t.jsx)(n.a,{href:"#format-modifiers",children:"Format modifiers"})," section above."]}),"\n",(0,t.jsx)(n.p,{children:"It also supports a small set of escape characters:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Escape Character"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Meaning"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"\\n"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"newline"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"\\t"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"tab"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:'\\"'})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"literal double quote"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"\\'"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"literal single quote"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"center"},children:(0,t.jsx)(n.code,{children:"\\\\"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"literal backslash"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Note that single quotes do not require escaping, but are legal to escape."}),"\n",(0,t.jsx)(n.p,{children:"Thus printf can be used in a way very similar to how it is used in C:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val myUInt = 32.U\nprintf("myUInt = %d", myUInt) // myUInt = 32\n'})}),"\n",(0,t.jsx)(n.h2,{id:"logging",children:"Logging"}),"\n",(0,t.jsxs)(n.p,{children:["Chisel supports logging via the ",(0,t.jsx)(n.code,{children:"SimLog"})," API.\n",(0,t.jsx)(n.code,{children:"SimLog"})," provides a way to write simulation logs to files or standard error. It's particularly useful when you need to:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Write simulation output to specific files."}),"\n",(0,t.jsx)(n.li,{children:"Have multiple log files in a single simulation."}),"\n",(0,t.jsx)(n.li,{children:"Write reusable code that can target different log destinations."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsxs)(n.p,{children:["The most common use of ",(0,t.jsx)(n.code,{children:"SimLog"})," is to write to a file:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'class MyModule extends Module {\n  val log = SimLog.file("logfile.log")\n  val in = IO(Input(UInt(8.W)))\n  log.printf(cf"in = $in%d\\n")\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"You can also write to standard error using the default file descriptor:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'class MyModule extends Module {\n  val log = SimLog.StdErr\n  val in = IO(Input(UInt(8.W)))\n  log.printf(cf"in = $in%d\\n")\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["This is the same as standard ",(0,t.jsx)(n.code,{children:"printf"}),"."]})}),"\n",(0,t.jsxs)(n.p,{children:["SimLog filenames can themselves be ",(0,t.jsx)(n.code,{children:"Printable"})," values:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'class MyModule extends Module {\n  val idx = IO(Input(UInt(8.W)))\n  val log = SimLog.file(cf"logfile_$idx%0d.log")\n  val in = IO(Input(UInt(8.W)))\n  log.printf(cf"in = $in%d\\n")\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["It is strongly recommended to use ",(0,t.jsx)(n.code,{children:"%0d"})," with UInts in filenames to avoid spaces in the filename."]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsx)(n.p,{children:"Be careful to avoid uninitialized registers in the filename."})}),"\n",(0,t.jsx)(n.h3,{id:"writing-generic-code",children:"Writing Generic Code"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"SimLog"})," allows you to write code that can work with any log destination. This is useful when creating reusable components:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'class MyLogger(log: SimLog) extends Module {\n  val in = IO(Input(UInt(8.W)))\n  log.printf(cf"in = $in%d\\n")\n}\n\n// Use with a file\nval withFile = Module(new MyLogger(SimLog.file("data.log")))\n\n// Use with stderr\nval withStderr = Module(new MyLogger(SimLog.StdErr))\n'})}),"\n",(0,t.jsx)(n.h3,{id:"flush",children:"Flush"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"SimLog"})," objects can be flushed to ensure that all buffered output is written.\nThis is useful in simulations using the logged output as input to a co-simulated components like a checker or golden model."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val log = SimLog.file("logfile.log")\nval in = IO(Input(UInt(8.W)))\nlog.printf(cf"in = $in%d\\n")\nlog.flush() // Flush buffered output right away.\n'})}),"\n",(0,t.jsx)(n.p,{children:"You can also flush standard error:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"SimLog.StdErr.flush() // This will flush all standard printfs.\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const l={},s=t.createContext(l);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);