"use strict";(self.webpackChunkchisel_lang=self.webpackChunkchisel_lang||[]).push([[9387],{5370:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>r});var i=t(4848),o=t(8453);const a={layout:"docs",title:"Functional Module Creation",section:"chisel3"},l="Functional Module Creation",s={id:"explanations/functional-module-creation",title:"Functional Module Creation",description:"Objects in Scala have a pre-existing creation function (method) called apply.",source:"@site/docs/explanations/functional-module-creation.md",sourceDirName:"explanations",slug:"/explanations/functional-module-creation",permalink:"/docs/explanations/functional-module-creation",draft:!1,unlisted:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/functional-module-creation.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Functional Module Creation",section:"chisel3"},sidebar:"chiselSidebar",previous:{title:"Functional Abstraction",permalink:"/docs/explanations/functional-abstraction"},next:{title:"Instance Choices",permalink:"/docs/explanations/instchoice"}},u={},r=[];function c(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"functional-module-creation",children:"Functional Module Creation"})}),"\n",(0,i.jsxs)(n.p,{children:["Objects in Scala have a pre-existing creation function (method) called ",(0,i.jsx)(n.code,{children:"apply"}),".\nWhen an object is used as value in an expression (which basically means that the constructor was called), this method determines the returned value.\nWhen dealing with hardware modules, one would expect the module output to be representative of the hardware module's functionality.\nTherefore, we would sometimes like the module output to be the value returned when using the object as a value in an expression.\nSince hardware modules are represented as Scala objects, this can be done by defining the object's ",(0,i.jsx)(n.code,{children:"apply"})," method to return the module's output.\nThis can be referred to as creating a functional interface for module construction.\nIf we apply this on the standard mux2 example, we would to return the mux2 output ports when we used mux2 in an expression.\nImplementing this requires building a constructor that takes multiplexer inputs as parameters and returns the multiplexer output:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import chisel3._\n\nclass Mux2 extends Module {\n  val io = IO(new Bundle {\n    val sel = Input(Bool())\n    val in0 = Input(UInt())\n    val in1 = Input(UInt())\n    val out = Output(UInt())\n  })\n  io.out := Mux(io.sel, io.in0, io.in1)\n}\n\nobject Mux2 {\n  def apply(sel: UInt, in0: UInt, in1: UInt) = {\n    val m = Module(new Mux2)\n    m.io.in0 := in0\n    m.io.in1 := in1\n    m.io.sel := sel\n    m.io.out\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As we can see in the code example, we defined the ",(0,i.jsx)(n.code,{children:"apply"})," method to take the Mux2 inputs as the method parameters, and return the Mux2 output as the function's return value.\nBy defining modules in this way, it is easier to later implement larger and more complex version of this regular module.\nFor example, we previously implemented Mux4 like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"class Mux4 extends Module {\n  val io = IO(new Bundle {\n    val in0 = Input(UInt(1.W))\n    val in1 = Input(UInt(1.W))\n    val in2 = Input(UInt(1.W))\n    val in3 = Input(UInt(1.W))\n    val sel = Input(UInt(2.W))\n    val out = Output(UInt(1.W))\n  })\n  val m0 = Module(new Mux2)\n  m0.io.sel := io.sel(0)\n  m0.io.in0 := io.in0\n  m0.io.in1 := io.in1\n\n  val m1 = Module(new Mux2)\n  m1.io.sel := io.sel(0)\n  m1.io.in0 := io.in2\n  m1.io.in1 := io.in3\n\n  val m3 = Module(new Mux2)\n  m3.io.sel := io.sel(1)\n  m3.io.in0 := m0.io.out\n  m3.io.in1 := m1.io.out\n\n  io.out := m3.io.out\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"However, by using the creation function we redefined for Mux2, we can now use the Mux2 outputs as values of the modules themselves\nwhen writing the Mux4 output expression:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"class Mux4 extends Module {\n  val io = IO(new Bundle {\n    val in0 = Input(UInt(1.W))\n    val in1 = Input(UInt(1.W))\n    val in2 = Input(UInt(1.W))\n    val in3 = Input(UInt(1.W))\n    val sel = Input(UInt(2.W))\n    val out = Output(UInt(1.W))\n  })\n  io.out := Mux2(io.sel(1),\n                 Mux2(io.sel(0), io.in0, io.in1),\n                 Mux2(io.sel(0), io.in2, io.in3))\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This allows us to write more intuitively readable hardware connection descriptions, which are similar to software expression evaluation."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var i=t(6540);const o={},a=i.createContext(o);function l(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);