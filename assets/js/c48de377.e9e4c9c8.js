"use strict";(globalThis.webpackChunkchisel_lang=globalThis.webpackChunkchisel_lang||[]).push([[3316],{4851(e,n,i){i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"appendix/experimental-features","title":"Experimental Features","description":"Chisel has a number of new features that are worth checking out.  This page is an informal list of these features and projects.","source":"@site/docs/appendix/experimental-features.md","sourceDirName":"appendix","slug":"/appendix/experimental-features","permalink":"/docs/appendix/experimental-features","draft":false,"unlisted":false,"editUrl":"https://github.com/chipsalliance/chisel/tree/main/docs/src/appendix/experimental-features.md","tags":[],"version":"current","frontMatter":{"layout":"docs","title":"Experimental Features","section":"chisel3"},"sidebar":"chiselSidebar","previous":{"title":"Migrating from ChiselTest","permalink":"/docs/appendix/migrating-from-chiseltest"},"next":{"title":"Upgrading From Chisel 3.4 to 3.5","permalink":"/docs/appendix/upgrading-from-chisel-3-4"}}');var t=i(4848),a=i(8453);const o={layout:"docs",title:"Experimental Features",section:"chisel3"},s="Experimental Features",r={},d=[{value:"Module Variants",id:"module-variants",level:2},{value:"Bundle Literals",id:"bundle-literals",level:2},{value:"Vec Literals",id:"vec-literals",level:2},{value:"Loading Memories for simulation or FPGA initialization",id:"loading-memories-for-simulation-or-fpga-initialization",level:2},{value:"Inline initialization with external file",id:"inline-initialization-with-external-file",level:3},{value:"SystemVerilog Bind Initialization",id:"systemverilog-bind-initialization",level:3},{value:"Notes on files",id:"notes-on-files",level:3},{value:"Aggregate memories",id:"aggregate-memories",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"experimental-features",children:"Experimental Features"})}),"\n",(0,t.jsx)(n.p,{children:"Chisel has a number of new features that are worth checking out.  This page is an informal list of these features and projects."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#module-variants",children:"Module Variants"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#bundle-literals",children:"Bundle Literals"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#vec-literals",children:"Vec Literals"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#loading-memories-for-simulation-or-fpga-initialization",children:"Loading-Memories-for-simulation-or-FPGA-initialization"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"module-variants",children:"Module Variants"}),"\n",(0,t.jsxs)(n.p,{children:["The standard Chisel ",(0,t.jsx)(n.em,{children:"Module"})," requires a ",(0,t.jsx)(n.code,{children:"val io = IO(...)"}),", the experimental package introduces several\nnew ways of defining Modules"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"BaseModule: no contents, instantiable"}),"\n",(0,t.jsx)(n.li,{children:"UserDefinedModule extends BaseModule: this module can contain Chisel RTL. No default clock or reset lines. No default IO. - User should be able to specify non-io ports, ideally multiple of them."}),"\n",(0,t.jsx)(n.li,{children:"ImplicitModule extends UserModule: has clock, reset, and io, essentially current Chisel Module."}),"\n",(0,t.jsx)(n.li,{children:"RawModule: will be the user-facing version of UserDefinedModule"}),"\n",(0,t.jsx)(n.li,{children:"Module: type-aliases to ImplicitModule, the user-facing version of ImplicitModule."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"bundle-literals",children:"Bundle Literals"}),"\n",(0,t.jsx)(n.p,{children:"Bundle literals can be constructed via an experimental import:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nimport chisel3.experimental.BundleLiterals._\n\nclass MyBundle extends Bundle {\n  val a = UInt(8.W)\n  val b = Bool()\n}\n\nclass Example extends RawModule {\n  val out = IO(Output(new MyBundle))\n  out := (new MyBundle).Lit(_.a -> 8.U, _.b -> true.B)\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example(\n  output [7:0] out_a,\n  output       out_b\n);\n\n  assign out_a = 8'h8;\n  assign out_b = 1'h1;\nendmodule\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:['Partial specification is allowed, which results in "invalidated fields" as\ndescribed in ',(0,t.jsx)(n.a,{href:"../explanations/unconnected-wires",children:"Unconnected Wires"}),".\nNote that this can be used with ",(0,t.jsx)(n.code,{children:"RegInit"})," to construct partially reset registers as\ndescribed in the ",(0,t.jsx)(n.a,{href:"../cookbooks/cookbook#how-do-i-partially-reset-an-aggregate-reg",children:"Cookbook"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class Example2 extends RawModule {\n  val out = IO(Output(new MyBundle))\n  out := (new MyBundle).Lit(_.b -> true.B)\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example2(\n  output [7:0] out_a,\n  output       out_b\n);\n\n  assign out_a = 8'h0;\n  assign out_b = 1'h1;\nendmodule\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"Bundle literals can also be nested arbitrarily."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class ChildBundle extends Bundle {\n  val foo = UInt(8.W)\n}\n\nclass ParentBundle extends Bundle {\n  val a = UInt(8.W)\n  val b = new ChildBundle\n}\n\nclass Example3 extends RawModule {\n  val out = IO(Output(new ParentBundle))\n  out := (new ParentBundle).Lit(_.a -> 123.U, _.b -> (new ChildBundle).Lit(_.foo -> 42.U))\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example3(\n  output [7:0] out_a,\n               out_b_foo\n);\n\n  assign out_a = 8'h7B;\n  assign out_b_foo = 8'h2A;\nendmodule\n\n"})}),"\n",(0,t.jsx)(n.h2,{id:"vec-literals",children:"Vec Literals"}),"\n",(0,t.jsx)(n.p,{children:"Vec literals are very similar to Bundle literals and can be constructed via an experimental import.\nThey can be constructed in two forms, with type and length inferred as in:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nimport chisel3.experimental.VecLiterals._\n\nclass VecExample1 extends Module {\n  val out = IO(Output(Vec(2, UInt(4.W))))\n  out := Vec.Lit(0xa.U, 0xbb.U)\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule VecExample1(\n  input        clock,\n               reset,\n  output [3:0] out_0,\n               out_1\n);\n\n  assign out_0 = 4'hA;\n  assign out_1 = 4'hB;\nendmodule\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"or explicitly as in:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nimport chisel3.experimental.VecLiterals._\n\nclass VecExample1a extends Module {\n  val out = IO(Output(Vec(2, UInt(4.W))))\n  out := Vec(2, UInt(4.W)).Lit(0 -> 1.U, 1 -> 2.U)\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule VecExample1a(\n  input        clock,\n               reset,\n  output [3:0] out_0,\n               out_1\n);\n\n  assign out_0 = 4'h1;\n  assign out_1 = 4'h2;\nendmodule\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:['The following examples all use the explicit form.\nWith the explicit form partial specification is allowed, which results in\n"invalidated fields" as described in ',(0,t.jsx)(n.a,{href:"../explanations/unconnected-wires",children:"Unconnected Wires"}),".\nNote that this can be used with ",(0,t.jsx)(n.code,{children:"RegInit"})," to construct partially reset registers as\ndescribed in the ",(0,t.jsx)(n.a,{href:"../cookbooks/cookbook#how-do-i-partially-reset-an-aggregate-reg",children:"Cookbook"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class VecExample2 extends RawModule {\n  val out = IO(Output(Vec(4, UInt(4.W))))\n  out := Vec(4, UInt(4.W)).Lit(0 -> 1.U, 3 -> 7.U)\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule VecExample2(\n  output [3:0] out_0,\n               out_1,\n               out_2,\n               out_3\n);\n\n  assign out_0 = 4'h1;\n  assign out_1 = 4'h0;\n  assign out_2 = 4'h0;\n  assign out_3 = 4'h7;\nendmodule\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"Registers can be initialized from Vec literals"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class VecExample3 extends Module {\n  val out = IO(Output(Vec(4, UInt(8.W))))\n  val y = RegInit(\n    Vec(4, UInt(8.W)).Lit(0 -> 0xAB.U(8.W), 1 -> 0xCD.U(8.W), 2 -> 0xEF.U(8.W), 3 -> 0xFF.U(8.W))\n  )\n  out := y\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule VecExample3(\n  input        clock,\n               reset,\n  output [7:0] out_0,\n               out_1,\n               out_2,\n               out_3\n);\n\n  assign out_0 = 8'hAB;\n  assign out_1 = 8'hCD;\n  assign out_2 = 8'hEF;\n  assign out_3 = 8'hFF;\nendmodule\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"Vec literals can also be nested arbitrarily."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class VecExample5 extends RawModule {\n  val out = IO(Output(Vec(2, new ChildBundle)))\n  out := Vec(2, new ChildBundle).Lit(\n    0 -> (new ChildBundle).Lit(_.foo -> 42.U),\n    1 -> (new ChildBundle).Lit(_.foo -> 7.U)\n  )\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule VecExample5(\n  output [7:0] out_0_foo,\n               out_1_foo\n);\n\n  assign out_0_foo = 8'h2A;\n  assign out_1_foo = 8'h7;\nendmodule\n\n"})}),"\n",(0,t.jsx)(n.h2,{id:"loading-memories-for-simulation-or-fpga-initialization",children:"Loading Memories for simulation or FPGA initialization"}),"\n",(0,t.jsx)(n.h3,{id:"inline-initialization-with-external-file",children:"Inline initialization with external file"}),"\n",(0,t.jsxs)(n.p,{children:["Memories can be initialized by generating inline ",(0,t.jsx)(n.code,{children:"readmemh"})," or ",(0,t.jsx)(n.code,{children:"readmemb"})," statements in the output Verilog."]}),"\n",(0,t.jsxs)(n.p,{children:["The function ",(0,t.jsx)(n.code,{children:"loadMemoryFromFileInline"})," from ",(0,t.jsx)(n.code,{children:"chisel3.util.experimental"})," allows the memory to be initialized by the synthesis software from the specified file. Chisel does not validate the file contents nor its location. Both the memory initialization file and the Verilog source should be accessible for the toolchain."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.util.experimental.loadMemoryFromFileInline\n\nclass InitMemInline(memoryFile: String = "") extends Module {\n  val width: Int = 32\n  val io = IO(new Bundle {\n    val enable = Input(Bool())\n    val write = Input(Bool())\n    val addr = Input(UInt(10.W))\n    val dataIn = Input(UInt(width.W))\n    val dataOut = Output(UInt(width.W))\n  })\n\n  val mem = SyncReadMem(1024, UInt(width.W))\n  // Initialize memory\n  if (memoryFile.trim().nonEmpty) {\n    loadMemoryFromFileInline(mem, memoryFile)\n  }\n  io.dataOut := DontCare\n  when(io.enable) {\n    val rdwrPort = mem(io.addr)\n    when (io.write) { rdwrPort := io.dataIn }\n      .otherwise    { io.dataOut := rdwrPort }\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The default is to use ",(0,t.jsx)(n.code,{children:"$readmemh"})," (which assumes all numbers in the file are in ascii hex),\nbut to use ascii binary there is an optional ",(0,t.jsx)(n.code,{children:"hexOrBinary"})," argument which can be set to ",(0,t.jsx)(n.code,{children:"MemoryLoadFileType.Hex"})," or ",(0,t.jsx)(n.code,{children:"MemoryLoadFileType.Binary"}),". You will need to add an additional import."]}),"\n",(0,t.jsx)(n.h3,{id:"systemverilog-bind-initialization",children:"SystemVerilog Bind Initialization"}),"\n",(0,t.jsxs)(n.p,{children:["Chisel can also initialize memories by generating a SV bind module with ",(0,t.jsx)(n.code,{children:"readmemh"})," or ",(0,t.jsx)(n.code,{children:"readmemb"})," statements by using the function ",(0,t.jsx)(n.code,{children:"loadMemoryFromFile"})," from ",(0,t.jsx)(n.code,{children:"chisel3.util.experimental"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nimport chisel3.util.experimental.loadMemoryFromFile\n\nclass InitMemBind(val bits: Int, val size: Int, filename: String) extends Module {\n  val io = IO(new Bundle {\n    val nia = Input(UInt(bits.W))\n    val insn = Output(UInt(32.W))\n  })\n\n  val memory = Mem(size, UInt(32.W))\n  io.insn := memory(io.nia >> 2);\n  loadMemoryFromFile(memory, filename)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Which generates the bind module:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:'module BindsTo_0_Foo(\n  input         clock,\n  input         reset,\n  input  [31:0] io_nia,\n  output [31:0] io_insn\n);\n\ninitial begin\n  $readmemh("test.hex", Foo.memory);\nend\nendmodule\n\nbind Foo BindsTo_0_Foo BindsTo_0_Foo_Inst(.*);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"notes-on-files",children:"Notes on files"}),"\n",(0,t.jsxs)(n.p,{children:["There is no simple answer to where to put the ",(0,t.jsx)(n.code,{children:"hex"})," or ",(0,t.jsx)(n.code,{children:"bin"})," file with the initial contents. It's probably best to create a resource directory somewhere and reference that through a full path or place the file beside the generated Verilog. Another option is adding the path to the memory file in the synthesis tool path. Because these files may be large, Chisel does not copy them."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Don't forget there is no decimal option, so a 10 in an input file will be 16 decimal"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["See: ",(0,t.jsx)(n.a,{href:"https://github.com/freechipsproject/chisel-testers/blob/master/src/test/scala/examples/ComplexMemoryLoadingSpec.scala",children:"ComplexMemoryLoadingSpec.scala"})," and\n",(0,t.jsx)(n.a,{href:"https://github.com/freechipsproject/chisel-testers/blob/master/src/test/scala/examples/LoadMemoryFromFileSpec.scala",children:"LoadMemoryFromFileSpec.scala"}),"\nfor working examples."]}),"\n",(0,t.jsx)(n.h3,{id:"aggregate-memories",children:"Aggregate memories"}),"\n",(0,t.jsxs)(n.p,{children:["Aggregate memories are supported and will be lowered to a single wide ",(0,t.jsx)(n.code,{children:"UInt"}),".  The memory loading file should be constructed to align with the final structure of the memory."]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453(e,n,i){i.d(n,{R:()=>o,x:()=>s});var l=i(6540);const t={},a=l.createContext(t);function o(e){const n=l.useContext(a);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),l.createElement(a.Provider,{value:n},e.children)}}}]);