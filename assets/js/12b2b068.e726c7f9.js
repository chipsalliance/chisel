"use strict";(self.webpackChunkchisel_lang=self.webpackChunkchisel_lang||[]).push([[9942],{2661:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>c});var n=t(4848),s=t(8453);const l={title:"Migrating from ChiselTest",sidebar_position:0},o="Migrating from ChiselTest to ChiselSim",r={id:"appendix/migrating-from-chiseltest",title:"Migrating from ChiselTest",description:"Background",source:"@site/docs/appendix/migrating-from-chiseltest.md",sourceDirName:"appendix",slug:"/appendix/migrating-from-chiseltest",permalink:"/docs/appendix/migrating-from-chiseltest",draft:!1,unlisted:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/appendix/migrating-from-chiseltest.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{title:"Migrating from ChiselTest",sidebar_position:0},sidebar:"chiselSidebar",previous:{title:"Appendix",permalink:"/docs/appendix"},next:{title:"Experimental Features",permalink:"/docs/appendix/experimental-features"}},a={},c=[{value:"Background",id:"background",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Migration",id:"migration",level:2}];function h(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"migrating-from-chiseltest-to-chiselsim",children:"Migrating from ChiselTest to ChiselSim"})}),"\n",(0,n.jsx)(i.h2,{id:"background",children:"Background"}),"\n",(0,n.jsxs)(i.p,{children:["With the release of Chisel 5, Chisel moved off of the legacy ",(0,n.jsx)(i.a,{href:"https://github.com/chipsalliance/firrtl",children:"Scala FIRRTL Compiler (SFC)"})," to the MLIR FIRRTL Compiler (MFC), part of the ",(0,n.jsx)(i.a,{href:"https://github.com/llvm/circt",children:"llvm/circt"})," project.\nAfter this release, the Scala FIRRTL Compiler was no longer maintained.\nThis change in underlying compiler technology has been a crucial piece in enabling the addition of many new features to Chisel, including linear-temporal logic (LTL) properties, Probes, and Layers.\nUnfortunately, Chisel 3's testing library, ",(0,n.jsx)(i.a,{href:"https://github.com/ucb-bar/chiseltest",children:"ChiselTest"}),", is built around the SFC, making it difficult to support ChiselTest in Chisel 5 and beyond.\n",(0,n.jsx)(i.em,{children:"ChiselTest is not used or maintained by the core Chisel development team or their employers."})]}),"\n",(0,n.jsx)(i.p,{children:"ChiselSim is the approved replacement for ChiselTest in Chisel 5 and beyond.\nChiselSim is maintained and used by the core Chisel development team.\nThis page describes how to migrate from ChiselTest to ChiselSim."}),"\n",(0,n.jsx)(i.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,n.jsx)(i.p,{children:"The developers of ChiselTest have maintained some amount of compatibility between ChiselTest and newer versions of Chisel.\nThis relies on a forked version of the SFC.\nUse of ChiselTest with Chisel 6 or later will prevent the usage of new Chisel 6 features.\nIt is not expected that new versions of Chisel will be compatible with the SFC."}),"\n",(0,n.jsx)(i.p,{children:"We recommend using the latest minor version of Chisel 5 and ChiselTest 5 for migrating. At the time of writing this is Chisel v5.1.0 and ChiselTest v5.0.2, but please check for later versions."}),"\n",(0,n.jsx)(i.h2,{id:"migration",children:"Migration"}),"\n",(0,n.jsxs)(i.p,{children:["ChiselSim provides a minimal ",(0,n.jsx)(i.code,{children:"peek"}),", ",(0,n.jsx)(i.code,{children:"poke"}),", ",(0,n.jsx)(i.code,{children:"expect"}),", and ",(0,n.jsx)(i.code,{children:"step"})," API, similar to that of ChiselTest.\nYou use ChiselSim by importing it ",(0,n.jsx)(i.code,{children:"import chisel3.simulator.EphemeralSimulator._"}),", and using its ",(0,n.jsx)(i.code,{children:"simulate"})," method which is similar to ChiselTest's ",(0,n.jsx)(i.code,{children:"test"}),".\nAt present, it does not have any integration with ScalaTest, so users should use any ScalaTest APIs directly."]}),"\n",(0,n.jsxs)(i.p,{children:["For example, given a simple design (typically in ",(0,n.jsx)(i.code,{children:"src/main/scala"}),"):"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-scala",children:"import chisel3._\nclass MyModule extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n\n  io.out := RegNext(io.in)\n}\n"})}),"\n",(0,n.jsxs)(i.p,{children:["The legacy ChiselTest way to test this would be with a ",(0,n.jsx)(i.code,{children:"ChiselScalatestTester"})," in ",(0,n.jsx)(i.code,{children:"src/test/scala"}),":"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-scala",children:'import chisel3._\nimport chiseltest._\nimport org.scalatest.flatspec.AnyFlatSpec\n\nclass MyModuleSpec extends AnyFlatSpec with ChiselScalatestTester {\n  behavior of "MyModule"\n  it should "do something" in {\n    test(new MyModule) { c =>\n      c.io.in.poke(0.U)\n      c.clock.step()\n      c.io.out.expect(0.U)\n      c.io.in.poke(42.U)\n      c.clock.step()\n      c.io.out.expect(42.U)\n      println("Last output value : " + c.io.out.peek().litValue)\n    }\n  }\n}\n'})}),"\n",(0,n.jsx)(i.p,{children:"This can be rewritten using ChiselSim as follows:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.simulator.EphemeralSimulator._\nimport org.scalatest.flatspec.AnyFlatSpec\n\nclass MyModuleSpec extends AnyFlatSpec {\n  behavior of "MyModule"\n  it should "do something" in {\n    simulate(new MyModule) { c =>\n      c.io.in.poke(0.U)\n      c.clock.step()\n      c.io.out.expect(0.U)\n      c.io.in.poke(42.U)\n      c.clock.step()\n      c.io.out.expect(42.U)\n      println("Last output value : " + c.io.out.peek().litValue)\n    }\n  }\n}\n'})}),"\n",(0,n.jsxs)(i.p,{children:["For both ChiselTest and ChiselSim, you will typically run this with ",(0,n.jsx)(i.code,{children:"sbt test"})," or some way of running tests.\nThe output from ChiselSim will look something like the following:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-scala",children:'// This is how one can run a ScalaTest Spec manually, typically one would use "sbt test"\norg.scalatest.nocolor.run(new MyModuleSpec)\n'})}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"Last output value : 42\nMdocSession$MdocApp$MyModuleSpec:\nMyModule\n- should do something\n\n"})}),"\n",(0,n.jsxs)(i.p,{children:["ChiselSim also does not currently have any support for ",(0,n.jsx)(i.code,{children:"fork"}),"-",(0,n.jsx)(i.code,{children:"join"}),", so any tests using those constructs will need to be rewritten in a single-threaded manner."]})]})}function d(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>o,x:()=>r});var n=t(6540);const s={},l=n.createContext(s);function o(e){const i=n.useContext(l);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(l.Provider,{value:i},e.children)}}}]);