"use strict";(globalThis.webpackChunkchisel_lang=globalThis.webpackChunkchisel_lang||[]).push([[4315],{4745(e,n,t){t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"explanations/blackboxes","title":"External Modules (\\"Black Boxes\\")\\n","description":"Chisel External Modules are used to instantiate externally defined modules. This construct is useful","source":"@site/docs/explanations/blackboxes.md","sourceDirName":"explanations","slug":"/explanations/blackboxes","permalink":"/docs/explanations/blackboxes","draft":false,"unlisted":false,"editUrl":"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/blackboxes.md","tags":[],"version":"current","frontMatter":{"layout":"docs","title":"External Modules (\\"Black Boxes\\")\\n","section":"chisel3"},"sidebar":"chiselSidebar","previous":{"title":"Annotations","permalink":"/docs/explanations/annotations"},"next":{"title":"Bundles and Vecs","permalink":"/docs/explanations/bundles-and-vecs"}}');var l=t(4848),s=t(8453);const o={layout:"docs",title:'External Modules ("Black Boxes")\n',section:"chisel3"},a='External Modules ("Black Boxes")',r={},d=[{value:"Parameterization",id:"parameterization",level:3},{value:"Providing Implementations for External Modules",id:"providing-implementations-for-external-modules",level:3},{value:"External Modules with Verilog in a Resource File",id:"external-modules-with-verilog-in-a-resource-file",level:3},{value:"External Modules with In-line Verilog",id:"external-modules-with-in-line-verilog",level:3},{value:"Under the Hood",id:"under-the-hood",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"external-modules-black-boxes",children:'External Modules ("Black Boxes")'})}),"\n",(0,l.jsxs)(n.p,{children:["Chisel ",(0,l.jsx)(n.em,{children:"External Modules"})," are used to instantiate externally defined modules. This construct is useful\nfor hardware constructs that cannot be described in Chisel and for connecting to FPGA or other IP not defined in Chisel."]}),"\n",(0,l.jsxs)(n.p,{children:["Modules defined as an ",(0,l.jsx)(n.code,{children:"ExtModule"})," will be instantiated in the generated Verilog, but no code\nwill be generated to define the behavior of module."]}),"\n",(0,l.jsxs)(n.p,{children:["Unlike Module, ",(0,l.jsx)(n.code,{children:"ExtModule"})," has no implicit clock and reset.\nInstead, they behave like ",(0,l.jsx)(n.code,{children:"RawModule"})," in this regard.\n",(0,l.jsx)(n.code,{children:"ExtModule"}),"'s clock and reset ports must be explicitly declared and connected to input signals."]}),"\n",(0,l.jsx)(n.h3,{id:"parameterization",children:"Parameterization"}),"\n",(0,l.jsxs)(n.p,{children:["Verilog parameters can be passed as an argument to the ",(0,l.jsx)(n.code,{children:"ExtModule"})," constructor."]}),"\n",(0,l.jsx)(n.p,{children:"For example, consider instantiating a Xilinx differential clock buffer (IBUFDS) in a Chisel design:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.util._\nimport chisel3.experimental.fromStringToStringParam\n\nclass IBUFDS extends ExtModule(Map("DIFF_TERM" -> "TRUE",\n                                  "IOSTANDARD" -> "DEFAULT")) {\n  val O = IO(Output(Clock()))\n  val I = IO(Input(Clock()))\n  val IB = IO(Input(Clock()))\n}\n\nclass Top extends Module {\n  val ibufds = Module(new IBUFDS)\n  // connecting one of IBUFDS\'s input clock ports to Top\'s clock signal\n  ibufds.I := clock\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["In the Chisel-generated Verilog code, ",(0,l.jsx)(n.code,{children:"IBUFDS"})," will be instantiated as:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:'IBUFDS #(.DIFF_TERM("TRUE"), .IOSTANDARD("DEFAULT")) ibufds (\n  .IB(ibufds_IB),\n  .I(ibufds_I),\n  .O(ibufds_O)\n);\n'})}),"\n",(0,l.jsx)(n.h3,{id:"providing-implementations-for-external-modules",children:"Providing Implementations for External Modules"}),"\n",(0,l.jsx)(n.p,{children:"Chisel provides the following ways of delivering the code underlying the external module. Consider the following external module that\nadds two real numbers together. The numbers are represented in chisel3 as 64-bit unsigned integers."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nclass ExtModuleRealAdd extends ExtModule {\n  val in1 = IO(Input(UInt(64.W)))\n  val in2 = IO(Input(UInt(64.W)))\n  val out = IO(Output(UInt(64.W)))\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"The implementation is described by the following verilog"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"module ExtModuleRealAdd(\n    input  [63:0] in1,\n    input  [63:0] in2,\n    output reg [63:0] out\n);\n  always @* begin\n    out <= $realtobits($bitstoreal(in1) + $bitstoreal(in2));\n  end\nendmodule\n"})}),"\n",(0,l.jsx)(n.h3,{id:"external-modules-with-verilog-in-a-resource-file",children:"External Modules with Verilog in a Resource File"}),"\n",(0,l.jsxs)(n.p,{children:["In order to deliver the Verilog snippet above to the backend simulator, chisel3 provides the following tools basedf on the Chisel/FIRRTL ",(0,l.jsx)(n.a,{href:"../explanations/annotations",children:"annotation system"})," via methods that are already available on ",(0,l.jsx)(n.code,{children:"ExtModule"}),".  To include a Java resource, use ",(0,l.jsx)(n.code,{children:"addResource"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass ExtModuleRealAdd extends ExtModule {\n  val in1 = IO(Input(UInt(64.W)))\n  val in2 = IO(Input(UInt(64.W)))\n  val out = IO(Output(UInt(64.W)))\n  addResource("/real_math.v")\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["The verilog snippet above gets put into a resource file names ",(0,l.jsx)(n.code,{children:"real_math.v"}),".  What is a resource file? It comes from\na java convention of keeping files in a project that are automatically included in library distributions. In a typical\nChisel project, see ",(0,l.jsx)(n.a,{href:"https://github.com/chipsalliance/chisel-template",children:"chisel-template"}),", this would be a directory in the\nsource hierarchy: ",(0,l.jsx)(n.code,{children:"src/main/resources/real_math.v"}),"."]}),"\n",(0,l.jsx)(n.h3,{id:"external-modules-with-in-line-verilog",children:"External Modules with In-line Verilog"}),"\n",(0,l.jsxs)(n.p,{children:["It is also possible to place this Verilog directly in the scala source.  Instead\nof ",(0,l.jsx)(n.code,{children:"addResource"})," use ",(0,l.jsx)(n.code,{children:"setInline"}),".  The code will look like this:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:'import chisel3._\nclass ExtModuleRealAdd extends ExtModule {\n  val in1 = IO(Input(UInt(64.W)))\n  val in2 = IO(Input(UInt(64.W)))\n  val out = IO(Output(UInt(64.W)))\n  setInline("ExtModuleRealAdd.v",\n    """module ExtModuleRealAdd(\n      |    input  [63:0] in1,\n      |    input  [63:0] in2,\n      |    output reg [63:0] out\n      |);\n      |always @* begin\n      |  out <= $realtobits($bitstoreal(in1) + $bitstoreal(in2));\n      |end\n      |endmodule\n    """.stripMargin)\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["This technique will copy the inline verilog into the target directory under the name ",(0,l.jsx)(n.code,{children:"ExtModuleRealAdd.v"})]}),"\n",(0,l.jsx)(n.h3,{id:"under-the-hood",children:"Under the Hood"}),"\n",(0,l.jsxs)(n.p,{children:["This mechanism of delivering verilog content to the testing backends is implemented via Chisel/FIRRTL annotations. The\ntwo methods, inline and resource, are two kinds of annotations that are created via the ",(0,l.jsx)(n.code,{children:"setInline"})," and\n",(0,l.jsx)(n.code,{children:"addResource"})," methods calls.  Those annotations are passed through to the chisel-testers which in turn passes them\non to firrtl.  The default firrtl verilog compilers have a pass that detects the annotations and moves the files or\ninline test into the build directory.  For each unique file added, the transform adds a line to a file\n",(0,l.jsx)(n.code,{children:"black_box_verilog_files.f"}),", this file is added to the command line constructed for verilator or vcs to inform them where\nto look.\nThe ",(0,l.jsx)(n.a,{href:"https://github.com/ucb-bar/dsptools",children:"dsptools project"})," is a good example of using this feature to build a real\nnumber simulation tester based on black boxes."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const l={},s=i.createContext(l);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);