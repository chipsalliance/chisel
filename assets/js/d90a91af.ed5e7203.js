"use strict";(self.webpackChunkchisel_lang=self.webpackChunkchisel_lang||[]).push([[9240],{14:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>a,toc:()=>c});var s=n(4848),t=n(8453);const l={layout:"docs",title:"Testing",section:"chisel3"},o="Testing",a={id:"explanations/testing",title:"Testing",description:"Chisel provides several packages for testing generators with different",source:"@site/docs/explanations/testing.md",sourceDirName:"explanations",slug:"/explanations/testing",permalink:"/docs/explanations/testing",draft:!1,unlisted:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/testing.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Testing",section:"chisel3"},sidebar:"chiselSidebar",previous:{title:"Supported Hardware",permalink:"/docs/explanations/supported-hardware"},next:{title:"Unconnected Wires",permalink:"/docs/explanations/unconnected-wires"}},r={},c=[{value:"ChiselSim",id:"chiselsim",level:2},{value:"Simulation APIs",id:"simulation-apis",level:3},{value:"Peek/Poke APIs",id:"peekpoke-apis",level:3},{value:"Example",id:"example",level:3},{value:"FileCheck",id:"filecheck",level:2},{value:"Example",id:"example-1",level:3}];function h(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"testing",children:"Testing"})}),"\n",(0,s.jsx)(i.p,{children:"Chisel provides several packages for testing generators with different\nstrategies."}),"\n",(0,s.jsxs)(i.p,{children:["The primary testing strategy is simulation.  This is done using ",(0,s.jsx)(i.em,{children:"ChiselSim"}),", a\nlibrary for simulating Chisel-generated SystemVerilog on different simulators."]}),"\n",(0,s.jsxs)(i.p,{children:["An alternative, complementary testing strategy is to directly inspect the\nSystemVerilog or FIRRTL text that a Chisel generator produces.  This is done\nusing ",(0,s.jsx)(i.a,{href:"https://llvm.org/docs/CommandGuide/FileCheck.html",children:"FileCheck"}),"."]}),"\n",(0,s.jsx)(i.admonition,{type:"tip",children:(0,s.jsx)(i.p,{children:"The apprpriate testing strategy will depend on what you are trying to test.  It\nis likely that you will want a mix of different strategies."})}),"\n",(0,s.jsx)(i.p,{children:"Both ChiselSim and FileCheck are provided as packages inside Chisel.\nSubsections below describe these packages and their use."}),"\n",(0,s.jsx)(i.h2,{id:"chiselsim",children:"ChiselSim"}),"\n",(0,s.jsx)(i.p,{children:"ChiselSim provides a number of methods that you can use to run simulations and\nprovide stimulus to Chisel modules being tested."}),"\n",(0,s.jsx)(i.admonition,{type:"info",children:(0,s.jsx)(i.p,{children:"ChiselSim requires the installation of a compatible simulator tool, like\nVerilator or VCS."})}),"\n",(0,s.jsx)(i.p,{children:"To use ChiselSim, mix-in one of the following two traits into a class:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"chisel3.simulator.ChiselSim"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"chisel3.simulator.scalatest.ChiselSim"})}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["Both traits provide the same methods.  The latter trait provides tighter\nintegration with ",(0,s.jsx)(i.a,{href:"https://www.scalatest.org/",children:"ScalaTest"})," and will cause test\nresults to be placed in a directory structure derived from ScalaTest test names\nfor easy user inspection."]}),"\n",(0,s.jsx)(i.h3,{id:"simulation-apis",children:"Simulation APIs"}),"\n",(0,s.jsx)(i.p,{children:"ChiselSim provides two simulation APIs for running simulations.  These are:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"simulate"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"simulateRaw"})}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["The former may only be used with ",(0,s.jsx)(i.code,{children:"Module"}),"s or their subtypes.  The latter may\nonly be used with ",(0,s.jsx)(i.code,{children:"RawModule"}),"s or their subtypes."]}),"\n",(0,s.jsxs)(i.p,{children:["Thd difference between them is that ",(0,s.jsx)(i.code,{children:"simulate"})," will put the module through an\ninitialization procedure before user stimulus is applied."]}),"\n",(0,s.jsxs)(i.p,{children:["Conversely, ",(0,s.jsx)(i.code,{children:"simulateRaw"})," will apply no initialization procedure and it is up to\nthe user to provide suitable reset stimulus."]}),"\n",(0,s.jsx)(i.admonition,{type:"info",children:(0,s.jsxs)(i.p,{children:["The reason why ",(0,s.jsx)(i.code,{children:"simulate"})," can define a reset procedure is because a ",(0,s.jsx)(i.code,{children:"Module"})," has\na defined clock and reset port.  Because of this, a common pattern when working\nwith ChiselSim is to wrap your design under test in a test harness that is a\n",(0,s.jsx)(i.code,{children:"Module"}),".  The test harness will be provided with the initialization stimulus\nand any more complicated stimulus (e.g., multiple clocks) can be derived inside\nthe test harness."]})}),"\n",(0,s.jsxs)(i.p,{children:["Simulation APIs take user provided stimulus and apply it to the module.  Some\nuseful stimulus is provided in the ",(0,s.jsx)(i.code,{children:"chisel3.simulator.stimulus"})," package.  For\nexample, the ",(0,s.jsx)(i.code,{children:"RunUntilFinished"})," stimulus will toggle a ",(0,s.jsx)(i.code,{children:"Module"}),"'s clock for a\nnumber of cycles and throw an exception if the module does net execute a\n",(0,s.jsx)(i.code,{children:"chisel3.stop"})," before that number of clock cycles has elapsed."]}),"\n",(0,s.jsxs)(i.p,{children:["For more information see the ",(0,s.jsx)(i.a,{href:"https://www.chisel-lang.org/api",children:"Chisel API\ndocumentation"})," for\n",(0,s.jsx)(i.code,{children:"chisel3.simulator.SimulatorAPI"}),"."]}),"\n",(0,s.jsx)(i.h3,{id:"peekpoke-apis",children:"Peek/Poke APIs"}),"\n",(0,s.jsxs)(i.p,{children:['ChiselSim provides basic "peek", "poke", and "expect" APIs for providing simple\nstimulus to Chisel modules.  This API is implemented as ',(0,s.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Extension_method",children:"extension\nmethods"})," on Chisel types, like\n",(0,s.jsx)(i.code,{children:"Data"}),".  This means that the ports of your design under test have ",(0,s.jsx)(i.em,{children:"new"})," methods\ndefined on them that can be used to drive stimulus."]}),"\n",(0,s.jsx)(i.p,{children:"These APIs are summarized below:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"poke"})," sets a value on a port"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"peek"})," reads a value on a port"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"expect"})," reads a value on a port and asserts that it is equal another value"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"step"})," toggles a clock for a number of cycles"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"stepUntil"})," toggles a clock until a condition occurs on another port"]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["For more information see the ",(0,s.jsx)(i.a,{href:"https://www.chisel-lang.org/api",children:"Chisel API\ndocumentation"})," for\n",(0,s.jsx)(i.code,{children:"chisel3.simulator.PeekPokeAPI"}),"."]}),"\n",(0,s.jsx)(i.h3,{id:"example",children:"Example"}),"\n",(0,s.jsxs)(i.p,{children:["The example below shows a basic usage of ChiselSim inside ScalaTest.  This shows\na single test suite, ",(0,s.jsx)(i.code,{children:"ChiselSimExample"}),".  To gain access to ChiselSim methods,\nthe ",(0,s.jsx)(i.code,{children:"ChiselSim"})," trait is mixed in.  A ",(0,s.jsx)(i.a,{href:"https://www.scalatest.org/user_guide/selecting_a_style",children:"testing\nstyle"}),' is chosen and\n"should" matches are added to provide a more natural language way of writing\ntests.']}),"\n",(0,s.jsxs)(i.p,{children:["In the test, module ",(0,s.jsx)(i.code,{children:"Foo"})," is tested using custom stimulus.  Module ",(0,s.jsx)(i.code,{children:"Bar"})," is\ntested using pre-defined stimulus.  Both tests, as written, will pass."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.simulator.scalatest.ChiselSim\nimport chisel3.simulator.stimulus.RunUntilFinished\nimport chisel3.util.Counter\nimport org.scalatest.flatspec.AnyFlatSpec\nimport org.scalatest.matchers.should.Matchers\n\nclass ChiselSimExample extends AnyFlatSpec with Matchers with ChiselSim {\n\n  class Foo extends Module {\n    val a, b = IO(Input(UInt(8.W)))\n    val c = IO(Output(chiselTypeOf(a)))\n\n    private val r = Reg(chiselTypeOf(a))\n\n    r :<= a +% b\n    c :<= r\n  }\n\n  behavior of "Baz"\n\n  it should "add two numbers" in {\n\n    simulate(new Foo) { foo =>\n      // Poke different values on the two input ports.\n      foo.a.poke(1)\n      foo.b.poke(2)\n\n      // Step the clock by one cycle.\n      foo.clock.step(1)\n\n      // Expect that the sum of the two inputs is on the output port.\n      foo.c.expect(3)\n    }\n\n  }\n\n  class Bar extends Module {\n\n    val (_, done) = Counter(true.B, 10)\n\n    when (done) {\n      stop()\n    }\n\n  }\n\n  behavior of "Bar"\n\n  it should "terminate before 11 cycles have elapsed" in {\n\n    simulate(new Bar)(RunUntilFinished(11))\n\n  }\n\n}\n\n'})}),"\n",(0,s.jsx)(i.h2,{id:"filecheck",children:"FileCheck"}),"\n",(0,s.jsx)(i.p,{children:"Sometimes, it is sufficient to directly inspect the result of a generator.  This\ntesting strategy is particularly relevent if you are trying to create very\nspecific Verilog structures or to guarantee exact naming of specific constructs."}),"\n",(0,s.jsxs)(i.p,{children:["While simple testing can be done with string comparisons, this is often\ninsufficient as it is necessary to both have a mixture of regular expression\ncaptures and ordering of specific lines.  For this, Chisel provides a native way\nto write ",(0,s.jsx)(i.a,{href:"https://llvm.org/docs/CommandGuide/FileCheck.html",children:"FileCheck"})," tests."]}),"\n",(0,s.jsx)(i.admonition,{type:"info",children:(0,s.jsx)(i.p,{children:"Use of FileCheck tests requires installation of the FileCheck binary.  FileCheck\nis typically packaged as part of LLVM."})}),"\n",(0,s.jsx)(i.p,{children:"Like with ChiselSim, two different traits are provided for writing FileCheck\ntests:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"chisel3.testing.FileCheck"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"chisel3.testing.scalatest.FileCheck"})}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Both provide the same APIs, but the latter will write intermediary files to\ndirectories derived from ScalaTest suite and scope names."}),"\n",(0,s.jsxs)(i.p,{children:["Presently, only one FileCheck API is provided: ",(0,s.jsx)(i.code,{children:"fileCheck"}),".  This API is\nimplemented as an extension method on ",(0,s.jsx)(i.code,{children:"String"})," and takes two arguments: (1) a\nlist of arguments to FileCheck and (2) a string that contains an inline\nFileCheck test to run.  Both the input string and the check string will be\nwritten to disk and preserved on failure so that you can rerun them manually if\nneeded."]}),"\n",(0,s.jsxs)(i.p,{children:["If the ",(0,s.jsx)(i.code,{children:"fileCheck"})," method succeeds, nothing is returned.  If it fails, it will\nthrow an exception indicating why it failed and verbose information aobut where\nan expected string did not match."]}),"\n",(0,s.jsxs)(i.p,{children:["For more information on the API see the ",(0,s.jsx)(i.a,{href:"https://www.chisel-lang.org/api",children:"Chisel API\ndocumentation"})," for ",(0,s.jsx)(i.code,{children:"chisel3.testing.FileCheck"}),".\nFor more information on FileCheck and its usage see the ",(0,s.jsx)(i.a,{href:"https://llvm.org/docs/CommandGuide/FileCheck.html",children:"FileCheck\ndocumentation"}),"."]}),"\n",(0,s.jsx)(i.admonition,{type:"note",children:(0,s.jsxs)(i.p,{children:["FileCheck is a tool used extensively in the testing of compilers in the LLVM\necosystem.  ",(0,s.jsx)(i.a,{href:"https://github.com/llvm/circt",children:"CIRCT"}),", the compiler that converts\nthe FIRRTL that Chisel produces into SystemVerilog, makes heavy use of FileCheck\nfor its own testing."]})}),"\n",(0,s.jsx)(i.h3,{id:"example-1",children:"Example"}),"\n",(0,s.jsx)(i.p,{children:"The example below shows a FileCheck test that checks that a module has a\nspecific name and that it has some expected content inside it.  Specifically,\nthis test is checking that constant propagation happens as expected.  As\nwritten, this test will pass."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.testing.scalatest.FileCheck\nimport circt.stage.ChiselStage\nimport org.scalatest.flatspec.AnyFlatSpec\nimport org.scalatest.matchers.should.Matchers\n\nclass FileCheckExample extends AnyFlatSpec with Matchers with FileCheck {\n\n  class Baz extends RawModule {\n\n    val out = IO(Output(UInt(32.W)))\n\n    out :<= 1.U(32.W) + 3.U(32.W)\n\n  }\n\n  behavior of "Foo"\n\n  it should "simplify the constant computation in its body" in {\n\n    ChiselStage.emitSystemVerilog(new Baz).fileCheck()(\n      """|CHECK:      module Baz(\n         |CHECK-NEXT:   output [31:0] out\n         |CHECK:        assign out = 32\'h4;\n         |CHECK:      endmodule\n         |""".stripMargin\n    )\n\n  }\n\n}\n\n'})}),"\n",(0,s.jsxs)(i.admonition,{type:"note",children:[(0,s.jsxs)(i.p,{children:["FileCheck has ",(0,s.jsx)(i.em,{children:"a lot"})," of useful features that are not shown in this example."]}),(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"CHECK-SAME"})," allows for checking a match on the same line.  ",(0,s.jsx)(i.code,{children:"CHECK-NOT"})," ensures\nthat a match does ",(0,s.jsx)(i.em,{children:"not"})," happen.  ",(0,s.jsx)(i.code,{children:"CHECK-COUNT-<n>"})," will check for ",(0,s.jsx)(i.code,{children:"n"}),"\nrepetitions of a match.  ",(0,s.jsx)(i.code,{children:"CHECK-DAG"})," will allow for a series of matches to occur\nin any order."]}),(0,s.jsx)(i.p,{children:"Most powerfully, FileCheck allows for inline regular expression and saving the\nresults in string substitution blocks which can then be used later.  This is\nuseful when you care about capturing a name, but do not care about the actual\nname."}),(0,s.jsx)(i.p,{children:"Please see the FileCheck documentation for more thorough documentation."})]})]})}function d(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var s=n(6540);const t={},l=s.createContext(t);function o(e){const i=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(l.Provider,{value:i},e.children)}}}]);