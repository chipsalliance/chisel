"use strict";(self.webpackChunkchisel_lang=self.webpackChunkchisel_lang||[]).push([[5432],{9730:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var t=o(4848),a=o(8453),i=o(1871);const l={sidebar_position:0},s="General Cookbook",c={id:"cookbooks/cookbook",title:"General Cookbook",description:"Please note that these examples make use of Chisel's scala-style printing.",source:"@site/docs/cookbooks/cookbook.md",sourceDirName:"cookbooks",slug:"/cookbooks/cookbook",permalink:"/docs/cookbooks/cookbook",draft:!1,unlisted:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/cookbooks/cookbook.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0},sidebar:"chiselSidebar",previous:{title:"Cookbooks",permalink:"/docs/cookbooks"},next:{title:"Naming Cookbook",permalink:"/docs/cookbooks/naming"}},r={},d=[{value:"Type Conversions",id:"type-conversions",level:2},{value:"How do I create a UInt from an instance of a Bundle?",id:"how-do-i-create-a-uint-from-an-instance-of-a-bundle",level:3},{value:"How do I create a Bundle from a UInt?",id:"how-do-i-create-a-bundle-from-a-uint",level:3},{value:"How can I tieoff a Bundle/Vec to 0?",id:"how-can-i-tieoff-a-bundlevec-to-0",level:3},{value:"How do I create a Vec of Bools from a UInt?",id:"how-do-i-create-a-vec-of-bools-from-a-uint",level:3},{value:"How do I create a UInt from a Vec of Bool?",id:"how-do-i-create-a-uint-from-a-vec-of-bool",level:3},{value:"How do I connect a subset of Bundle fields?",id:"how-do-i-connect-a-subset-of-bundle-fields",level:3},{value:"Vectors and Registers",id:"vectors-and-registers",level:2},{value:"Can I make a 2D or 3D Vector?",id:"can-i-make-a-2d-or-3d-vector",level:3},{value:"How do I create a Vector of Registers?",id:"how-do-i-create-a-vector-of-registers",level:3},{value:"How do I create a Reg of type Vec?",id:"how-do-i-create-a-reg-of-type-vec",level:3},{value:"How do I partially reset an Aggregate Reg?",id:"how-do-i-partially-reset-an-aggregate-reg",level:3},{value:"Bundles",id:"bundles",level:2},{value:"<a></a> How do I deal with aliased Bundle fields?",id:"-how-do-i-deal-with-aliased-bundle-fields",level:3},{value:"1. 0-arity function parameters",id:"1-0-arity-function-parameters",level:4},{value:"2. By-name function parameters",id:"2-by-name-function-parameters",level:4},{value:"3. Directioned Bundle fields",id:"3-directioned-bundle-fields",level:4},{value:"4. Call <code>.cloneType</code> directly",id:"4-call-clonetype-directly",level:4},{value:"<a></a> How do I deal with the &quot;unable to clone&quot; error?",id:"-how-do-i-deal-with-the-unable-to-clone-error",level:3},{value:"How do I create a finite state machine (FSM)?",id:"how-do-i-create-a-finite-state-machine-fsm",level:2},{value:"How do I unpack a value (&quot;reverse concatenation&quot;) like in Verilog?",id:"how-do-i-unpack-a-value-reverse-concatenation-like-in-verilog",level:2},{value:"How do I do subword assignment (assign to some bits in a UInt)?",id:"how-do-i-do-subword-assignment-assign-to-some-bits-in-a-uint",level:2},{value:"How do I create an optional I/O?",id:"how-do-i-create-an-optional-io",level:2},{value:"How do I create I/O without a prefix?",id:"how-do-i-create-io-without-a-prefix",level:2},{value:"How do I override the implicit clock or reset within a Module?",id:"how-do-i-override-the-implicit-clock-or-reset-within-a-module",level:2},{value:"How do I minimize the number of bits used in an output vector?",id:"how-do-i-minimize-the-number-of-bits-used-in-an-output-vector",level:2},{value:"<a></a> How do I resolve &quot;Dynamic index ... is too wide/narrow for extractee ...&quot;?",id:"-how-do-i-resolve-dynamic-index--is-too-widenarrow-for-extractee-",level:2},{value:"Use bit extraction when the index is too wide",id:"use-bit-extraction-when-the-index-is-too-wide",level:4},{value:"Predictable Naming",id:"predictable-naming",level:2},{value:"How do I get Chisel to name signals properly in blocks like when/withClockAndReset?",id:"how-do-i-get-chisel-to-name-signals-properly-in-blocks-like-whenwithclockandreset",level:3},{value:"How do I get Chisel to name the results of vector reads properly?",id:"how-do-i-get-chisel-to-name-the-results-of-vector-reads-properly",level:3},{value:"How can I dynamically set/parametrize the name of a module?",id:"how-can-i-dynamically-setparametrize-the-name-of-a-module",level:3},{value:"Directionality",id:"directionality",level:2},{value:"How do I strip directions from a bidirectional Bundle (or other Data)?",id:"how-do-i-strip-directions-from-a-bidirectional-bundle-or-other-data",level:3}];function u(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"general-cookbook",children:"General Cookbook"}),"\n",(0,t.jsxs)(n.p,{children:["Please note that these examples make use of ",(0,t.jsx)(n.a,{href:"../explanations/printing#scala-style",children:"Chisel's scala-style printing"}),"."]}),"\n","\n","\n",(0,t.jsx)(i.A,{toc:d}),"\n",(0,t.jsx)(n.h2,{id:"type-conversions",children:"Type Conversions"}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-create-a-uint-from-an-instance-of-a-bundle",children:"How do I create a UInt from an instance of a Bundle?"}),"\n",(0,t.jsxs)(n.p,{children:["Call ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api/latest/chisel3/Bundle.html#asUInt:chisel3.UInt",children:(0,t.jsx)(n.code,{children:"asUInt"})})," on the ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api/latest/chisel3/Bundle.html",children:(0,t.jsx)(n.code,{children:"Bundle"})})," instance."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass MyBundle extends Bundle {\n  val foo = UInt(4.W)\n  val bar = UInt(4.W)\n}\n\nclass Foo extends Module {\n  val bundle = Wire(new MyBundle)\n  bundle.foo := 0xc.U\n  bundle.bar := 0x3.U\n  val uint = bundle.asUInt\n  printf(cf"$uint") // 195\n\n  // Test\n  assert(uint === 0xc3.U)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-create-a-bundle-from-a-uint",children:"How do I create a Bundle from a UInt?"}),"\n",(0,t.jsxs)(n.p,{children:["Use the ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api/latest/chisel3/UInt.html#asTypeOf%5BT%3C:chisel3.Data%5D(that:T):T",children:(0,t.jsx)(n.code,{children:"asTypeOf"})})," method to reinterpret the ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api/latest/chisel3/UInt.html",children:(0,t.jsx)(n.code,{children:"UInt"})})," as the type of the ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api/latest/chisel3/Bundle.html",children:(0,t.jsx)(n.code,{children:"Bundle"})}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass MyBundle extends Bundle {\n  val foo = UInt(4.W)\n  val bar = UInt(4.W)\n}\n\nclass Foo extends Module {\n  val uint = 0xb4.U\n  val bundle = uint.asTypeOf(new MyBundle)\n\n  printf(cf"$bundle") // Bundle(foo -> 11, bar -> 4)\n\n  // Test\n  assert(bundle.foo === 0xb.U)\n  assert(bundle.bar === 0x4.U)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"how-can-i-tieoff-a-bundlevec-to-0",children:"How can I tieoff a Bundle/Vec to 0?"}),"\n",(0,t.jsxs)(n.p,{children:["You can use ",(0,t.jsx)(n.code,{children:"asTypeOf"})," as above. If you don't want to worry about the type of the thing\nyou are tying off, you can use ",(0,t.jsx)(n.code,{children:"chiselTypeOf"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nimport circt.stage.ChiselStage\n\nclass MyBundle extends Bundle {\n  val foo = UInt(4.W)\n  val bar = Vec(4, UInt(1.W))\n}\n\nclass Foo(typ: MyBundle) extends Module {\n  val bundleA = IO(Output(typ))\n  val bundleB = IO(Output(typ))\n\n  // typ is already a Chisel Data Type, so can use it directly here, but you\n  // need to know that bundleA is of type typ\n  bundleA := 0.U.asTypeOf(typ)\n\n  // bundleB is a Hardware data IO(Output(...)) so need to call chiselTypeOf,\n  // but this will work no matter the type of bundleB:\n  bundleB := 0.U.asTypeOf(chiselTypeOf(bundleB))\n}\n\nChiselStage.emitSystemVerilog(new Foo(new MyBundle))\n"})}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-create-a-vec-of-bools-from-a-uint",children:"How do I create a Vec of Bools from a UInt?"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api/latest/chisel3/VecInit$.html",children:(0,t.jsx)(n.code,{children:"VecInit"})})," given a ",(0,t.jsx)(n.code,{children:"Seq[Bool]"})," generated using the ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api/latest/chisel3/UInt.html#asBools:Seq%5Bchisel3.Bool%5D",children:(0,t.jsx)(n.code,{children:"asBools"})})," method."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Foo extends Module {\n  val uint = 0xc.U\n  val vec = VecInit(uint.asBools)\n\n  printf(cf"$vec") // Vec(0, 0, 1, 1)\n\n  // Test\n  assert(vec(0) === false.B)\n  assert(vec(1) === false.B)\n  assert(vec(2) === true.B)\n  assert(vec(3) === true.B)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-create-a-uint-from-a-vec-of-bool",children:"How do I create a UInt from a Vec of Bool?"}),"\n",(0,t.jsxs)(n.p,{children:["Use the builtin function ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api/latest/chisel3/Vec.html#asUInt:chisel3.UInt",children:(0,t.jsx)(n.code,{children:"asUInt"})})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Foo extends Module {\n  val vec = VecInit(true.B, false.B, true.B, true.B)\n  val uint = vec.asUInt\n\n  printf(cf"$uint") // 13\n\n  // Test\n  // (remember leftmost Bool in Vec is low order bit)\n  assert(0xd.U === uint)\n\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-connect-a-subset-of-bundle-fields",children:"How do I connect a subset of Bundle fields?"}),"\n",(0,t.jsxs)(n.p,{children:["See the ",(0,t.jsx)(n.a,{href:"dataview#how-do-i-connect-a-subset-of-bundle-fields",children:"DataView cookbook"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"vectors-and-registers",children:"Vectors and Registers"}),"\n",(0,t.jsx)(n.h3,{id:"can-i-make-a-2d-or-3d-vector",children:"Can I make a 2D or 3D Vector?"}),"\n",(0,t.jsxs)(n.p,{children:["Yes. Using ",(0,t.jsx)(n.code,{children:"VecInit"})," you can make Vectors that hold Vectors of Chisel types. Methods ",(0,t.jsx)(n.code,{children:"fill"})," and ",(0,t.jsx)(n.code,{children:"tabulate"})," make these multi-dimensional Vectors."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\n\nclass MyBundle extends Bundle {\n  val foo = UInt(4.W)\n  val bar = UInt(4.W)\n}\n\nclass Foo extends Module {\n  //2D Fill\n  val twoDVec = VecInit.fill(2, 3)(5.U)\n  //3D Fill\n  val myBundle = Wire(new MyBundle)\n  myBundle.foo := 0xc.U\n  myBundle.bar := 0x3.U\n  val threeDVec = VecInit.fill(1, 2, 3)(myBundle)\n  assert(threeDVec(0)(0)(0).foo === 0xc.U && threeDVec(0)(0)(0).bar === 0x3.U)\n\n  //2D Tabulate\n  val indexTiedVec = VecInit.tabulate(2, 2){ (x, y) => (x + y).U }\n  assert(indexTiedVec(0)(0) === 0.U)\n  assert(indexTiedVec(0)(1) === 1.U)\n  assert(indexTiedVec(1)(0) === 1.U)\n  assert(indexTiedVec(1)(1) === 2.U)\n  //3D Tabulate\n  val indexTiedVec3D = VecInit.tabulate(2, 3, 4){ (x, y, z) => (x + y * z).U }\n  assert(indexTiedVec3D(0)(0)(0) === 0.U)\n  assert(indexTiedVec3D(1)(1)(1) === 2.U)\n  assert(indexTiedVec3D(1)(1)(2) === 3.U)\n  assert(indexTiedVec3D(1)(1)(3) === 4.U)\n  assert(indexTiedVec3D(1)(2)(3) === 7.U)\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-create-a-vector-of-registers",children:"How do I create a Vector of Registers?"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Rule!  Use Reg of Vec not Vec of Reg!"})}),"\n",(0,t.jsxs)(n.p,{children:["You create a ",(0,t.jsx)(n.a,{href:"#how-do-i-create-a-reg-of-type-vec",children:"Reg of type Vec"}),". Because Vecs are a ",(0,t.jsx)(n.em,{children:"type"})," (like ",(0,t.jsx)(n.code,{children:"UInt"}),", ",(0,t.jsx)(n.code,{children:"Bool"}),") rather than a ",(0,t.jsx)(n.em,{children:"value"}),", we must bind the Vec to some concrete ",(0,t.jsx)(n.em,{children:"value"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-create-a-reg-of-type-vec",children:"How do I create a Reg of type Vec?"}),"\n",(0,t.jsxs)(n.p,{children:["For more information, the API Documentation for ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api/latest/chisel3/Vec.html",children:(0,t.jsx)(n.code,{children:"Vec"})})," provides more information."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\n\nclass Foo extends Module {\n  val regOfVec = Reg(Vec(4, UInt(32.W))) // Register of 32-bit UInts\n  regOfVec(0) := 123.U                   // Assignments to elements of the Vec\n  regOfVec(1) := 456.U\n  regOfVec(2) := 789.U\n  regOfVec(3) := regOfVec(0)\n\n  // Reg of Vec of 32-bit UInts initialized to zero\n  //   Note that Seq.fill constructs 4 32-bit UInt literals with the value 0\n  //   VecInit(...) then constructs a Wire of these literals\n  //   The Reg is then initialized to the value of the Wire (which gives it the same type)\n  val initRegOfVec = RegInit(VecInit(Seq.fill(4)(0.U(32.W))))\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-partially-reset-an-aggregate-reg",children:"How do I partially reset an Aggregate Reg?"}),"\n",(0,t.jsxs)(n.p,{children:["The easiest way is to use a partially-specified ",(0,t.jsx)(n.a,{href:"#../appendix/experimental-features#bundle-literals",children:"Bundle Literal"}),"\nor ",(0,t.jsx)(n.a,{href:"#../appendix/experimental-features#vec-literals",children:"Vec Literal"})," to match the type of the Reg."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nimport chisel3.experimental.BundleLiterals._\n\nclass MyBundle extends Bundle {\n  val foo = UInt(8.W)\n  val bar = UInt(8.W)\n}\n\nclass MyModule extends Module {\n  // Only .foo will be reset, .bar will have no reset value\n  val reg = RegInit((new MyBundle).Lit(_.foo -> 123.U))\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If your initial value is not a literal, or if you just prefer, you can use a\nWire as the initial value for the Reg. Simply connect fields to ",(0,t.jsx)(n.code,{children:"DontCare"})," that\nyou do not wish to be reset."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class MyModule2 extends Module {\n  val reg = RegInit({\n    // The wire could be constructed before the reg rather than in the RegInit scope,\n    // but this style has nice lexical scoping behavior, keeping the Wire private\n    val init = Wire(new MyBundle)\n    init := DontCare // No fields will be reset\n    init.foo := 123.U // Last connect override, .foo is reset\n    init\n  })\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"bundles",children:"Bundles"}),"\n",(0,t.jsxs)(n.h3,{id:"-how-do-i-deal-with-aliased-bundle-fields",children:[(0,t.jsx)("a",{name:"aliased-bundle-fields"})," How do I deal with aliased Bundle fields?"]}),"\n",(0,t.jsxs)(n.p,{children:["Following the ",(0,t.jsx)(n.code,{children:"gen"})," pattern when creating Bundles can result in some opaque error messages:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class AliasedBundle[T <: Data](gen: T) extends Bundle {\n  val foo = gen\n  val bar = gen\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"getVerilogString(new Top(new AliasedBundle(UInt(8.W))))\n// chisel3.AliasedAggregateFieldException: AliasedBundle contains aliased fields named (bar,foo)\n// \tat ... ()\n// \tat repl.MdocSession$MdocApp17$Top$$anonfun$50$$anonfun$apply$37.apply(cookbook.md:301)\n// \tat repl.MdocSession$MdocApp17$Top$$anonfun$50$$anonfun$apply$37.apply(cookbook.md:301)\n// \tat chisel3.experimental.prefix$.apply(prefix.scala:50)\n// \tat repl.MdocSession$MdocApp17$Top$$anonfun$50.apply(cookbook.md:301)\n// \tat repl.MdocSession$MdocApp17$Top$$anonfun$50.apply(cookbook.md)\n// \tat chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33)\n// \tat repl.MdocSession$MdocApp17$Top.<init>(cookbook.md:301)\n// \tat repl.MdocSession$MdocApp17$$anonfun$55$$anonfun$apply$43.apply(cookbook.md:320)\n// \tat repl.MdocSession$MdocApp17$$anonfun$55$$anonfun$apply$43.apply(cookbook.md:320)\n// \tat chisel3.Module$.evaluate(Module.scala:92)\n// \tat chisel3.Module$.do_apply(Module.scala:35)\n// \tat chisel3.stage.phases.Elaborate.$anonfun$transform$2(Elaborate.scala:49)\n// \tat chisel3.internal.Builder$.$anonfun$buildImpl$1(Builder.scala:1030)\n// \tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \tat chisel3.internal.Builder$.buildImpl(Builder.scala:1024)\n// \tat chisel3.internal.Builder$.$anonfun$build$1(Builder.scala:1016)\n// \tat logger.Logger$.$anonfun$makeScope$4(Logger.scala:148)\n// \tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \tat logger.Logger$.makeScope(Logger.scala:146)\n// \tat logger.Logger$.makeScope(Logger.scala:133)\n// \tat ... ()\n// \tat ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This error is saying that fields ",(0,t.jsx)(n.code,{children:"foo"})," and ",(0,t.jsx)(n.code,{children:"bar"})," of ",(0,t.jsx)(n.code,{children:"AliasedBundle"})," are the\nexact same object in memory.\nThis is a problem for Chisel because we need to be able to distinguish uses of\n",(0,t.jsx)(n.code,{children:"foo"})," and ",(0,t.jsx)(n.code,{children:"bar"})," but cannot when they are referentially the same."]}),"\n",(0,t.jsx)(n.p,{children:"Note that the following example looks different but will give you exactly the same issue:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class AlsoAliasedBundle[T <: Data](val gen: T) extends Bundle {\n                                // ^ This val makes `gen` a field, just like `foo`\n  val foo = gen\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["By making ",(0,t.jsx)(n.code,{children:"gen"})," a ",(0,t.jsx)(n.code,{children:"val"}),", it becomes a public field of the ",(0,t.jsx)(n.code,{children:"class"}),", just like ",(0,t.jsx)(n.code,{children:"foo"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"getVerilogString(new Top(new AlsoAliasedBundle(UInt(8.W))))\n// chisel3.AliasedAggregateFieldException: AlsoAliasedBundle contains aliased fields named (foo,gen)\n// \tat ... ()\n// \tat repl.MdocSession$MdocApp17$Top$$anonfun$50$$anonfun$apply$37.apply(cookbook.md:301)\n// \tat repl.MdocSession$MdocApp17$Top$$anonfun$50$$anonfun$apply$37.apply(cookbook.md:301)\n// \tat chisel3.experimental.prefix$.apply(prefix.scala:50)\n// \tat repl.MdocSession$MdocApp17$Top$$anonfun$50.apply(cookbook.md:301)\n// \tat repl.MdocSession$MdocApp17$Top$$anonfun$50.apply(cookbook.md)\n// \tat chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33)\n// \tat repl.MdocSession$MdocApp17$Top.<init>(cookbook.md:301)\n// \tat repl.MdocSession$MdocApp17$$anonfun$57$$anonfun$apply$44.apply(cookbook.md:339)\n// \tat repl.MdocSession$MdocApp17$$anonfun$57$$anonfun$apply$44.apply(cookbook.md:339)\n// \tat chisel3.Module$.evaluate(Module.scala:92)\n// \tat chisel3.Module$.do_apply(Module.scala:35)\n// \tat chisel3.stage.phases.Elaborate.$anonfun$transform$2(Elaborate.scala:49)\n// \tat chisel3.internal.Builder$.$anonfun$buildImpl$1(Builder.scala:1030)\n// \tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \tat chisel3.internal.Builder$.buildImpl(Builder.scala:1024)\n// \tat chisel3.internal.Builder$.$anonfun$build$1(Builder.scala:1016)\n// \tat logger.Logger$.$anonfun$makeScope$4(Logger.scala:148)\n// \tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \tat logger.Logger$.makeScope(Logger.scala:146)\n// \tat logger.Logger$.makeScope(Logger.scala:133)\n// \tat ... ()\n// \tat ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)\n"})}),"\n",(0,t.jsx)(n.p,{children:"There are several ways to solve this issue with their own advantages and disadvantages."}),"\n",(0,t.jsx)(n.h4,{id:"1-0-arity-function-parameters",children:"1. 0-arity function parameters"}),"\n",(0,t.jsx)(n.p,{children:"Instead of passing an object as a parameter, you can pass a 0-arity function (a function with no arguments):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class UsingAFunctionBundle[T <: Data](gen: () => T) extends Bundle {\n  val foo = gen()\n  val bar = gen()\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that the type of ",(0,t.jsx)(n.code,{children:"gen"})," is now ",(0,t.jsx)(n.code,{children:"() => T"}),".\nBecause it is now a function and not a subtype of ",(0,t.jsx)(n.code,{children:"Data"}),", you can safely make ",(0,t.jsx)(n.code,{children:"gen"})," a ",(0,t.jsx)(n.code,{children:"val"})," without\nit becoming a hardware field of the ",(0,t.jsx)(n.code,{children:"Bundle"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that this also means you must pass ",(0,t.jsx)(n.code,{children:"gen"})," as a function, for example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"getVerilogString(new Top(new UsingAFunctionBundle(() => UInt(8.W))))\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)("a",{name:"aliased-warning"})," ",(0,t.jsx)(n.strong,{children:"Warning"}),": you must ensure that ",(0,t.jsx)(n.code,{children:"gen"})," creates fresh objects rather than capturing an already constructed value:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class MisusedFunctionArguments extends Module {\n  // This usage is correct\n  val in = IO(Input(new UsingAFunctionBundle(() => UInt(8.W))))\n\n  // This usage is incorrect\n  val fizz = UInt(8.W)\n  val out = IO(Output(new UsingAFunctionBundle(() => fizz)))\n}\ngetVerilogString(new MisusedFunctionArguments)\n// chisel3.AutoClonetypeException: The bundle plugin was unable to clone UsingAFunctionBundle that has field 'foo' aliased with base UsingAFunctionBundle.This likely happened because you tried nesting Data arguments inside of other data structures. Try wrapping the field(s) in Input(...), Output(...), or Flipped(...) if appropriate. As a last resort, you can call chisel3.reflect.DataMirror.internal.chiselTypeClone on any nested Data arguments. See the cookbook entry 'How do I deal with the \"unable to clone\" error?' for more details.\n// \tat ... ()\n// \tat repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1$$anonfun$62$$anonfun$apply$51$$anonfun$apply$52.apply(cookbook.md:370)\n// \tat repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1$$anonfun$62$$anonfun$apply$51$$anonfun$apply$52.apply(cookbook.md:370)\n// \tat chisel3.IO$.apply(IO.scala:34)\n// \tat chisel3.experimental.BaseModule.IO(Module.scala:821)\n// \tat repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1$$anonfun$62$$anonfun$apply$51.apply(cookbook.md:370)\n// \tat repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1$$anonfun$62$$anonfun$apply$51.apply(cookbook.md:370)\n// \tat chisel3.experimental.prefix$.apply(prefix.scala:50)\n// \tat repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1$$anonfun$62.apply(cookbook.md:370)\n// \tat repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1$$anonfun$62.apply(cookbook.md)\n// \tat chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33)\n// \tat repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1.<init>(cookbook.md:370)\n// \tat repl.MdocSession$MdocApp17$$anonfun$59$$anonfun$apply$55.apply(cookbook.md:372)\n// \tat repl.MdocSession$MdocApp17$$anonfun$59$$anonfun$apply$55.apply(cookbook.md:372)\n// \tat chisel3.Module$.evaluate(Module.scala:92)\n// \tat chisel3.Module$.do_apply(Module.scala:35)\n// \tat chisel3.stage.phases.Elaborate.$anonfun$transform$2(Elaborate.scala:49)\n// \tat chisel3.internal.Builder$.$anonfun$buildImpl$1(Builder.scala:1030)\n// \tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \tat chisel3.internal.Builder$.buildImpl(Builder.scala:1024)\n// \tat chisel3.internal.Builder$.$anonfun$build$1(Builder.scala:1016)\n// \tat logger.Logger$.$anonfun$makeScope$4(Logger.scala:148)\n// \tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \tat logger.Logger$.makeScope(Logger.scala:146)\n// \tat logger.Logger$.makeScope(Logger.scala:133)\n// \tat ... ()\n// \tat ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the above example, value ",(0,t.jsx)(n.code,{children:"fizz"})," and fields ",(0,t.jsx)(n.code,{children:"foo"})," and ",(0,t.jsx)(n.code,{children:"bar"})," of ",(0,t.jsx)(n.code,{children:"out"})," are all the same object in memory."]}),"\n",(0,t.jsx)(n.h4,{id:"2-by-name-function-parameters",children:"2. By-name function parameters"}),"\n",(0,t.jsxs)(n.p,{children:["Functionally the same as (1) but with more subtle syntax, you can use ",(0,t.jsx)(n.a,{href:"https://docs.scala-lang.org/tour/by-name-parameters.html",children:"Scala by-name function parameters"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class UsingByNameParameters[T <: Data](gen: => T) extends Bundle {\n  val foo = gen\n  val bar = gen\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["With this usage, you do not include ",(0,t.jsx)(n.code,{children:"() =>"})," when passing the argument:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"getVerilogString(new Top(new UsingByNameParameters(UInt(8.W))))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that as this is just syntactic sugar over (1), the ",(0,t.jsx)(n.a,{href:"#aliased-warning",children:"same warning applies"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"3-directioned-bundle-fields",children:"3. Directioned Bundle fields"}),"\n",(0,t.jsxs)(n.p,{children:["You can alternatively wrap the fields with ",(0,t.jsx)(n.code,{children:"Output(...)"}),", which creates fresh instances of the passed argument.\nChisel treats ",(0,t.jsx)(n.code,{children:"Output"}),' as the "default direction" so if all fields are outputs, the ',(0,t.jsx)(n.code,{children:"Bundle"})," is functionally equivalent to a ",(0,t.jsx)(n.code,{children:"Bundle"})," with no directioned fields."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class DirectionedBundle[T <: Data](gen: T) extends Bundle {\n  val foo = Output(gen)\n  val bar = Output(gen)\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This approach is admittedly a little ugly and may mislead others reading the code because it implies that this Bundle is intended to be used as an ",(0,t.jsx)(n.code,{children:"Output"}),"."]}),"\n",(0,t.jsxs)(n.h4,{id:"4-call-clonetype-directly",children:["4. Call ",(0,t.jsx)(n.code,{children:".cloneType"})," directly"]}),"\n",(0,t.jsxs)(n.p,{children:["You can also just call ",(0,t.jsx)(n.code,{children:".cloneType"})," on your ",(0,t.jsx)(n.code,{children:"gen"})," argument directly.\nWhile we try to hide this implementation detail from the user, ",(0,t.jsx)(n.code,{children:".cloneType"})," is the mechanism by which Chisel creates fresh instances of ",(0,t.jsx)(n.code,{children:"Data"})," objects:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class UsingCloneTypeBundle[T <: Data](gen: T) extends Bundle {\n  val foo = gen.cloneType\n  val bar = gen.cloneType\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"-how-do-i-deal-with-the-unable-to-clone-error",children:[(0,t.jsx)("a",{name:"bundle-unable-to-clone"}),' How do I deal with the "unable to clone" error?']}),"\n",(0,t.jsx)(n.p,{children:'Most Chisel objects need to be cloned in order to differentiate between the\nsoftware representation of the bundle field from its "bound" hardware\nrepresentation, where "binding" is the process of generating a hardware\ncomponent. For Bundle fields, this cloning is supposed to happen automatically\nwith a compiler plugin.'}),"\n",(0,t.jsxs)(n.p,{children:["In some cases though, the plugin may not be able to clone the Bundle fields. The\nmost common case for when this happens is when the ",(0,t.jsx)(n.code,{children:"chisel3.Data"})," part of the\nBundle field is nested inside some other data structure and the compiler plugin\nis unable to figure out how to clone the entire structure. It is best to avoid\nsuch nested structures."]}),"\n",(0,t.jsxs)(n.p,{children:["There are a few ways around this issue - you can try wrapping the problematic\nfields in Input(...), Output(...), or Flipped(...) if appropriate. You can also\ntry manually cloning each field in the Bundle using the ",(0,t.jsx)(n.code,{children:"chiselTypeClone"})," method\nin ",(0,t.jsx)(n.code,{children:"chisel3.reflect.DataMirror"}),". Here's an example with the Bundle whose fields\nwon't get cloned:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'class CustomBundleBroken(elts: (String, Data)*) extends Record {\n  val elements = ListMap(elts: _*)\n\n  def apply(elt: String): Data = elements(elt)\n}\n\nclass NewModule extends Module {\n  val out = Output(UInt(8.W))\n  val recordType = new CustomBundleBroken("fizz" -> UInt(16.W), "buzz" -> UInt(16.W))\n  val record = Wire(recordType)\n  val uint = record.asUInt\n  val record2 = uint.asTypeOf(recordType)\n  out := record\n}\ngetVerilogString(new NewModule)\n// chisel3.AutoClonetypeException: The bundle plugin was unable to clone CustomBundleBroken$1 that has field \'fizz\' aliased with base CustomBundleBroken$1.This likely happened because you tried nesting Data arguments inside of other data structures. Try wrapping the field(s) in Input(...), Output(...), or Flipped(...) if appropriate. As a last resort, you can call chisel3.reflect.DataMirror.internal.chiselTypeClone on any nested Data arguments. See the cookbook entry \'How do I deal with the "unable to clone" error?\' for more details.\n// \tat ... ()\n// \tat repl.MdocSession$MdocApp17$$anonfun$70$NewModule$1$$anonfun$74$$anonfun$apply$63.apply(cookbook.md:444)\n// \tat repl.MdocSession$MdocApp17$$anonfun$70$NewModule$1$$anonfun$74$$anonfun$apply$63.apply(cookbook.md:444)\n// \tat chisel3.experimental.prefix$.apply(prefix.scala:50)\n// \tat repl.MdocSession$MdocApp17$$anonfun$70$NewModule$1$$anonfun$74.apply(cookbook.md:444)\n// \tat repl.MdocSession$MdocApp17$$anonfun$70$NewModule$1$$anonfun$74.apply(cookbook.md)\n// \tat chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33)\n// \tat repl.MdocSession$MdocApp17$$anonfun$70$NewModule$1.<init>(cookbook.md:444)\n// \tat repl.MdocSession$MdocApp17$$anonfun$70$$anonfun$apply$67.apply(cookbook.md:449)\n// \tat repl.MdocSession$MdocApp17$$anonfun$70$$anonfun$apply$67.apply(cookbook.md:449)\n// \tat chisel3.Module$.evaluate(Module.scala:92)\n// \tat chisel3.Module$.do_apply(Module.scala:35)\n// \tat chisel3.stage.phases.Elaborate.$anonfun$transform$2(Elaborate.scala:49)\n// \tat chisel3.internal.Builder$.$anonfun$buildImpl$1(Builder.scala:1030)\n// \tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \tat chisel3.internal.Builder$.buildImpl(Builder.scala:1024)\n// \tat chisel3.internal.Builder$.$anonfun$build$1(Builder.scala:1016)\n// \tat logger.Logger$.$anonfun$makeScope$4(Logger.scala:148)\n// \tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \tat logger.Logger$.makeScope(Logger.scala:146)\n// \tat logger.Logger$.makeScope(Logger.scala:133)\n// \tat ... ()\n// \tat ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["You can use ",(0,t.jsx)(n.code,{children:"chiselTypeClone"})," to clone the elements as:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3.reflect.DataMirror\nimport chisel3.experimental.requireIsChiselType\n\nclass CustomBundleFixed(elts: (String, Data)*) extends Record {\n  val elements = ListMap(elts.map {\n    case (field, elt) =>\n      requireIsChiselType(elt)\n      field -> DataMirror.internal.chiselTypeClone(elt)\n  }: _*)\n\n  def apply(elt: String): Data = elements(elt)\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"how-do-i-create-a-finite-state-machine-fsm",children:"How do I create a finite state machine (FSM)?"}),"\n",(0,t.jsxs)(n.p,{children:["The advised way is to use ",(0,t.jsx)(n.code,{children:"ChiselEnum"})," to construct enumerated types representing the state of the FSM.\nState transitions are then handled with ",(0,t.jsx)(n.code,{children:"switch"}),"/",(0,t.jsx)(n.code,{children:"is"})," and ",(0,t.jsx)(n.code,{children:"when"}),"/",(0,t.jsx)(n.code,{children:".elsewhen"}),"/",(0,t.jsx)(n.code,{children:".otherwise"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nimport chisel3.util.{switch, is}\n\nobject DetectTwoOnes {\n  object State extends ChiselEnum {\n    val sNone, sOne1, sTwo1s = Value\n  }\n}\n\n/* This FSM detects two 1's one after the other */\nclass DetectTwoOnes extends Module {\n  import DetectTwoOnes.State\n  import DetectTwoOnes.State._\n\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(Bool())\n    val state = Output(State())\n  })\n\n  val state = RegInit(sNone)\n\n  io.out := (state === sTwo1s)\n  io.state := state\n\n  switch (state) {\n    is (sNone) {\n      when (io.in) {\n        state := sOne1\n      }\n    }\n    is (sOne1) {\n      when (io.in) {\n        state := sTwo1s\n      } .otherwise {\n        state := sNone\n      }\n    }\n    is (sTwo1s) {\n      when (!io.in) {\n        state := sNone\n      }\n    }\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note: the ",(0,t.jsx)(n.code,{children:"is"})," statement can take multiple conditions e.g. ",(0,t.jsx)(n.code,{children:"is (sTwo1s, sOne1) { ... }"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"how-do-i-unpack-a-value-reverse-concatenation-like-in-verilog",children:'How do I unpack a value ("reverse concatenation") like in Verilog?'}),"\n",(0,t.jsxs)(n.p,{children:["In Verilog, you can do something like the following which will unpack a the value ",(0,t.jsx)(n.code,{children:"z"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"wire [1:0] a;\nwire [3:0] b;\nwire [2:0] c;\nwire [8:0] z = [...];\nassign {a,b,c} = z;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Unpacking often corresponds to reinterpreting an unstructured data type as a structured data type.\nFrequently, this structured type is used prolifically in the design, and has been declared as in the following example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\n\nclass MyBundle extends Bundle {\n  val a = UInt(2.W)\n  val b = UInt(4.W)\n  val c = UInt(3.W)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"The easiest way to accomplish this in Chisel would be:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'class Foo extends Module {\n  val z = Wire(UInt(9.W))\n  z := DontCare // This is a dummy connection\n  val unpacked = z.asTypeOf(new MyBundle)\n  printf("%d", unpacked.a)\n  printf("%d", unpacked.b)\n  printf("%d", unpacked.c)\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If you ",(0,t.jsx)(n.strong,{children:"really"})," need to do this for a one-off case (Think thrice! It is likely you can better structure the code using bundles), then rocket-chip has a ",(0,t.jsx)(n.a,{href:"https://github.com/freechipsproject/rocket-chip/blob/723af5e6b69e07b5f94c46269a208a8d65e9d73b/src/main/scala/util/Misc.scala#L140",children:"Split utility"})," which can accomplish this."]}),"\n",(0,t.jsx)(n.h2,{id:"how-do-i-do-subword-assignment-assign-to-some-bits-in-a-uint",children:"How do I do subword assignment (assign to some bits in a UInt)?"}),"\n",(0,t.jsxs)(n.p,{children:["You may try to do something like the following where you want to assign only some bits of a Chisel type.\nBelow, the left-hand side connection to ",(0,t.jsx)(n.code,{children:"io.out(0)"})," is not allowed."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nimport circt.stage.ChiselStage\n\nclass Foo extends Module {\n  val io = IO(new Bundle {\n    val bit = Input(Bool())\n    val out = Output(UInt(10.W))\n  })\n  io.out(0) := io.bit\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"If you try to compile this, you will get an error."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"getVerilogString(new Foo)\n// chisel3.package$ChiselException: Cannot reassign to read-only Foo.?: OpResult[Bool]\n// \tat ... ()\n// \tat repl.MdocSession$MdocApp26$Foo.<init>(cookbook.md:589)\n// \tat repl.MdocSession$MdocApp26$$anonfun$104$$anonfun$apply$90.apply(cookbook.md:597)\n// \tat repl.MdocSession$MdocApp26$$anonfun$104$$anonfun$apply$90.apply(cookbook.md:597)\n// \tat chisel3.Module$.evaluate(Module.scala:92)\n// \tat chisel3.Module$.do_apply(Module.scala:35)\n// \tat chisel3.stage.phases.Elaborate.$anonfun$transform$2(Elaborate.scala:49)\n// \tat chisel3.internal.Builder$.$anonfun$buildImpl$1(Builder.scala:1030)\n// \tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \tat chisel3.internal.Builder$.buildImpl(Builder.scala:1024)\n// \tat chisel3.internal.Builder$.$anonfun$build$1(Builder.scala:1016)\n// \tat logger.Logger$.$anonfun$makeScope$4(Logger.scala:148)\n// \tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \tat logger.Logger$.makeScope(Logger.scala:146)\n// \tat logger.Logger$.makeScope(Logger.scala:133)\n// \tat ... ()\n// \tat ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Chisel3 ",(0,t.jsx)(n.em,{children:"does not support subword assignment"}),".\nThe reason for this is that subword assignment generally hints at a better abstraction with an aggregate/structured types, i.e., a ",(0,t.jsx)(n.code,{children:"Bundle"})," or a ",(0,t.jsx)(n.code,{children:"Vec"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If you must express it this way, one approach is to blast your ",(0,t.jsx)(n.code,{children:"UInt"})," to a ",(0,t.jsx)(n.code,{children:"Vec"})," of ",(0,t.jsx)(n.code,{children:"Bool"})," and back:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\n\nclass Foo extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(10.W))\n    val bit = Input(Bool())\n    val out = Output(UInt(10.W))\n  })\n  val bools = VecInit(io.in.asBools)\n  bools(0) := io.bit\n  io.out := bools.asUInt\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"how-do-i-create-an-optional-io",children:"How do I create an optional I/O?"}),"\n",(0,t.jsxs)(n.p,{children:["The following example is a module which includes the optional port ",(0,t.jsx)(n.code,{children:"out2"})," only if the given parameter is ",(0,t.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\n\nclass ModuleWithOptionalIOs(flag: Boolean) extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(12.W))\n    val out = Output(UInt(12.W))\n    val out2 = if (flag) Some(Output(UInt(12.W))) else None\n  })\n\n  io.out := io.in\n  if (flag) {\n    io.out2.get := io.in\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The following is an example where an entire ",(0,t.jsx)(n.code,{children:"IO"})," is optional:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\n\nclass ModuleWithOptionalIO(flag: Boolean) extends Module {\n  val in = if (flag) Some(IO(Input(Bool()))) else None\n  val out = IO(Output(Bool()))\n\n  out := in.getOrElse(false.B)\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"how-do-i-create-io-without-a-prefix",children:"How do I create I/O without a prefix?"}),"\n",(0,t.jsxs)(n.p,{children:["In most cases, you can simply call ",(0,t.jsx)(n.code,{children:"IO"})," multiple times:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\n\nclass MyModule extends Module {\n  val in = IO(Input(UInt(8.W)))\n  val out = IO(Output(UInt(8.W)))\n\n  out := in +% 1.U\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.67.0\nmodule MyModule(\t// cookbook.md:691:7\n  input        clock,\t// cookbook.md:691:7\n               reset,\t// cookbook.md:691:7\n  input  [7:0] in,\t// cookbook.md:692:14\n  output [7:0] out\t// cookbook.md:693:15\n);\n\n  assign out = in + 8'h1;\t// cookbook.md:691:7, :695:13\nendmodule\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you have a ",(0,t.jsx)(n.code,{children:"Bundle"})," from which you would like to create ports without the\nnormal ",(0,t.jsx)(n.code,{children:"val"})," prefix, you can use ",(0,t.jsx)(n.code,{children:"FlatIO"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\n\nclass MyBundle extends Bundle {\n  val foo = Input(UInt(8.W))\n  val bar = Output(UInt(8.W))\n}\n\nclass MyModule extends Module {\n  val io = FlatIO(new MyBundle)\n\n  io.bar := io.foo +% 1.U\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that ",(0,t.jsx)(n.code,{children:"io_"})," is nowhere to be seen!"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.67.0\nmodule MyModule(\t// cookbook.md:720:7\n  input        clock,\t// cookbook.md:720:7\n               reset,\t// cookbook.md:720:7\n  input  [7:0] foo,\t// cookbook.md:721:18\n  output [7:0] bar\t// cookbook.md:721:18\n);\n\n  assign bar = foo + 8'h1;\t// cookbook.md:720:7, :723:20\nendmodule\n\n"})}),"\n",(0,t.jsx)(n.h2,{id:"how-do-i-override-the-implicit-clock-or-reset-within-a-module",children:"How do I override the implicit clock or reset within a Module?"}),"\n",(0,t.jsxs)(n.p,{children:["To change the clock or reset for a region of code, use ",(0,t.jsx)(n.code,{children:"withClock"}),", ",(0,t.jsx)(n.code,{children:"withReset"}),", or ",(0,t.jsx)(n.code,{children:"withClockAndReset"}),".\nSee ",(0,t.jsx)(n.a,{href:"../explanations/multi-clock",children:"Multiple Clock Domains"})," for examples and details."]}),"\n",(0,t.jsxs)(n.p,{children:["To override the clock or reset for the entire scope of the ",(0,t.jsx)(n.code,{children:"Module"}),", you can mixin the ",(0,t.jsx)(n.code,{children:"ImplicitClock"})," and ",(0,t.jsx)(n.code,{children:"ImplicitReset"})," traits."]}),"\n",(0,t.jsx)(n.p,{children:'For example, you could "gate" the default implicit clock as follows:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nclass MyModule extends Module with ImplicitClock {\n  val gate = IO(Input(Bool()))\n  val in = IO(Input(UInt(8.W)))\n  val out = IO(Output(UInt(8.W)))\n  // We could just assign this to val implicitClock, but this allows us to give it a custom name\n  val gatedClock = (clock.asBool || gate).asClock\n  // The trait requires us to implement this method referring to the clock\n  // Note that this is a def, but the actual clock value must be assigned to a val\n  override protected def implicitClock = gatedClock\n\n  val r = Reg(UInt(8.W))\n  out := r\n  r := in\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This gives the following Verilog:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.67.0\nmodule MyModule(\n  input        clock,\n               reset,\n               gate,\n  input  [7:0] in,\n  output [7:0] out\n);\n\n  wire       gatedClock = clock | gate;\n  reg  [7:0] r;\n  always @(posedge gatedClock)\n    r <= in;\n  assign out = r;\nendmodule\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you do not care about the name of the overriden clock, you can just assign it to ",(0,t.jsx)(n.code,{children:"val implicitClock"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"override protected val implicitClock = (clock.asBool || gate).asClock\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ImplicitReset"})," works analogously to ",(0,t.jsx)(n.code,{children:"ImplicitClock"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"how-do-i-minimize-the-number-of-bits-used-in-an-output-vector",children:"How do I minimize the number of bits used in an output vector?"}),"\n",(0,t.jsxs)(n.p,{children:["Use inferred width and a ",(0,t.jsx)(n.code,{children:"Seq"})," instead of a ",(0,t.jsx)(n.code,{children:"Vec"}),":"]}),"\n",(0,t.jsx)(n.p,{children:"Consider:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\n\n// Count the number of set bits up to and including each bit position\nclass CountBits(width: Int) extends Module {\n  val bits = IO(Input(UInt(width.W)))\n  val countVector = IO(Output(Vec(width, UInt())))\n\n  private val countSequence = Seq.tabulate(width)(i => Wire(UInt()))\n  countSequence.zipWithIndex.foreach { case (port, i) =>\n    port := util.PopCount(bits(i, 0))\n  }\n  countVector := countSequence\n}\n\nclass Top(width: Int) extends Module {\n  val countBits = Module(new CountBits(width))\n  countBits.bits :<>= DontCare\n  dontTouch(countBits.bits)\n  dontTouch(countBits.countVector)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Note that top modules or public modules cannot have unknown widths."}),"\n",(0,t.jsxs)(n.p,{children:["Unlike ",(0,t.jsx)(n.code,{children:"Vecs"})," which represent a singular Chisel type and must have the same width for every element,\n",(0,t.jsx)(n.code,{children:"Seq"})," is a purely Scala construct, so their elements are independent from the perspective of Chisel and can have different widths."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.67.0\nmodule CountBits(\t// cookbook.md:780:7\n  input  [3:0] bits,\t// cookbook.md:781:16\n  output [2:0] countVector_0,\t// cookbook.md:782:23\n               countVector_1,\t// cookbook.md:782:23\n               countVector_2,\t// cookbook.md:782:23\n               countVector_3\t// cookbook.md:782:23\n);\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"-how-do-i-resolve-dynamic-index--is-too-widenarrow-for-extractee-",children:[(0,t.jsx)("a",{id:"dynamic-index-too-wide-narrow"}),' How do I resolve "Dynamic index ... is too wide/narrow for extractee ..."?']}),"\n",(0,t.jsx)(n.p,{children:'Chisel will warn if a dynamic index is not the correctly-sized width for indexing a Vec or UInt.\n"Correctly-sized" means that the width of the index should be the log2 of the size of the indexee.\nIf the indexee is a non-power-of-2 size, use the ceiling of the log2 result.'}),"\n",(0,t.jsxs)(n.p,{children:["When the index does not have enough bits to address all entries or bits in the extractee, you can ",(0,t.jsx)(n.code,{children:".pad"})," the index to increase the width."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class TooNarrow extends RawModule {\n  val extractee = Wire(UInt(7.W))\n  val index = Wire(UInt(2.W))\n  extractee(index)\n}\ncompile(new TooNarrow)\n// [warn] cookbook.md 829:12: [W003] Dynamic index with width 2 is too small for extractee of width 7\n// [warn] There were 1 warning(s) during hardware elaboration.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This can be fixed with ",(0,t.jsx)(n.code,{children:"pad"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class TooNarrowFixed extends RawModule {\n  val extractee = Wire(UInt(7.W))\n  val index = Wire(UInt(2.W))\n  extractee(index.pad(3))\n}\ncompile(new TooNarrowFixed)\n"})}),"\n",(0,t.jsx)(n.h4,{id:"use-bit-extraction-when-the-index-is-too-wide",children:"Use bit extraction when the index is too wide"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class TooWide extends RawModule {\n  val extractee = Wire(Vec(8, UInt(32.W)))\n  val index = Wire(UInt(4.W))\n  extractee(index)\n}\ncompile(new TooWide)\n// [warn] cookbook.md 855:12: [W004] Dynamic index with width 4 is too wide for Vec of size 8 (expected index width 3).\n// [warn] There were 1 warning(s) during hardware elaboration.\n"})}),"\n",(0,t.jsx)(n.p,{children:"This can be fixed with bit extraction:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class TooWideFixed extends RawModule {\n  val extractee = Wire(Vec(8, UInt(32.W)))\n  val index = Wire(UInt(4.W))\n  extractee(index(2, 0))\n}\ncompile(new TooWideFixed)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that size 1 ",(0,t.jsx)(n.code,{children:"Vecs"})," and ",(0,t.jsx)(n.code,{children:"UInts"})," should be indexed by a zero-width ",(0,t.jsx)(n.code,{children:"UInt"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class SizeOneVec extends RawModule {\n  val extractee = Wire(Vec(1, UInt(32.W)))\n  val index = Wire(UInt(0.W))\n  extractee(index)\n}\ncompile(new SizeOneVec)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Because ",(0,t.jsx)(n.code,{children:"pad"})," only pads if the desired width is less than the current width of the argument,\nyou can use ",(0,t.jsx)(n.code,{children:"pad"})," in conjunction with bit extraction when the widths may be too wide or too\nnarrow under different circumstances"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3.util.log2Ceil\nclass TooWideOrNarrow(extracteeSize: Int, indexWidth: Int) extends Module {\n  val extractee = Wire(Vec(extracteeSize, UInt(8.W)))\n  val index = Wire(UInt(indexWidth.W))\n  val correctWidth = log2Ceil(extracteeSize)\n  extractee(index.pad(correctWidth)(correctWidth - 1, 0))\n}\ncompile(new TooWideOrNarrow(8, 2))\ncompile(new TooWideOrNarrow(8, 4))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Another option for dynamic bit selection of ",(0,t.jsx)(n.code,{children:"UInts"})," (but not ",(0,t.jsx)(n.code,{children:"Vec"})," dynamic indexing) is to do a dynamic\nright shift of the extractee by the index and then just bit select a single bit:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"class TooWideOrNarrowUInt(extracteeSize: Int, indexWidth: Int) extends Module {\n  val extractee = Wire(UInt(extracteeSize.W))\n  val index = Wire(UInt(indexWidth.W))\n  (extractee >> index)(0)\n}\ncompile(new TooWideOrNarrowUInt(8, 2))\ncompile(new TooWideOrNarrowUInt(8, 4))\n"})}),"\n",(0,t.jsx)(n.h2,{id:"predictable-naming",children:"Predictable Naming"}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-get-chisel-to-name-signals-properly-in-blocks-like-whenwithclockandreset",children:"How do I get Chisel to name signals properly in blocks like when/withClockAndReset?"}),"\n",(0,t.jsxs)(n.p,{children:["Use the compiler plugin, and check out the ",(0,t.jsx)(n.a,{href:"naming",children:"Naming Cookbook"})," if that still does not do what you want."]}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-get-chisel-to-name-the-results-of-vector-reads-properly",children:"How do I get Chisel to name the results of vector reads properly?"}),"\n",(0,t.jsx)(n.p,{children:"Currently, name information is lost when using dynamic indexing. For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\n\nclass Foo extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Vec(4, Bool()))\n    val idx = Input(UInt(2.W))\n    val en = Input(Bool())\n    val out = Output(Bool())\n  })\n\n  val x = io.in(io.idx)\n  val y = x && io.en\n  io.out := y\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The above code loses the ",(0,t.jsx)(n.code,{children:"x"})," name, instead using ",(0,t.jsx)(n.code,{children:"_GEN_3"})," (the other ",(0,t.jsx)(n.code,{children:"_GEN_*"})," signals are expected)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.67.0\nmodule Foo(\t// cookbook.md:933:7\n  input        clock,\t// cookbook.md:933:7\n               reset,\t// cookbook.md:933:7\n               io_in_0,\t// cookbook.md:934:14\n               io_in_1,\t// cookbook.md:934:14\n               io_in_2,\t// cookbook.md:934:14\n               io_in_3,\t// cookbook.md:934:14\n  input  [1:0] io_idx,\t// cookbook.md:934:14\n  input        io_en,\t// cookbook.md:934:14\n  output       io_out\t// cookbook.md:934:14\n);\n\n  wire [3:0] _GEN = {{io_in_3}, {io_in_2}, {io_in_1}, {io_in_0}};\t// cookbook.md:942:13\n  assign io_out = _GEN[io_idx] & io_en;\t// cookbook.md:933:7, :942:13\nendmodule\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"This can be worked around by creating a wire and connecting the dynamic index to the wire:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val x = WireInit(io.in(io.idx))\n"})}),"\n",(0,t.jsx)(n.p,{children:"Which produces:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.67.0\nmodule Foo2(\t// cookbook.md:956:7\n  input        clock,\t// cookbook.md:956:7\n               reset,\t// cookbook.md:956:7\n               io_in_0,\t// cookbook.md:957:14\n               io_in_1,\t// cookbook.md:957:14\n               io_in_2,\t// cookbook.md:957:14\n               io_in_3,\t// cookbook.md:957:14\n  input  [1:0] io_idx,\t// cookbook.md:957:14\n  input        io_en,\t// cookbook.md:957:14\n  output       io_out\t// cookbook.md:957:14\n);\n\n  wire [3:0] _GEN = {{io_in_3}, {io_in_2}, {io_in_1}, {io_in_0}};\t// cookbook.md:964:19\n  assign io_out = _GEN[io_idx] & io_en;\t// cookbook.md:956:7, :964:19, :965:13\nendmodule\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"how-can-i-dynamically-setparametrize-the-name-of-a-module",children:"How can I dynamically set/parametrize the name of a module?"}),"\n",(0,t.jsxs)(n.p,{children:["You can override the ",(0,t.jsx)(n.code,{children:"desiredName"})," function. This works with normal Chisel modules and ",(0,t.jsx)(n.code,{children:"BlackBox"}),"es. Example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Coffee extends BlackBox {\n    val io = IO(new Bundle {\n        val I = Input(UInt(32.W))\n        val O = Output(UInt(32.W))\n    })\n    override def desiredName = "Tea"\n}\n\nclass Salt extends Module {\n    val io = IO(new Bundle {})\n    val drink = Module(new Coffee)\n    override def desiredName = "SodiumMonochloride"\n\n    drink.io.I := 42.U\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Elaborating the Chisel module ",(0,t.jsx)(n.code,{children:"Salt"}),' yields our "desired names" for ',(0,t.jsx)(n.code,{children:"Salt"})," and ",(0,t.jsx)(n.code,{children:"Coffee"})," in the output Verilog:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.67.0\n// external module Tea\n\nmodule SodiumMonochloride(\t// cookbook.md:994:7\n  input clock,\t// cookbook.md:994:7\n        reset\t// cookbook.md:994:7\n);\n\n  Tea drink (\t// cookbook.md:996:23\n    .I (32'h2A),\n    .O (/* unused */)\n  );\t// cookbook.md:996:23\nendmodule\n\n"})}),"\n",(0,t.jsx)(n.h2,{id:"directionality",children:"Directionality"}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-strip-directions-from-a-bidirectional-bundle-or-other-data",children:"How do I strip directions from a bidirectional Bundle (or other Data)?"}),"\n",(0,t.jsxs)(n.p,{children:["Given a bidirectional port like a ",(0,t.jsx)(n.code,{children:"Decoupled"}),", you will get an error if you try to connect it directly\nto a register:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nimport circt.stage.ChiselStage\nimport chisel3.util.Decoupled\nclass BadRegConnect extends Module {\n  val io = IO(new Bundle {\n    val enq = Decoupled(UInt(8.W))\n  })\n\n  val monitor = Reg(chiselTypeOf(io.enq))\n  monitor := io.enq\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"ChiselStage.emitSystemVerilog(new BadRegConnect)\n// circt.stage.phases.Exceptions$FirtoolNonZeroExitCode: /home/runner/.cache/llvm-firtool/1.67.0/bin/firtool returned a non-zero exit code. Note that this version of Chisel (7.0.0-M1+34-6dfc0470-SNAPSHOT) was published against firtool version 1.67.0.\n// ------------------------------------------------------------------------------\n// ExitCode:\n// 1\n// STDOUT:\n// \n// STDERR:\n// cookbook.md:1029:20: error: 'firrtl.reg' op result #0 must be a passive non-'const' base type that does not contain analog, but got '!firrtl.bundle<ready flip: uint<1>, valid: uint<1>, bits: uint<8>>'\n// cookbook.md:1029:20: note: see current operation: %4 = \"firrtl.reg\"(%arg0) {annotations = [], name = \"monitor\", nameKind = #firrtl<name_kind interesting_name>} : (!firrtl.clock) -> !firrtl.bundle<ready flip: uint<1>, valid: uint<1>, bits: uint<8>>\n// \n// ------------------------------------------------------------------------------\n"})}),"\n",(0,t.jsxs)(n.p,{children:['While there is no construct to "strip direction" in Chisel3, wrapping a type in ',(0,t.jsx)(n.code,{children:"Output(...)"}),"\n(the default direction in Chisel3) will\nset all of the individual elements to output direction.\nThis will have the desired result when used to construct a Register:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nimport circt.stage.ChiselStage\nimport chisel3.util.Decoupled\nclass CoercedRegConnect extends Module {\n  val io = IO(new Bundle {\n    val enq = Flipped(Decoupled(UInt(8.W)))\n  })\n\n  // Make a Reg which contains all of the bundle's signals, regardless of their directionality\n  val monitor = Reg(Output(chiselTypeOf(io.enq)))\n  // Even though io.enq is bidirectional, := will drive all fields of monitor with the fields of io.enq\n  monitor := io.enq\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},1871:(e,n,o)=>{o.d(n,{A:()=>l});o(6540);var t=o(5195);const a={tableOfContentsInline:"tableOfContentsInline_prmo"};var i=o(4848);function l(e){let{toc:n,minHeadingLevel:o,maxHeadingLevel:l}=e;return(0,i.jsx)("div",{className:a.tableOfContentsInline,children:(0,i.jsx)(t.A,{toc:n,minHeadingLevel:o,maxHeadingLevel:l,className:"table-of-contents",linkClassName:null})})}},5195:(e,n,o)=>{o.d(n,{A:()=>g});var t=o(6540),a=o(6342);function i(e){const n=e.map((e=>({...e,parentIndex:-1,children:[]}))),o=Array(7).fill(-1);n.forEach(((e,n)=>{const t=o.slice(2,e.level);e.parentIndex=Math.max(...t),o[e.level]=n}));const t=[];return n.forEach((e=>{const{parentIndex:o,...a}=e;o>=0?n[o].children.push(a):t.push(a)})),t}function l(e){let{toc:n,minHeadingLevel:o,maxHeadingLevel:t}=e;return n.flatMap((e=>{const n=l({toc:e.children,minHeadingLevel:o,maxHeadingLevel:t});return function(e){return e.level>=o&&e.level<=t}(e)?[{...e,children:n}]:n}))}function s(e){const n=e.getBoundingClientRect();return n.top===n.bottom?s(e.parentNode):n}function c(e,n){let{anchorTopOffset:o}=n;const t=e.find((e=>s(e).top>=o));if(t){return function(e){return e.top>0&&e.bottom<window.innerHeight/2}(s(t))?t:e[e.indexOf(t)-1]??null}return e[e.length-1]??null}function r(){const e=(0,t.useRef)(0),{navbar:{hideOnScroll:n}}=(0,a.p)();return(0,t.useEffect)((()=>{e.current=n?0:document.querySelector(".navbar").clientHeight}),[n]),e}function d(e){const n=(0,t.useRef)(void 0),o=r();(0,t.useEffect)((()=>{if(!e)return()=>{};const{linkClassName:t,linkActiveClassName:a,minHeadingLevel:i,maxHeadingLevel:l}=e;function s(){const e=function(e){return Array.from(document.getElementsByClassName(e))}(t),s=function(e){let{minHeadingLevel:n,maxHeadingLevel:o}=e;const t=[];for(let a=n;a<=o;a+=1)t.push(`h${a}.anchor`);return Array.from(document.querySelectorAll(t.join()))}({minHeadingLevel:i,maxHeadingLevel:l}),r=c(s,{anchorTopOffset:o.current}),d=e.find((e=>r&&r.id===function(e){return decodeURIComponent(e.href.substring(e.href.indexOf("#")+1))}(e)));e.forEach((e=>{!function(e,o){o?(n.current&&n.current!==e&&n.current.classList.remove(a),e.classList.add(a),n.current=e):e.classList.remove(a)}(e,e===d)}))}return document.addEventListener("scroll",s),document.addEventListener("resize",s),s(),()=>{document.removeEventListener("scroll",s),document.removeEventListener("resize",s)}}),[e,o])}var u=o(5489),h=o(4848);function p(e){let{toc:n,className:o,linkClassName:t,isChild:a}=e;return n.length?(0,h.jsx)("ul",{className:a?void 0:o,children:n.map((e=>(0,h.jsxs)("li",{children:[(0,h.jsx)(u.A,{to:`#${e.id}`,className:t??void 0,dangerouslySetInnerHTML:{__html:e.value}}),(0,h.jsx)(p,{isChild:!0,toc:e.children,className:o,linkClassName:t})]},e.id)))}):null}const m=t.memo(p);function g(e){let{toc:n,className:o="table-of-contents table-of-contents__left-border",linkClassName:s="table-of-contents__link",linkActiveClassName:c,minHeadingLevel:r,maxHeadingLevel:u,...p}=e;const g=(0,a.p)(),x=r??g.tableOfContents.minHeadingLevel,f=u??g.tableOfContents.maxHeadingLevel,w=function(e){let{toc:n,minHeadingLevel:o,maxHeadingLevel:a}=e;return(0,t.useMemo)((()=>l({toc:i(n),minHeadingLevel:o,maxHeadingLevel:a})),[n,o,a])}({toc:n,minHeadingLevel:x,maxHeadingLevel:f});return d((0,t.useMemo)((()=>{if(s&&c)return{linkClassName:s,linkActiveClassName:c,minHeadingLevel:x,maxHeadingLevel:f}}),[s,c,x,f])),(0,h.jsx)(m,{toc:w,className:o,linkClassName:s,...p})}},8453:(e,n,o)=>{o.d(n,{R:()=>l,x:()=>s});var t=o(6540);const a={},i=t.createContext(a);function l(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);