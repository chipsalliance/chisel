"use strict";(globalThis.webpackChunkchisel_lang=globalThis.webpackChunkchisel_lang||[]).push([[9920],{2437:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var t=i(4848),s=i(8453);const a={layout:"docs",title:"Combinational Circuits",section:"chisel3"},o="Combinational Circuits",r={id:"explanations/combinational-circuits",title:"Combinational Circuits",description:"A circuit is represented as a graph of nodes in Chisel.  Each node is",source:"@site/docs/explanations/combinational-circuits.md",sourceDirName:"explanations",slug:"/explanations/combinational-circuits",permalink:"/docs/explanations/combinational-circuits",draft:!1,unlisted:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/combinational-circuits.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Combinational Circuits",section:"chisel3"},sidebar:"chiselSidebar",previous:{title:"Chisel Type vs Scala Type",permalink:"/docs/explanations/chisel-type-vs-scala-type"},next:{title:"Connectable Operators",permalink:"/docs/explanations/connectable"}},c={},l=[{value:"Wires",id:"wires",level:3}];function d(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"combinational-circuits",children:"Combinational Circuits"})}),"\n",(0,t.jsx)(n.p,{children:"A circuit is represented as a graph of nodes in Chisel.  Each node is\na hardware operator that has zero or more inputs and that drives one\noutput.  A literal, introduced above, is a degenerate kind of node\nthat has no inputs and drives a constant value on its output.  One way\nto create and wire together nodes is using textual expressions.  For\nexample, we can express a simple combinational logic circuit\nusing the following expression:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"(a & b) | (~c & d)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The syntax should look familiar, with ",(0,t.jsx)(n.code,{children:"&"})," and ",(0,t.jsx)(n.code,{children:"|"}),"\nrepresenting bitwise-AND and -OR respectively, and ",(0,t.jsx)(n.code,{children:"~"}),"\nrepresenting bitwise-NOT.  The names ",(0,t.jsx)(n.code,{children:"a"})," through ",(0,t.jsx)(n.code,{children:"d"}),"\nrepresent named wires of some (unspecified) width."]}),"\n",(0,t.jsx)(n.p,{children:"Any simple expression can be converted directly into a circuit tree,\nwith named wires at the leaves and operators forming the internal\nnodes.  The final circuit output of the expression is taken from the\noperator at the root of the tree, in this example, the bitwise-OR."}),"\n",(0,t.jsx)(n.p,{children:"Simple expressions can build circuits in the shape of trees, but to\nconstruct circuits in the shape of arbitrary directed acyclic graphs\n(DAGs), we need to describe fan-out.  In Chisel, we do this by naming\na wire that holds a subexpression that we can then reference multiple\ntimes in subsequent expressions.  We name a wire in Chisel by\ndeclaring a variable.  For example, consider the select expression,\nwhich is used twice in the following multiplexer description:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val sel = a | b\nval out = (sel & in1) | (~sel & in0)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The keyword ",(0,t.jsx)(n.code,{children:"val"})," is part of Scala, and is used to name variables\nthat have values that won't change.  It is used here to name the\nChisel wire, ",(0,t.jsx)(n.code,{children:"sel"}),", holding the output of the first bitwise-OR\noperator so that the output can be used multiple times in the second\nexpression."]}),"\n",(0,t.jsx)(n.h3,{id:"wires",children:"Wires"}),"\n",(0,t.jsx)(n.p,{children:"Chisel also supports wires as hardware nodes to which one can assign values or connect other nodes."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val myNode = Wire(UInt(8.W))\nwhen (isReady) {\n  myNode := 255.U\n} .otherwise {\n  myNode := 0.U\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val myNode = Wire(UInt(8.W))\nwhen (input > 128.U) {\n  myNode := 255.U\n} .elsewhen (input > 64.U) {\n  myNode := 1.U\n} .otherwise {\n  myNode := 0.U\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Note that the last connection to a Wire takes effect. For example, the following two Chisel circuits are equivalent:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val myNode = Wire(UInt(8.W))\nmyNode := 10.U\nmyNode := 0.U\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val myNode = Wire(UInt(8.W))\nmyNode := 0.U\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var t=i(6540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);