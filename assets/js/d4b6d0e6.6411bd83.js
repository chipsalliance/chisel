"use strict";(globalThis.webpackChunkchisel_lang=globalThis.webpackChunkchisel_lang||[]).push([[4166],{5762(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>o,toc:()=>r});const o=JSON.parse('{"id":"explanations/connectable","title":"Connectable Operators","description":"Table of Contents","source":"@site/docs/explanations/connectable.md","sourceDirName":"explanations","slug":"/explanations/connectable","permalink":"/docs/explanations/connectable","draft":false,"unlisted":false,"editUrl":"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/connectable.md","tags":[],"version":"current","frontMatter":{"layout":"docs","title":"Connectable Operators","section":"chisel3"},"sidebar":"chiselSidebar","previous":{"title":"Combinational Circuits","permalink":"/docs/explanations/combinational-circuits"},"next":{"title":"Deep Dive into <> and := Connection Operators","permalink":"/docs/explanations/connection-operators"}}');var l=i(4848),t=i(8453);const c={layout:"docs",title:"Connectable Operators",section:"chisel3"},s=void 0,d={},r=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Overview",id:"overview",level:2},{value:"Alignment: Flipped vs Aligned",id:"alignment-flipped-vs-aligned",level:2},{value:"Input/Output",id:"inputoutput",level:2},{value:"Connecting components with fully aligned members",id:"connecting-components-with-fully-aligned-members",level:2},{value:"Mono-direction connection operator (:=)",id:"mono-direction-connection-operator-",level:3},{value:"Connecting components with mixed alignment members",id:"connecting-components-with-mixed-alignment-members",level:2},{value:"Bi-direction connection operator (<code>:&lt;&gt;=</code>)",id:"bi-direction-connection-operator-",level:3},{value:"Port-Direction Computation versus Connection-Direction Computation",id:"port-direction-computation-versus-connection-direction-computation",level:3},{value:"Aligned connection operator (<code>:&lt;=</code>)",id:"aligned-connection-operator-",level:3},{value:"Flipped connection operator (<code>:&gt;=</code>)",id:"flipped-connection-operator-",level:3},{value:"Coercing mono-direction connection operator (<code>:#=</code>)",id:"coercing-mono-direction-connection-operator-",level:3},{value:"Connectable",id:"connectable",level:2},{value:"Connecting Records",id:"connecting-records",level:3},{value:"Defaults with waived connections",id:"defaults-with-waived-connections",level:3},{value:"Connecting types with optional members",id:"connecting-types-with-optional-members",level:3},{value:"Always ignore errors caused by extra members (partial connection operator)",id:"always-ignore-errors-caused-by-extra-members-partial-connection-operator",level:3},{value:"Connecting components with different widths",id:"connecting-components-with-different-widths",level:3},{value:"Excluding members from any operator on a Connectable",id:"excluding-members-from-any-operator-on-a-connectable",level:3},{value:"Techniques for connecting structurally inequivalent Chisel types",id:"techniques-for-connecting-structurally-inequivalent-chisel-types",level:2},{value:"Connecting different sub-types of the same super-type, with colliding names",id:"connecting-different-sub-types-of-the-same-super-type-with-colliding-names",level:3},{value:"Connecting sub-types to super-types by waiving extra members",id:"connecting-sub-types-to-super-types-by-waiving-extra-members",level:3},{value:"Connecting different sub-types",id:"connecting-different-sub-types",level:3},{value:"FAQ",id:"faq",level:2},{value:"How do I connect two items as flexibly as possible (try your best but never error)",id:"how-do-i-connect-two-items-as-flexibly-as-possible-try-your-best-but-never-error",level:3},{value:"How do I connect two items but don&#39;t care about the Scala types being equivalent?",id:"how-do-i-connect-two-items-but-dont-care-about-the-scala-types-being-equivalent",level:3}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#terminology",children:"Terminology"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#alignment-flipped-vs-aligned",children:"Alignment: Flipped vs Aligned"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#inputoutput",children:"Input/Output"})}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"#connecting-components-with-fully-aligned-members",children:"Connecting components with fully aligned members"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsxs)(n.a,{href:"#mono-direction-connection-operator-",children:["Mono-direction connection operator (",(0,l.jsx)(n.code,{children:":="}),")"]})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"#connecting-components-with-mixed-alignment-members",children:"Connecting components with mixed alignment members"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsxs)(n.a,{href:"#bi-direction-connection-operator-",children:["Bi-direction connection operator (",(0,l.jsx)(n.code,{children:":<>="}),")"]})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#port-direction-computation-versus-connection-direction-computation",children:"Port-Direction Computation versus Connection-Direction Computation"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsxs)(n.a,{href:"#aligned-connection-operator-",children:["Aligned connection operator (",(0,l.jsx)(n.code,{children:":<="}),")"]})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsxs)(n.a,{href:"#flipped-connection-operator-",children:["Flipped connection operator (",(0,l.jsx)(n.code,{children:":>="}),")"]})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsxs)(n.a,{href:"#coercing-mono-direction-connection-operator-",children:["Coercing mono-direction connection operator (",(0,l.jsx)(n.code,{children:":#="}),")"]})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"#connectable",children:"Connectable"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#connecting-records",children:"Connecting Records"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#defaults-with-waived-connections",children:"Defaults with waived connections"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#connecting-types-with-optional-members",children:"Connecting types with optional members"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#always-ignore-errors-caused-by-extra-members-partial-connection-operator",children:"Always ignore extra members (partial connection operator)"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#connecting-components-with-different-widths",children:"Connecting components with different widths"})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"#techniques-for-connecting-structurally-inequivalent-chisel-types",children:"Techniques for connecting structurally inequivalent Chisel types"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#connecting-different-sub-types-of-the-same-super-type-with-colliding-names",children:"Connecting different sub-types of the same super-type, with colliding names"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#connecting-sub-types-to-super-types-by-waiving-extra-members",children:"Connecting sub-types to super-types by waiving extra members"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#connecting-different-sub-types",children:"Connecting different sub-types"})}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#faq",children:"FAQ"})}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:['"Chisel type" - a ',(0,l.jsx)(n.code,{children:"Data"})," that is not bound to hardware, i.e. not a component. (more details ",(0,l.jsx)(n.a,{href:"chisel-type-vs-scala-type",children:"here"}),").","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["E.g. ",(0,l.jsx)(n.code,{children:"UInt(3.W)"}),", ",(0,l.jsx)(n.code,{children:"new Bundle {..}"}),", ",(0,l.jsx)(n.code,{children:"Vec(3, SInt(2.W))"})," are all Chisel types"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:['"component" - a ',(0,l.jsx)(n.code,{children:"Data"})," that is bound to hardware (",(0,l.jsx)(n.code,{children:"IO"}),", ",(0,l.jsx)(n.code,{children:"Reg"}),", ",(0,l.jsx)(n.code,{children:"Wire"}),", etc.)","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["E.g. ",(0,l.jsx)(n.code,{children:"Wire(UInt(3.W))"})," is a component, whose Chisel type is ",(0,l.jsx)(n.code,{children:"UInt(3.W)"})]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Aggregate"})," - a Chisel type or component that contains other Chisel types or components (i.e. ",(0,l.jsx)(n.code,{children:"Vec"}),", ",(0,l.jsx)(n.code,{children:"Record"}),", or ",(0,l.jsx)(n.code,{children:"Bundle"}),")"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Element"})," - a Chisel type or component that does not contain other Chisel types or components (e.g. ",(0,l.jsx)(n.code,{children:"UInt"}),", ",(0,l.jsx)(n.code,{children:"SInt"}),", ",(0,l.jsx)(n.code,{children:"Clock"}),", ",(0,l.jsx)(n.code,{children:"Bool"})," etc.)"]}),"\n",(0,l.jsxs)(n.li,{children:['"member" - a Chisel type or component, or any of its children (could be an ',(0,l.jsx)(n.code,{children:"Aggregate"})," or an ",(0,l.jsx)(n.code,{children:"Element"}),")","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["E.g. ",(0,l.jsx)(n.code,{children:"Vec(3, UInt(2.W))(0)"})," is a member of the parent ",(0,l.jsx)(n.code,{children:"Vec"})," Chisel type"]}),"\n",(0,l.jsxs)(n.li,{children:["E.g. ",(0,l.jsx)(n.code,{children:"Wire(Vec(3, UInt(2.W)))(0)"})," is a member of the parent ",(0,l.jsx)(n.code,{children:"Wire"})," component"]}),"\n",(0,l.jsxs)(n.li,{children:["E.g. ",(0,l.jsx)(n.code,{children:"IO(Decoupled(Bool)).ready"})," is a member of the parent ",(0,l.jsx)(n.code,{children:"IO"})," component"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:['"relative alignment" - whether two members of the same component or Chisel type are aligned/flipped, relative to one another',"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["see section ",(0,l.jsx)(n.a,{href:"#alignment-flipped-vs-aligned",children:"below"})," for a detailed definition"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:['"structural type check" - Chisel type ',(0,l.jsx)(n.code,{children:"A"})," is structurally equivalent to Chisel type ",(0,l.jsx)(n.code,{children:"B"})," if ",(0,l.jsx)(n.code,{children:"A"})," and ",(0,l.jsx)(n.code,{children:"B"})," have matching bundle field names and types (",(0,l.jsx)(n.code,{children:"Record"})," vs ",(0,l.jsx)(n.code,{children:"Vector"})," vs ",(0,l.jsx)(n.code,{children:"Element"}),"), probe modifiers (probe vs nonprobe), vector sizes, ",(0,l.jsx)(n.code,{children:"Element"})," types (UInt/SInt/Bool/Clock)","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"ignores relative alignment (flippedness)"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:['"alignment type check" - a Chisel type ',(0,l.jsx)(n.code,{children:"A"})," matches alignment with another Chisel type ",(0,l.jsx)(n.code,{children:"B"})," if every member of ",(0,l.jsx)(n.code,{children:"A"}),"'s relative alignment to ",(0,l.jsx)(n.code,{children:"A"})," is the same as the structurally corresponding member of ",(0,l.jsx)(n.code,{children:"B"}),"'s relative alignment to ",(0,l.jsx)(n.code,{children:"B"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"Connectable"})," operators are the standard way to connect Chisel hardware components to one another."]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Note: For descriptions of the semantics for the previous operators, see ",(0,l.jsx)(n.a,{href:"connection-operators",children:(0,l.jsx)(n.code,{children:"Connection Operators"})}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"All connection operators require the two hardware components (consumer and producer) to be structurally type equivalent."}),"\n",(0,l.jsxs)(n.p,{children:["The one exception to the structural type-equivalence rule is using the ",(0,l.jsx)(n.code,{children:"Connectable"})," mechanism, detailed at this ",(0,l.jsx)(n.a,{href:"#techniques-for-connecting-structurally-inequivalent-chisel-types",children:"section"})," towards the end of this document."]}),"\n",(0,l.jsxs)(n.p,{children:["Aggregate (",(0,l.jsx)(n.code,{children:"Record"}),", ",(0,l.jsx)(n.code,{children:"Vec"}),", ",(0,l.jsx)(n.code,{children:"Bundle"}),") Chisel types can include data members which are flipped relative to one another.\nDue to this, there are many desired connection behaviors between two Chisel components.\nThe following are the Chisel connection operators between a consumer ",(0,l.jsx)(n.code,{children:"c"})," and producer ",(0,l.jsx)(n.code,{children:"p"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"c := p"})," (mono-direction): connects all ",(0,l.jsx)(n.code,{children:"p"})," members to ",(0,l.jsx)(n.code,{children:"c"}),"; requires ",(0,l.jsx)(n.code,{children:"c"})," and ",(0,l.jsx)(n.code,{children:"p"})," to not have any flipped members"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"c :#= p"})," (coercing mono-direction): connects all ",(0,l.jsx)(n.code,{children:"p"})," members to ",(0,l.jsx)(n.code,{children:"c"}),"; regardless of alignment"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"c :<= p"})," (aligned-direction): connects all aligned (non-flipped) ",(0,l.jsx)(n.code,{children:"c"})," members from ",(0,l.jsx)(n.code,{children:"p"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"c :>= p"})," (flipped-direction): connects all flipped ",(0,l.jsx)(n.code,{children:"p"})," members from ",(0,l.jsx)(n.code,{children:"c"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"c :<>= p"})," (bi-direction operator): connects all aligned ",(0,l.jsx)(n.code,{children:"c"})," members from ",(0,l.jsx)(n.code,{children:"p"}),"; all flipped ",(0,l.jsx)(n.code,{children:"p"})," members from ",(0,l.jsx)(n.code,{children:"c"})]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"These operators may appear to be a random collection of symbols; however, the characters are consistent between operators and self-describe the semantics of each operator:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:":"})," always indicates the consumer, or left-hand-side, of the operator."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"="})," always indicates the producer, or right-hand-side, of the operator.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Hence, ",(0,l.jsx)(n.code,{children:"c := p"})," connects a consumer (",(0,l.jsx)(n.code,{children:"c"}),") and a producer (",(0,l.jsx)(n.code,{children:"p"}),")."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"<"})," always indicates that some members will be driven producer-to-consumer, or right-to-left.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Hence, ",(0,l.jsx)(n.code,{children:"c :<= p"})," drives members in producer (",(0,l.jsx)(n.code,{children:"p"}),") to members in consumer (",(0,l.jsx)(n.code,{children:"c"}),")."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:">"})," always indicates that some signals will be driven consumer-to-producer, or left-to-right.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Hence, ",(0,l.jsx)(n.code,{children:"c :>= p"})," drives members in consumer (",(0,l.jsx)(n.code,{children:"c"}),") to members producer (",(0,l.jsx)(n.code,{children:"p"}),")."]}),"\n",(0,l.jsxs)(n.li,{children:["Hence, ",(0,l.jsx)(n.code,{children:"c :<>= p"})," both drives members from ",(0,l.jsx)(n.code,{children:"p"})," to ",(0,l.jsx)(n.code,{children:"c"})," and from ",(0,l.jsx)(n.code,{children:"c"})," to ",(0,l.jsx)(n.code,{children:"p"}),"."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"#"})," always indicates to ignore member alignment and to drive producer-to-consumer, or right-to-left.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Hence, ",(0,l.jsx)(n.code,{children:"c :#= p"})," always drives members from ",(0,l.jsx)(n.code,{children:"p"})," to ",(0,l.jsx)(n.code,{children:"c"})," ignoring direction."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Note: in addition, an operator that ends in ",(0,l.jsx)(n.code,{children:"="})," has assignment-precedence, which means that ",(0,l.jsx)(n.code,{children:"x :<>= y + z"})," will translate to ",(0,l.jsx)(n.code,{children:"x :<>= (y + z)"}),", rather than ",(0,l.jsx)(n.code,{children:"(x :<>= y) + z"}),".\nThis was not true of the ",(0,l.jsx)(n.code,{children:"<>"})," operator and was a minor painpoint for users."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"alignment-flipped-vs-aligned",children:"Alignment: Flipped vs Aligned"}),"\n",(0,l.jsxs)(n.p,{children:["A member's alignment is a relative property: a member is aligned/flipped relative to another member of the same component or Chisel type.\nHence, one must always say whether a member is flipped/aligned ",(0,l.jsx)(n.em,{children:"with respect to (w.r.t)"})," another member of that type (parent, sibling, child etc.)."]}),"\n",(0,l.jsxs)(n.p,{children:["We use the following example of a non-nested bundle ",(0,l.jsx)(n.code,{children:"Parent"})," to let us state all of the alignment relationships between members of ",(0,l.jsx)(n.code,{children:"p"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nclass Parent extends Bundle {\n  val alignedChild = UInt(32.W)\n  val flippedChild = Flipped(UInt(32.W))\n}\nclass MyModule0 extends Module {\n  val p = Wire(new Parent)\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"First, every member is always aligned with themselves:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"p"})," is aligned w.r.t ",(0,l.jsx)(n.code,{children:"p"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"p.alignedChild"})," is aligned w.r.t ",(0,l.jsx)(n.code,{children:"p.alignedChild"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"p.flippedChild"})," is aligned w.r.t ",(0,l.jsx)(n.code,{children:"p.flippedChild"})]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Next, we list all parent/child relationships.\nBecause the ",(0,l.jsx)(n.code,{children:"flippedChild"})," field is ",(0,l.jsx)(n.code,{children:"Flipped"}),", it changes its alignment relative to its parent."]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"p"})," is aligned w.r.t ",(0,l.jsx)(n.code,{children:"p.alignedChild"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"p"})," is flipped w.r.t ",(0,l.jsx)(n.code,{children:"p.flippedChild"})]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Finally, we can list all sibling relationships:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"p.alignedChild"})," is flipped w.r.t ",(0,l.jsx)(n.code,{children:"p.flippedChild"})]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["The next example has a nested bundle ",(0,l.jsx)(n.code,{children:"GrandParent"})," who instantiates an aligned ",(0,l.jsx)(n.code,{children:"Parent"})," field and flipped ",(0,l.jsx)(n.code,{children:"Parent"})," field."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nclass GrandParent extends Bundle {\n  val alignedParent = new Parent\n  val flippedParent = Flipped(new Parent)\n}\nclass MyModule1 extends Module {\n  val g = Wire(new GrandParent)\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Consider the following alignments between grandparent and grandchildren.\nAn odd number of flips indicate a flipped relationship; even numbers of flips indicate an aligned relationship."}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g"})," is aligned w.r.t ",(0,l.jsx)(n.code,{children:"g.flippedParent.flippedChild"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g"})," is aligned w.r.t ",(0,l.jsx)(n.code,{children:"g.alignedParent.alignedChild"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g"})," is flipped w.r.t ",(0,l.jsx)(n.code,{children:"g.flippedParent.alignedChild"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g"})," is flipped w.r.t ",(0,l.jsx)(n.code,{children:"g.alignedParent.flippedChild"})]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Consider the following alignment relationships starting from ",(0,l.jsx)(n.code,{children:"g.alignedParent"})," and ",(0,l.jsx)(n.code,{children:"g.flippedParent"}),".\n",(0,l.jsxs)(n.em,{children:["Note that whether ",(0,l.jsx)(n.code,{children:"g.alignedParent"})," is aligned/flipped relative to ",(0,l.jsx)(n.code,{children:"g"})," has no effect on the aligned/flipped relationship between ",(0,l.jsx)(n.code,{children:"g.alignedParent"})," and ",(0,l.jsx)(n.code,{children:"g.alignedParent.alignedChild"})," because alignment is only relative to the two members in question!"]}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g.alignedParent"})," is aligned w.r.t. ",(0,l.jsx)(n.code,{children:"g.alignedParent.alignedChild"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g.flippedParent"})," is aligned w.r.t. ",(0,l.jsx)(n.code,{children:"g.flippedParent.alignedChild"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g.alignedParent"})," is flipped w.r.t. ",(0,l.jsx)(n.code,{children:"g.alignedParent.flippedChild"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g.flippedParent"})," is flipped w.r.t. ",(0,l.jsx)(n.code,{children:"g.flippedParent.flippedChild"})]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["In summary, a member is aligned or flipped w.r.t. another member of the hardware component.\nThis means that the type of the consumer/producer is the only information needed to determine the behavior of any operator.\n",(0,l.jsx)(n.em,{children:"Whether the consumer/producer is a member of a larger bundle is irrelevant; you ONLY need to know the type of the consumer/producer"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"inputoutput",children:"Input/Output"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Input(gen)"}),"/",(0,l.jsx)(n.code,{children:"Output(gen)"})," are coercing operators.\nThey perform two functions: (1) create a new Chisel type that has all flips removed from all recursive children members (still structurally equivalent to ",(0,l.jsx)(n.code,{children:"gen"})," but no longer alignment type equivalent), and (2) apply ",(0,l.jsx)(n.code,{children:"Flipped"})," if ",(0,l.jsx)(n.code,{children:"Input"}),", keep aligned (do nothing) if ",(0,l.jsx)(n.code,{children:"Output"}),".\nE.g. if we imagine a function called ",(0,l.jsx)(n.code,{children:"cloneChiselTypeButStripAllFlips"}),", then ",(0,l.jsx)(n.code,{children:"Input(gen)"})," is structurally and alignment type equivalent to ",(0,l.jsx)(n.code,{children:"Flipped(cloneChiselTypeButStripAllFlips(gen))"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["Note that if ",(0,l.jsx)(n.code,{children:"gen"})," is a non-aggregate, then ",(0,l.jsx)(n.code,{children:"Input(nonAggregateGen)"})," is equivalent to ",(0,l.jsx)(n.code,{children:"Flipped(nonAggregateGen)"}),"."]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Future work will refactor how these primitives are exposed to the user to make Chisel's type system more intuitive.\nSee [",(0,l.jsx)(n.a,{href:"https://github.com/chipsalliance/chisel3/issues/2643",children:"https://github.com/chipsalliance/chisel3/issues/2643"}),"]."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"With this in mind, we can consider the following examples and detail relative alignments of members."}),"\n",(0,l.jsxs)(n.p,{children:["First, we can use a similar example to ",(0,l.jsx)(n.code,{children:"Parent"})," but use ",(0,l.jsx)(n.code,{children:"Input/Output"})," instead of ",(0,l.jsx)(n.code,{children:"Flipped"}),".\nBecause ",(0,l.jsx)(n.code,{children:"alignedChild"})," and ",(0,l.jsx)(n.code,{children:"flippedChild"})," are non-aggregates, ",(0,l.jsx)(n.code,{children:"Input"})," is basically just a ",(0,l.jsx)(n.code,{children:"Flipped"})," and thus the alignments are unchanged compared to the previous ",(0,l.jsx)(n.code,{children:"Parent"})," example."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nclass ParentWithOutputInput extends Bundle {\n  val alignedCoerced = Output(UInt(32.W)) // Equivalent to just UInt(32.W)\n  val flippedCoerced = Input(UInt(32.W))  // Equivalent to Flipped(UInt(32.W))\n}\nclass MyModule2 extends Module {\n  val p = Wire(new ParentWithOutputInput)\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["The alignments are the same as the previous ",(0,l.jsx)(n.code,{children:"Parent"})," example:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"p"})," is aligned w.r.t ",(0,l.jsx)(n.code,{children:"p"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"p.alignedCoerced"})," is aligned w.r.t ",(0,l.jsx)(n.code,{children:"p.alignedCoerced"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"p.flippedCoerced"})," is aligned w.r.t ",(0,l.jsx)(n.code,{children:"p.flippedCoerced"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"p"})," is aligned w.r.t ",(0,l.jsx)(n.code,{children:"p.alignedCoerced"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"p"})," is flipped w.r.t ",(0,l.jsx)(n.code,{children:"p.flippedCoerced"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"p.alignedCoerced"})," is flipped w.r.t ",(0,l.jsx)(n.code,{children:"p.flippedCoerced"})]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["The next example has a nested bundle ",(0,l.jsx)(n.code,{children:"GrandParent"})," who instantiates an ",(0,l.jsx)(n.code,{children:"Output"})," ",(0,l.jsx)(n.code,{children:"ParentWithOutputInput"})," field and an ",(0,l.jsx)(n.code,{children:"Input"})," ",(0,l.jsx)(n.code,{children:"ParentWithOutputInput"})," field."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nclass GrandParentWithOutputInput extends Bundle {\n  val alignedCoerced = Output(new ParentWithOutputInput)\n  val flippedCoerced = Input(new ParentWithOutputInput)\n}\nclass MyModule3 extends Module {\n  val g = Wire(new GrandParentWithOutputInput)\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Remember that ",(0,l.jsx)(n.code,{children:"Output(gen)/Input(gen)"})," recursively strips the ",(0,l.jsx)(n.code,{children:"Flipped"})," of any recursive children.\nThis makes every member of ",(0,l.jsx)(n.code,{children:"gen"})," aligned with every other member of ",(0,l.jsx)(n.code,{children:"gen"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["Consider the following alignments between grandparent and grandchildren.\nBecause ",(0,l.jsx)(n.code,{children:"alignedCoerced"})," and ",(0,l.jsx)(n.code,{children:"flippedCoerced"})," are aligned with all their recursive members, they are fully aligned.\nThus, only their alignment to ",(0,l.jsx)(n.code,{children:"g"})," influences grandchildren alignment:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g"})," is aligned w.r.t ",(0,l.jsx)(n.code,{children:"g.alignedCoerced.alignedCoerced"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g"})," is aligned w.r.t ",(0,l.jsx)(n.code,{children:"g.alignedCoerced.flippedCoerced"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g"})," is flipped w.r.t ",(0,l.jsx)(n.code,{children:"g.flippedCoerced.alignedCoerced"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g"})," is flipped w.r.t ",(0,l.jsx)(n.code,{children:"g.flippedCoerced.flippedCoerced"})]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Consider the following alignment relationships starting from ",(0,l.jsx)(n.code,{children:"g.alignedCoerced"})," and ",(0,l.jsx)(n.code,{children:"g.flippedCoerced"}),".\n",(0,l.jsxs)(n.em,{children:["Note that whether ",(0,l.jsx)(n.code,{children:"g.alignedCoerced"})," is aligned/flipped relative to ",(0,l.jsx)(n.code,{children:"g"})," has no effect on the aligned/flipped relationship between ",(0,l.jsx)(n.code,{children:"g.alignedCoerced"})," and ",(0,l.jsx)(n.code,{children:"g.alignedCoerced.alignedCoerced"})," or ",(0,l.jsx)(n.code,{children:"g.alignedCoerced.flippedCoerced"})," because alignment is only relative to the two members in question! However, because alignment is coerced, everything is aligned between ",(0,l.jsx)(n.code,{children:"g.alignedCoerced"}),"/",(0,l.jsx)(n.code,{children:"g.flippedAligned"})," and their children"]}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g.alignedCoerced"})," is aligned w.r.t. ",(0,l.jsx)(n.code,{children:"g.alignedCoerced.alignedCoerced"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g.alignedCoerced"})," is aligned w.r.t. ",(0,l.jsx)(n.code,{children:"g.alignedCoerced.flippedCoerced"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g.flippedCoerced"})," is aligned w.r.t. ",(0,l.jsx)(n.code,{children:"g.flippedCoerced.alignedCoerced"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g.flippedCoerced"})," is aligned w.r.t. ",(0,l.jsx)(n.code,{children:"g.flippedCoerced.flippedCoerced"})]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["In summary, ",(0,l.jsx)(n.code,{children:"Input(gen)"})," and ",(0,l.jsx)(n.code,{children:"Output(gen)"})," recursively coerce children alignment, as well as dictate ",(0,l.jsx)(n.code,{children:"gen"}),"'s alignment to its parent bundle (if it exists)."]}),"\n",(0,l.jsx)(n.h2,{id:"connecting-components-with-fully-aligned-members",children:"Connecting components with fully aligned members"}),"\n",(0,l.jsx)(n.h3,{id:"mono-direction-connection-operator-",children:"Mono-direction connection operator (:=)"}),"\n",(0,l.jsxs)(n.p,{children:["For simple connections where all members are aligned (non-flipped) w.r.t. one another, use ",(0,l.jsx)(n.code,{children:":="}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nclass FullyAlignedBundle extends Bundle {\n  val a = Bool()\n  val b = Bool()\n}\nclass Example0 extends RawModule {\n  val incoming = IO(Flipped(new FullyAlignedBundle))\n  val outgoing = IO(new FullyAlignedBundle)\n  outgoing := incoming\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where each member of ",(0,l.jsx)(n.code,{children:"incoming"})," drives every member of ",(0,l.jsx)(n.code,{children:"outgoing"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example0(\n  input  incoming_a,\n         incoming_b,\n  output outgoing_a,\n         outgoing_b\n);\n\n  assign outgoing_a = incoming_a;\n  assign outgoing_b = incoming_b;\nendmodule\n\n"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["You may be thinking \"Wait, I'm confused! Isn't ",(0,l.jsx)(n.code,{children:"incoming"})," flipped and ",(0,l.jsx)(n.code,{children:"outgoing"}),' aligned?" -- Noo! Whether ',(0,l.jsx)(n.code,{children:"incoming"})," is aligned with ",(0,l.jsx)(n.code,{children:"outgoing"})," makes no sense; remember, you only evaluate alignment between members of the same component or Chisel type.\nBecause components are always aligned to themselves, ",(0,l.jsx)(n.code,{children:"outgoing"})," is aligned to ",(0,l.jsx)(n.code,{children:"outgoing"}),", and ",(0,l.jsx)(n.code,{children:"incoming"})," is aligned to ",(0,l.jsx)(n.code,{children:"incoming"}),", there is no problem.\nTheir relative flippedness to anything else is irrelevant."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"connecting-components-with-mixed-alignment-members",children:"Connecting components with mixed alignment members"}),"\n",(0,l.jsxs)(n.p,{children:["Aggregate Chisel types can include data members which are flipped relative to one another; in the example below, ",(0,l.jsx)(n.code,{children:"alignedChild"})," and ",(0,l.jsx)(n.code,{children:"flippedChild"})," are aligned/flipped relative to ",(0,l.jsx)(n.code,{children:"MixedAlignmentBundle"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nclass MixedAlignmentBundle extends Bundle {\n  val alignedChild = Bool()\n  val flippedChild = Flipped(Bool())\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Due to this, there are many desired connection behaviors between two Chisel components.\nFirst we will introduce the most common Chisel connection operator, ",(0,l.jsx)(n.code,{children:":<>="}),", useful for connecting components with members of mixed-alignments, then take a moment to investigate a common source of confusion between port-direction and connection-direction.\nThen, we will explore the remainder of the Chisel connection operators."]}),"\n",(0,l.jsxs)(n.h3,{id:"bi-direction-connection-operator-",children:["Bi-direction connection operator (",(0,l.jsx)(n.code,{children:":<>="}),")"]}),"\n",(0,l.jsxs)(n.p,{children:["For connections where you want 'bulk-connect-like-semantics' where the aligned members are driven producer-to-consumer and flipped members are driven consumer-to-producer, use ",(0,l.jsx)(n.code,{children:":<>="}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class Example1 extends RawModule {\n  val incoming = IO(Flipped(new MixedAlignmentBundle))\n  val outgoing = IO(new MixedAlignmentBundle)\n  outgoing :<>= incoming\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where the aligned members are driven ",(0,l.jsx)(n.code,{children:"incoming"})," to ",(0,l.jsx)(n.code,{children:"outgoing"})," and flipped members are driven ",(0,l.jsx)(n.code,{children:"outgoing"})," to ",(0,l.jsx)(n.code,{children:"incoming"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example1(\n  input  incoming_alignedChild,\n  output incoming_flippedChild,\n         outgoing_alignedChild,\n  input  outgoing_flippedChild\n);\n\n  assign incoming_flippedChild = outgoing_flippedChild;\n  assign outgoing_alignedChild = incoming_alignedChild;\nendmodule\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"port-direction-computation-versus-connection-direction-computation",children:"Port-Direction Computation versus Connection-Direction Computation"}),"\n",(0,l.jsxs)(n.p,{children:["A common question is if you use a mixed-alignment connection (such as ",(0,l.jsx)(n.code,{children:":<>="}),") to connect submembers of parent components, does the alignment of the submember to their parent affect anything? The answer is no, because ",(0,l.jsx)(n.em,{children:"alignment is always computed relative to what is being connected to, and members are always aligned with themselves."})]}),"\n",(0,l.jsxs)(n.p,{children:["In the following example connecting from ",(0,l.jsx)(n.code,{children:"incoming.alignedChild"})," to ",(0,l.jsx)(n.code,{children:"outgoing.alignedChild"}),", whether ",(0,l.jsx)(n.code,{children:"incoming.alignedChild"})," is aligned with ",(0,l.jsx)(n.code,{children:"incoming"})," is irrelevant because the ",(0,l.jsx)(n.code,{children:":<>="})," only computes alignment relative to the thing being connected to, and ",(0,l.jsx)(n.code,{children:"incoming.alignedChild"})," is aligned with ",(0,l.jsx)(n.code,{children:"incoming.alignedChild"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class Example1a extends RawModule {\n  val incoming = IO(Flipped(new MixedAlignmentBundle))\n  val outgoing = IO(new MixedAlignmentBundle)\n  outgoing.alignedChild :<>= incoming.alignedChild // whether incoming.alignedChild is aligned/flipped to incoming is IRRELEVANT to what gets connected with :<>=\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["While ",(0,l.jsx)(n.code,{children:"incoming.flippedChild"}),"'s alignment with ",(0,l.jsx)(n.code,{children:"incoming"})," does not affect our operators, it does influence whether ",(0,l.jsx)(n.code,{children:"incoming.flippedChild"})," is an output or input port of my module.\nA common source of confusion is to mistake the process for determining whether ",(0,l.jsx)(n.code,{children:"incoming.flippedChild"})," will resolve to a Verilog ",(0,l.jsx)(n.code,{children:"output"}),"/",(0,l.jsx)(n.code,{children:"input"})," (the port-direction computation) with the process for determining how ",(0,l.jsx)(n.code,{children:":<>="})," drives what with what (the connection-direction computation).\nWhile both processes consider relative alignment, they are distinct."]}),"\n",(0,l.jsxs)(n.p,{children:["The port-direction computation always computes alignment relative to the component marked with ",(0,l.jsx)(n.code,{children:"IO"}),".\nAn ",(0,l.jsx)(n.code,{children:"IO(Flipped(gen))"})," is an incoming port, and any member of ",(0,l.jsx)(n.code,{children:"gen"})," that is aligned/flipped with ",(0,l.jsx)(n.code,{children:"gen"})," is an incoming/outgoing port.\nAn ",(0,l.jsx)(n.code,{children:"IO(gen)"})," is an outgoing port, and any member of ",(0,l.jsx)(n.code,{children:"gen"})," that is aligned/flipped with ",(0,l.jsx)(n.code,{children:"gen"})," is an outgoing/incoming port."]}),"\n",(0,l.jsxs)(n.p,{children:["The connection-direction computation always computes alignment based on the explicit consumer/producer referenced for the connection.\nIf one connects ",(0,l.jsx)(n.code,{children:"incoming :<>= outgoing"}),", alignments are computed based on ",(0,l.jsx)(n.code,{children:"incoming"})," and ",(0,l.jsx)(n.code,{children:"outgoing"}),".\nIf one connects ",(0,l.jsx)(n.code,{children:"incoming.alignedChild :<>= outgoing.alignedChild"}),", then alignments are computed based on ",(0,l.jsx)(n.code,{children:"incoming.alignedChild"})," and ",(0,l.jsx)(n.code,{children:"outgoing.alignedChild"})," (and the alignment of ",(0,l.jsx)(n.code,{children:"incoming"})," to ",(0,l.jsx)(n.code,{children:"incoming.alignedChild"})," is irrelevant)."]}),"\n",(0,l.jsxs)(n.p,{children:["This means that users can try to connect to input ports of their module! If I write ",(0,l.jsx)(n.code,{children:"x :<>= y"}),", and ",(0,l.jsx)(n.code,{children:"x"})," is an input to the current module, then that is what the connection is trying to do.\nHowever, because input ports are not drivable from within the current module, Chisel will throw an error.\nThis is the same error a user would get using a mono-directioned operator: ",(0,l.jsx)(n.code,{children:"x := y"})," will throw the same error if ",(0,l.jsx)(n.code,{children:"x"})," is an input to the current module.\n",(0,l.jsx)(n.em,{children:"Whether a component is drivable is irrelevant to the semantics of any connection operator attempting to drive to it."})]}),"\n",(0,l.jsxs)(n.p,{children:["In summary, the port-direction computation is relative to the root marked ",(0,l.jsx)(n.code,{children:"IO"}),", but connection-direction computation is relative to the consumer/producer that the connection is doing.\nThis has the positive property that connection semantics are solely based on the Chisel structural type and its relative alignments of the consumer/producer (nothing more, nothing less)."]}),"\n",(0,l.jsxs)(n.h3,{id:"aligned-connection-operator-",children:["Aligned connection operator (",(0,l.jsx)(n.code,{children:":<="}),")"]}),"\n",(0,l.jsxs)(n.p,{children:["For connections where you want the aligned-half of 'bulk-connect-like-semantics' where the aligned members are driven producer-to-consumer and flipped members are ignored, use ",(0,l.jsx)(n.code,{children:":<="}),' (the "aligned connection").']}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class Example2 extends RawModule {\n  val incoming = IO(Flipped(new MixedAlignmentBundle))\n  val outgoing = IO(new MixedAlignmentBundle)\n  incoming.flippedChild := DontCare // Otherwise FIRRTL throws an uninitialization error\n  outgoing :<= incoming\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where the aligned members are driven ",(0,l.jsx)(n.code,{children:"incoming"})," to ",(0,l.jsx)(n.code,{children:"outgoing"})," and flipped members are ignored:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example2(\n  input  incoming_alignedChild,\n  output incoming_flippedChild,\n         outgoing_alignedChild,\n  input  outgoing_flippedChild\n);\n\n  assign incoming_flippedChild = 1'h0;\n  assign outgoing_alignedChild = incoming_alignedChild;\nendmodule\n\n"})}),"\n",(0,l.jsxs)(n.h3,{id:"flipped-connection-operator-",children:["Flipped connection operator (",(0,l.jsx)(n.code,{children:":>="}),")"]}),"\n",(0,l.jsxs)(n.p,{children:["For connections where you want the flipped-half of 'bulk-connect-like-semantics' where the aligned members are ignored and flipped members are connected consumer-to-producer, use ",(0,l.jsx)(n.code,{children:":>="}),' (the "flipped connection", or "backpressure connection").']}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class Example3 extends RawModule {\n  val incoming = IO(Flipped(new MixedAlignmentBundle))\n  val outgoing = IO(new MixedAlignmentBundle)\n  outgoing.alignedChild := DontCare // Otherwise FIRRTL throws an uninitialization error\n  outgoing :>= incoming\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where the aligned members are ignored and the flipped members are driven ",(0,l.jsx)(n.code,{children:"outgoing"})," to ",(0,l.jsx)(n.code,{children:"incoming"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example3(\n  input  incoming_alignedChild,\n  output incoming_flippedChild,\n         outgoing_alignedChild,\n  input  outgoing_flippedChild\n);\n\n  assign incoming_flippedChild = outgoing_flippedChild;\n  assign outgoing_alignedChild = 1'h0;\nendmodule\n\n"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Note: Astute observers will realize that ",(0,l.jsx)(n.code,{children:"c :<>= p"})," is semantically equivalent to ",(0,l.jsx)(n.code,{children:"c :<= p"})," followed by ",(0,l.jsx)(n.code,{children:"c :>= p"}),"."]}),"\n"]}),"\n",(0,l.jsxs)(n.h3,{id:"coercing-mono-direction-connection-operator-",children:["Coercing mono-direction connection operator (",(0,l.jsx)(n.code,{children:":#="}),")"]}),"\n",(0,l.jsxs)(n.p,{children:["For connections where you want to every producer member to always drive every consumer member, regardless of alignment, use ",(0,l.jsx)(n.code,{children:":#="}),' (the "coercion connection").\nThis operator is useful for initializing wires whose types contain members of mixed alignment.']}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import chisel3.experimental.BundleLiterals._\nclass Example4 extends RawModule {\n  val w = Wire(new MixedAlignmentBundle)\n  dontTouch(w) // So we see it in the output Verilog\n  w :#= (new MixedAlignmentBundle).Lit(_.alignedChild -> true.B, _.flippedChild -> true.B)\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where all members are driven from the literal to ",(0,l.jsx)(n.code,{children:"w"}),", regardless of alignment:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example4();\n  wire w_flippedChild = 1'h1;\n  wire w_alignedChild = 1'h1;\nendmodule\n\n"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Note: Astute observers will realize that ",(0,l.jsx)(n.code,{children:"c :#= p"})," is semantically equivalent to ",(0,l.jsx)(n.code,{children:"c :<= p"})," followed by ",(0,l.jsx)(n.code,{children:"p :>= c"})," (note ",(0,l.jsx)(n.code,{children:"p"})," and ",(0,l.jsx)(n.code,{children:"c"})," switched places in the second connection)."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Another use case for ",(0,l.jsx)(n.code,{children:":#="})," is for connecting a mixed-directional bundle to a fully-aligned monitor."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import chisel3.experimental.BundleLiterals._\nclass Example4b extends RawModule {\n  val monitor = IO(Output(new MixedAlignmentBundle))\n  val w = Wire(new MixedAlignmentBundle)\n  dontTouch(w) // So we see it in the output Verilog\n  w :#= DontCare\n  monitor :#= w\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where all members are driven from the literal to ",(0,l.jsx)(n.code,{children:"w"}),", regardless of alignment:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example4b(\n  output monitor_alignedChild,\n         monitor_flippedChild\n);\n\n  wire w_flippedChild = 1'h0;\n  wire w_alignedChild = 1'h0;\n  assign monitor_alignedChild = w_alignedChild;\n  assign monitor_flippedChild = w_flippedChild;\nendmodule\n\n"})}),"\n",(0,l.jsx)(n.h2,{id:"connectable",children:"Connectable"}),"\n",(0,l.jsxs)(n.p,{children:["Sometimes a user wants to connect Chisel components which are not type equivalent.\nFor example, a user may want to hook up anonymous ",(0,l.jsx)(n.code,{children:"Record"})," components who may have an intersection of their fields being equivalent, but cannot because they are not structurally equivalent.\nAlternatively, one may want to connect two types that have different widths."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Connectable"})," is the mechanism to specialize connection operator behavior in these scenarios.\nFor additional members which are not present in the other component being connected to, or for mismatched widths, or for always excluding a member from being connected to, they can be explicitly called out from the ",(0,l.jsx)(n.code,{children:"Connectable"})," object, rather than trigger an error."]}),"\n",(0,l.jsxs)(n.p,{children:["In addition, there are other techniques that can be used to address similar use cases including ",(0,l.jsx)(n.code,{children:".viewAsSuperType"}),", a static cast to a supertype (e.g. ",(0,l.jsx)(n.code,{children:"(x: T)"}),"), or creating a custom ",(0,l.jsx)(n.code,{children:"DataView"}),".\nFor a discussion about when to use each technique, please continue ",(0,l.jsx)(n.a,{href:"#techniques-for-connecting-structurally-inequivalent-chisel-types",children:"here"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["This section demonstrates how ",(0,l.jsx)(n.code,{children:"Connectable"})," specifically can be used in a multitude of scenarios."]}),"\n",(0,l.jsx)(n.h3,{id:"connecting-records",children:"Connecting Records"}),"\n",(0,l.jsxs)(n.p,{children:["One use case is to try to connect two ",(0,l.jsx)(n.code,{children:"Record"}),"s; for matching members, they should be connected, but for unmatched members, the errors caused due to them being unmatched should be ignored.\nTo accomplish this, use the other operators to initialize all ",(0,l.jsx)(n.code,{children:"Record"})," members, then use ",(0,l.jsx)(n.code,{children:":<>="})," with ",(0,l.jsx)(n.code,{children:".waive"})," to connect only the matching members."]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Note that none of ",(0,l.jsx)(n.code,{children:".viewAsSuperType"}),", static casts, nor a custom ",(0,l.jsx)(n.code,{children:"DataView"})," helps this case because the Scala types are still ",(0,l.jsx)(n.code,{children:"Record"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:'import scala.collection.immutable.SeqMap\n\nclass Example9 extends RawModule {\n  val abType = new Record { val elements = SeqMap("a" -> Bool(), "b" -> Flipped(Bool())) }\n  val bcType = new Record { val elements = SeqMap("b" -> Flipped(Bool()), "c" -> Bool()) }\n\n  val p = IO(Flipped(abType))\n  val c = IO(bcType)\n\n  DontCare :>= p\n  c :<= DontCare\n\n  c.waive(_.elements("c")):<>= p.waive(_.elements("a"))\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where ",(0,l.jsx)(n.code,{children:"p.b"})," is driven from ",(0,l.jsx)(n.code,{children:"c.b"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example9(\n  output p_b,\n  input  p_a,\n  output c_c,\n  input  c_b\n);\n\n  assign p_b = c_b;\n  assign c_c = 1'h0;\nendmodule\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"defaults-with-waived-connections",children:"Defaults with waived connections"}),"\n",(0,l.jsxs)(n.p,{children:["Another use case is to try to connect two ",(0,l.jsx)(n.code,{children:"Record"}),"s; for matching members, they should be connected, but for unmatched members, ",(0,l.jsx)(n.em,{children:"they should be connected to a default value"}),".\nTo accomplish this, use the other operators to initialize all ",(0,l.jsx)(n.code,{children:"Record"})," members, then use ",(0,l.jsx)(n.code,{children:":<>="})," with ",(0,l.jsx)(n.code,{children:".waive"})," to connect only the matching members."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:'import scala.collection.immutable.SeqMap\n\nclass Example10 extends RawModule {\n  val abType = new Record { val elements = SeqMap("a" -> Bool(), "b" -> Flipped(Bool())) }\n  val bcType = new Record { val elements = SeqMap("b" -> Flipped(Bool()), "c" -> Bool()) }\n\n  val p = Wire(abType)\n  val c = Wire(bcType)\n\n  dontTouch(p) // So it doesn\'t get constant-propped away for the example\n  dontTouch(c) // So it doesn\'t get constant-propped away for the example\n\n  p :#= abType.Lit(_.elements("a") -> true.B, _.elements("b") -> true.B)\n  c :#= bcType.Lit(_.elements("b") -> true.B, _.elements("c") -> true.B)\n\n  c.waive(_.elements("c")) :<>= p.waive(_.elements("a"))\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where ",(0,l.jsx)(n.code,{children:"p.b"})," is driven from ",(0,l.jsx)(n.code,{children:"c.b"}),", and ",(0,l.jsx)(n.code,{children:"p.a"}),", ",(0,l.jsx)(n.code,{children:"c.b"}),", and ",(0,l.jsx)(n.code,{children:"c.c"})," are initialized to default values:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example10();\n  wire p_a = 1'h1;\n  wire c_b = 1'h1;\n  wire c_c = 1'h1;\n  wire p_b = c_b;\nendmodule\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"connecting-types-with-optional-members",children:"Connecting types with optional members"}),"\n",(0,l.jsxs)(n.p,{children:["In the following example, we can use ",(0,l.jsx)(n.code,{children:":<>="})," and ",(0,l.jsx)(n.code,{children:".waive"})," to connect two ",(0,l.jsx)(n.code,{children:"MyDecoupledOpts"}),"'s, where only one has a ",(0,l.jsx)(n.code,{children:"bits"})," member."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class MyDecoupledOpt(hasBits: Boolean) extends Bundle {\n  val valid = Bool()\n  val ready = Flipped(Bool())\n  val bits = if (hasBits) Some(UInt(32.W)) else None\n}\nclass Example6 extends RawModule {\n  val in  = IO(Flipped(new MyDecoupledOpt(true)))\n  val out = IO(new MyDecoupledOpt(false))\n  out :<>= in.waive(_.bits.get) // We can know to call .get because we can inspect in.bits.isEmpty\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where ",(0,l.jsx)(n.code,{children:"ready"})," and ",(0,l.jsx)(n.code,{children:"valid"})," are connected, and ",(0,l.jsx)(n.code,{children:"bits"})," is ignored:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example6(\n  input         in_valid,\n  output        in_ready,\n  input  [31:0] in_bits,\n  output        out_valid,\n  input         out_ready\n);\n\n  assign in_ready = out_ready;\n  assign out_valid = in_valid;\nendmodule\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"always-ignore-errors-caused-by-extra-members-partial-connection-operator",children:"Always ignore errors caused by extra members (partial connection operator)"}),"\n",(0,l.jsx)(n.p,{children:"The most unsafe connection is to connect only members that are present in both consumer and producer, and ignore all other members.\nThis is unsafe because this connection will never error on any Chisel types."}),"\n",(0,l.jsxs)(n.p,{children:["To do this, you can use ",(0,l.jsx)(n.code,{children:".waiveAll"})," and static cast to ",(0,l.jsx)(n.code,{children:"Data"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class OnlyA extends Bundle {\n  val a = UInt(32.W)\n}\nclass OnlyB extends Bundle {\n  val b = UInt(32.W)\n}\nclass Example11 extends RawModule {\n  val in  = IO(Flipped(new OnlyA))\n  val out = IO(new OnlyB)\n\n  out := DontCare\n\n  (out: Data).waiveAll :<>= (in: Data).waiveAll\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"This generates the following Verilog, where nothing is connected:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example11(\n  input  [31:0] in_a,\n  output [31:0] out_b\n);\n\n  assign out_b = 32'h0;\nendmodule\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"connecting-components-with-different-widths",children:"Connecting components with different widths"}),"\n",(0,l.jsxs)(n.p,{children:["Non-",(0,l.jsx)(n.code,{children:"Connectable"})," operators implicitly truncate if a component with a larger width is connected to a component with a smaller width.\n",(0,l.jsx)(n.code,{children:"Connectable"})," operators disallow this implicit truncation behavior and require the driven component to be equal or larger in width that the sourcing component."]}),"\n",(0,l.jsxs)(n.p,{children:["If implicit truncation behavior is desired, then ",(0,l.jsx)(n.code,{children:"Connectable"})," provides a ",(0,l.jsx)(n.code,{children:"squeeze"})," mechanism which will allow the connection to continue with implicit truncation."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import scala.collection.immutable.SeqMap\n\nclass Example14 extends RawModule {\n  val p = IO(Flipped(UInt(4.W)))\n  val c = IO(UInt(3.W))\n\n  c :<>= p.squeeze\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where ",(0,l.jsx)(n.code,{children:"p"})," is truncated prior to driving ",(0,l.jsx)(n.code,{children:"c"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example14(\n  input  [3:0] p,\n  output [2:0] c\n);\n\n  assign c = p[2:0];\nendmodule\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"excluding-members-from-any-operator-on-a-connectable",children:"Excluding members from any operator on a Connectable"}),"\n",(0,l.jsxs)(n.p,{children:["If a user wants to always exclude a field from a connect, use the ",(0,l.jsx)(n.code,{children:".exclude"})," mechanism which will never connect the field (as if it didn't exist to the connection)."]}),"\n",(0,l.jsxs)(n.p,{children:["Note that if a field matches in both producer and consumer, but only one is excluded, the other non-excluded field will still trigger an error; to fix this, use either ",(0,l.jsx)(n.code,{children:".waive"})," or ",(0,l.jsx)(n.code,{children:".exclude"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import scala.collection.immutable.SeqMap\n\nclass BundleWithSpecialField extends Bundle {\n  val foo = UInt(3.W)\n  val special = Bool()\n}\nclass Example15 extends RawModule {\n  val p = IO(Flipped(new BundleWithSpecialField()))\n  val c = IO(new BundleWithSpecialField())\n\n  c.special := true.B // must initialize it\n\n  c.exclude(_.special) :<>= p.exclude(_.special)\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where the ",(0,l.jsx)(n.code,{children:"special"})," field is not connected:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example15(\n  input  [2:0] p_foo,\n  input        p_special,\n  output [2:0] c_foo,\n  output       c_special\n);\n\n  assign c_foo = p_foo;\n  assign c_special = 1'h1;\nendmodule\n\n"})}),"\n",(0,l.jsx)(n.h2,{id:"techniques-for-connecting-structurally-inequivalent-chisel-types",children:"Techniques for connecting structurally inequivalent Chisel types"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"DataView"})," and ",(0,l.jsx)(n.code,{children:".viewAsSupertype"})," create a view of the component that has a different Chisel type.\nThis means that a user can first create a ",(0,l.jsx)(n.code,{children:"DataView"})," of the consumer or producer (or both) so that the Chisel types are structurally equivalent.\nThis is useful when the difference between the consumer and producer aren't super nested, and also if they have rich Scala types which encode their structure.\nIn general, ",(0,l.jsx)(n.code,{children:"DataView"})," is the preferred mechanism to use (if you can) because it maintains the most amount of Chisel information in the Scala type, but there are many instances where it doesn't work and thus one must fall back on ",(0,l.jsx)(n.code,{children:"Connectable"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Connectable"})," does not change the Chisel type, but instead changes the semantics of the operator to not error on the waived members if they are dangling or unconnected.\nThis is useful for when differences between the consumer and producer do not show up in the Scala type system (e.g. present/missing fields of type ",(0,l.jsx)(n.code,{children:"Option[Data]"}),", or anonymous ",(0,l.jsx)(n.code,{children:"Record"}),"s) or are deeply nested in a bundle that is especially onerous to create a ",(0,l.jsx)(n.code,{children:"DataView"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["Static casts (e.g. ",(0,l.jsx)(n.code,{children:"(x: T)"}),") allows connecting components that have different Scala types, but leaves the Chisel type unchanged.\nUse this to force a connection to occur, even if the Scala types are different."]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:'One may wonder why the operators require identical Scala types in the first place, if they can easily be bypassed.\nThe reason is to encourage users to use the Scala type system to encode Chisel information as it can make their code more robust; however, we don\'t want to be draconian about it because there are times when we want to enable the user to "just connect the darn thing".'}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"When all else fails one can always manually expand the connection to do what they want to happen, member by member.\nThe down-side to this approach is its verbosity and that adding new members to a component will require updating the manual connections."}),"\n",(0,l.jsxs)(n.p,{children:["Things to remember about ",(0,l.jsx)(n.code,{children:"Connectable"})," vs ",(0,l.jsx)(n.code,{children:".viewAsSupertype"}),"/",(0,l.jsx)(n.code,{children:"DataView"})," vs static cast (e.g. ",(0,l.jsx)(n.code,{children:"(x: T)"}),"):"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"DataView"})," and ",(0,l.jsx)(n.code,{children:".viewAsSupertype"})," will preemptively remove members that are not present in the new view which has a different Chisel type, thus ",(0,l.jsx)(n.code,{children:"DataView"})," ",(0,l.jsx)(n.em,{children:"does"})," affect what is connected"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Connectable"})," can be used to waive the error on members who end up being dangling or unconnected.\nImportantly, ",(0,l.jsx)(n.code,{children:"Connectable"})," waives ",(0,l.jsx)(n.em,{children:"do not"})," affect what is connected"]}),"\n",(0,l.jsxs)(n.li,{children:["Static cast does not remove extra members, thus a static cast ",(0,l.jsx)(n.em,{children:"does not"})," affect what is connected"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"connecting-different-sub-types-of-the-same-super-type-with-colliding-names",children:"Connecting different sub-types of the same super-type, with colliding names"}),"\n",(0,l.jsxs)(n.p,{children:["In these examples, we are connecting ",(0,l.jsx)(n.code,{children:"MyDecoupled"})," with ",(0,l.jsx)(n.code,{children:"MyDecoupledOtherBits"}),".\nBoth are subtypes of ",(0,l.jsx)(n.code,{children:"MyReadyValid"}),", and both have a ",(0,l.jsx)(n.code,{children:"bits"})," field of type ",(0,l.jsx)(n.code,{children:"UInt(32.W)"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["The first example will use ",(0,l.jsx)(n.code,{children:".viewAsSupertype"})," to connect them as ",(0,l.jsx)(n.code,{children:"MyReadyValid"}),".\nBecause it changes the Chisel type to omit both ",(0,l.jsx)(n.code,{children:"bits"})," fields, the ",(0,l.jsx)(n.code,{children:"bits"})," fields are unconnected."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import experimental.dataview._\nclass MyDecoupledOtherBits extends MyReadyValid {\n  val bits = UInt(32.W)\n}\nclass Example12 extends RawModule {\n  val in  = IO(Flipped(new MyDecoupled))\n  val out = IO(new MyDecoupledOtherBits)\n\n  out := DontCare\n\n  out.viewAsSupertype(new MyReadyValid) :<>= in.viewAsSupertype(new MyReadyValid)\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Note that the ",(0,l.jsx)(n.code,{children:"bits"})," fields are unconnected."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example12(\n  input         in_valid,\n  output        in_ready,\n  input  [31:0] in_bits,\n  output        out_valid,\n  input         out_ready,\n  output [31:0] out_bits\n);\n\n  assign in_ready = out_ready;\n  assign out_valid = in_valid;\n  assign out_bits = 32'h0;\nendmodule\n\n"})}),"\n",(0,l.jsxs)(n.p,{children:["The second example will use a static cast and ",(0,l.jsx)(n.code,{children:".waive(_.bits)"})," to connect them as ",(0,l.jsx)(n.code,{children:"MyReadyValid"}),".\nNote that because the static cast does not change the Chisel type, the connection finds that both consumer and producer have a ",(0,l.jsx)(n.code,{children:"bits"})," field.\nThis means that since they are structurally equivalent, they match and are connected.\nThe ",(0,l.jsx)(n.code,{children:"waive(_.bits)"})," does nothing, because the ",(0,l.jsx)(n.code,{children:"bits"})," are neither dangling nor unconnected."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import experimental.dataview._\nclass Example13 extends RawModule {\n  val in  = IO(Flipped(new MyDecoupled))\n  val out = IO(new MyDecoupledOtherBits)\n\n  out := DontCare\n\n  out.waiveAs[MyReadyValid](_.bits) :<>= in.waiveAs[MyReadyValid](_.bits)\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Note that the ",(0,l.jsx)(n.code,{children:"bits"})," fields ARE connected, even though they are waived, as ",(0,l.jsx)(n.code,{children:".waive"})," just changes whether an error should be thrown if they are missing, NOT to not connect them if they are structurally equivalent.\nTo always omit the connection, use ",(0,l.jsx)(n.code,{children:".exclude"})," on one side and either ",(0,l.jsx)(n.code,{children:".exclude"})," or ",(0,l.jsx)(n.code,{children:".waive"})," on the other side."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example13(\n  input         in_valid,\n  output        in_ready,\n  input  [31:0] in_bits,\n  output        out_valid,\n  input         out_ready,\n  output [31:0] out_bits\n);\n\n  assign in_ready = out_ready;\n  assign out_valid = in_valid;\n  assign out_bits = in_bits;\nendmodule\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"connecting-sub-types-to-super-types-by-waiving-extra-members",children:"Connecting sub-types to super-types by waiving extra members"}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Note that in this example, it would be better to use ",(0,l.jsx)(n.code,{children:".viewAsSupertype"}),"."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["In the following example, we can use ",(0,l.jsx)(n.code,{children:":<>="})," to connect a ",(0,l.jsx)(n.code,{children:"MyReadyValid"})," to a ",(0,l.jsx)(n.code,{children:"MyDecoupled"})," by waiving the ",(0,l.jsx)(n.code,{children:"bits"})," member."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class MyReadyValid extends Bundle {\n  val valid = Bool()\n  val ready = Flipped(Bool())\n}\nclass MyDecoupled extends MyReadyValid {\n  val bits = UInt(32.W)\n}\nclass Example5 extends RawModule {\n  val in  = IO(Flipped(new MyDecoupled))\n  val out = IO(new MyReadyValid)\n  out :<>= in.waiveAs[MyReadyValid](_.bits)\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where ",(0,l.jsx)(n.code,{children:"ready"})," and ",(0,l.jsx)(n.code,{children:"valid"})," are connected, and ",(0,l.jsx)(n.code,{children:"bits"})," is ignored:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example5(\n  input         in_valid,\n  output        in_ready,\n  input  [31:0] in_bits,\n  output        out_valid,\n  input         out_ready\n);\n\n  assign in_ready = out_ready;\n  assign out_valid = in_valid;\nendmodule\n\n"})}),"\n",(0,l.jsx)(n.h3,{id:"connecting-different-sub-types",children:"Connecting different sub-types"}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Note that in this example, it would be better to use ",(0,l.jsx)(n.code,{children:".viewAsSupertype"}),"."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Note that the connection operator requires the ",(0,l.jsx)(n.code,{children:"consumer"})," and ",(0,l.jsx)(n.code,{children:"producer"})," to be the same Scala type to encourage capturing more information statically, but they can always be cast to ",(0,l.jsx)(n.code,{children:"Data"})," or another common supertype prior to connecting."]}),"\n",(0,l.jsxs)(n.p,{children:["In the following example, we can use ",(0,l.jsx)(n.code,{children:":<>="})," and ",(0,l.jsx)(n.code,{children:".waiveAs"})," to connect two different sub-types of ",(0,l.jsx)(n.code,{children:"MyReadyValid"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class HasBits extends MyReadyValid {\n  val bits = UInt(32.W)\n}\nclass HasEcho extends MyReadyValid {\n  val echo = Flipped(UInt(32.W))\n}\nclass Example7 extends RawModule {\n  val in  = IO(Flipped(new HasBits))\n  val out = IO(new HasEcho)\n  out.waiveAs[MyReadyValid](_.echo) :<>= in.waiveAs[MyReadyValid](_.bits)\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This generates the following Verilog, where ",(0,l.jsx)(n.code,{children:"ready"})," and ",(0,l.jsx)(n.code,{children:"valid"})," are connected, and ",(0,l.jsx)(n.code,{children:"bits"})," and ",(0,l.jsx)(n.code,{children:"echo"})," are ignored:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.140.0\nmodule Example7(\n  input         in_valid,\n  output        in_ready,\n  input  [31:0] in_bits,\n  output        out_valid,\n  input         out_ready,\n  input  [31:0] out_echo\n);\n\n  assign in_ready = out_ready;\n  assign out_valid = in_valid;\nendmodule\n\n"})}),"\n",(0,l.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,l.jsx)(n.h3,{id:"how-do-i-connect-two-items-as-flexibly-as-possible-try-your-best-but-never-error",children:"How do I connect two items as flexibly as possible (try your best but never error)"}),"\n",(0,l.jsxs)(n.p,{children:["Use ",(0,l.jsx)(n.code,{children:".unsafe"})," (both waives and allows squeezing of all fields)."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class ExampleUnsafe extends RawModule {\n  val in  = IO(Flipped(new Bundle { val foo = Bool(); val bar = Bool() }))\n  val out = IO(new Bundle { val baz = Bool(); val bar = Bool() })\n  out.unsafe :<>= in.unsafe // bar is connected, and nothing errors\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"how-do-i-connect-two-items-but-dont-care-about-the-scala-types-being-equivalent",children:"How do I connect two items but don't care about the Scala types being equivalent?"}),"\n",(0,l.jsxs)(n.p,{children:["Use ",(0,l.jsx)(n.code,{children:".as"})," (upcasts the Scala type)."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class ExampleAs extends RawModule {\n  val in  = IO(Flipped(new Bundle { val foo = Bool(); val bar = Bool() }))\n  val out = IO(new Bundle { val foo = Bool(); val bar = Bool() })\n  // foo and bar are connected, although Scala types aren't the same\n  out.as[Data] :<>= in.as[Data]\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},8453(e,n,i){i.d(n,{R:()=>c,x:()=>s});var o=i(6540);const l={},t=o.createContext(l);function c(e){const n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:c(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);