"use strict";(self.webpackChunkchisel_lang=self.webpackChunkchisel_lang||[]).push([[5522],{6102:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>t,metadata:()=>c,toc:()=>u});var l=s(4848),a=s(8453);const t={layout:"docs",title:"Enumerations",section:"chisel3"},i="ChiselEnum",c={id:"explanations/chisel-enum",title:"Enumerations",description:"The ChiselEnum type can be used to reduce the chance of error when encoding mux selectors, opcodes, and functional unit operations.",source:"@site/docs/explanations/chisel-enum.md",sourceDirName:"explanations",slug:"/explanations/chisel-enum",permalink:"/docs/explanations/chisel-enum",draft:!1,unlisted:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/chisel-enum.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Enumerations",section:"chisel3"},sidebar:"chiselSidebar",previous:{title:"Bundles and Vecs",permalink:"/docs/explanations/bundles-and-vecs"},next:{title:"Chisel Type vs Scala Type",permalink:"/docs/explanations/chisel-type-vs-scala-type"}},o={},u=[{value:"Functionality and Examples",id:"functionality-and-examples",level:2},{value:"Casting",id:"casting",level:2},{value:"Testing",id:"testing",level:2},{value:"Workarounds",id:"workarounds",level:2},{value:"Additional Resources",id:"additional-resources",level:2}];function r(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"chiselenum",children:"ChiselEnum"})}),"\n",(0,l.jsxs)(n.p,{children:["The ChiselEnum type can be used to reduce the chance of error when encoding mux selectors, opcodes, and functional unit operations.\nIn contrast with ",(0,l.jsx)(n.code,{children:"Chisel.util.Enum"}),", ",(0,l.jsx)(n.code,{children:"ChiselEnum"})," are subclasses of ",(0,l.jsx)(n.code,{children:"Data"}),", which means that they can be used to define fields in ",(0,l.jsx)(n.code,{children:"Bundle"}),"s, including in ",(0,l.jsx)(n.code,{children:"IO"}),"s."]}),"\n",(0,l.jsx)(n.h2,{id:"functionality-and-examples",children:"Functionality and Examples"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"// Imports used in the following examples\nimport chisel3._\nimport chisel3.util._\n"})}),"\n",(0,l.jsx)(n.p,{children:"Below we see ChiselEnum being used as mux select for a RISC-V core. While wrapping the object in a package is not required, it is highly recommended as it allows for the type to be used in multiple files more easily."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"// package CPUTypes {\nobject AluMux1Sel extends ChiselEnum {\n  val selectRS1, selectPC = Value\n}\n// We can see the mapping by printing each Value\nAluMux1Sel.all.foreach(println)\n// AluMux1Sel(0=selectRS1)\n// AluMux1Sel(1=selectPC)\n"})}),"\n",(0,l.jsx)(n.p,{children:"Here we see a mux using the AluMux1Sel to select between different inputs."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import AluMux1Sel._\n\nclass AluMux1Bundle extends Bundle {\n  val aluMux1Sel = Input(AluMux1Sel())\n  val rs1Out     = Input(Bits(32.W))\n  val pcOut      = Input(Bits(32.W))\n  val aluMux1Out = Output(Bits(32.W))\n}\n\nclass AluMux1File extends Module {\n  val io = IO(new AluMux1Bundle)\n\n  // Default value for aluMux1Out\n  io.aluMux1Out := 0.U\n\n  switch (io.aluMux1Sel) {\n    is (selectRS1) {\n      io.aluMux1Out := io.rs1Out\n    }\n    is (selectPC) {\n      io.aluMux1Out := io.pcOut\n    }\n  }\n}\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.91.0\nmodule AluMux1File(\n  input         clock,\n                reset,\n                io_aluMux1Sel,\n  input  [31:0] io_rs1Out,\n                io_pcOut,\n  output [31:0] io_aluMux1Out\n);\n\n  assign io_aluMux1Out = io_aluMux1Sel ? io_pcOut : io_rs1Out;\nendmodule\n\n"})}),"\n",(0,l.jsxs)(n.p,{children:["ChiselEnum also allows for the user to directly set the Values by passing an ",(0,l.jsx)(n.code,{children:"UInt"})," to ",(0,l.jsx)(n.code,{children:"Value(...)"}),"\nas shown below. Note that the magnitude of each ",(0,l.jsx)(n.code,{children:"Value"})," must be strictly greater than the one before\nit."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:'object Opcode extends ChiselEnum {\n    val load  = Value(0x03.U) // i "load"  -> 000_0011\n    val imm   = Value(0x13.U) // i "imm"   -> 001_0011\n    val auipc = Value(0x17.U) // u "auipc" -> 001_0111\n    val store = Value(0x23.U) // s "store" -> 010_0011\n    val reg   = Value(0x33.U) // r "reg"   -> 011_0011\n    val lui   = Value(0x37.U) // u "lui"   -> 011_0111\n    val br    = Value(0x63.U) // b "br"    -> 110_0011\n    val jalr  = Value(0x67.U) // i "jalr"  -> 110_0111\n    val jal   = Value(0x6F.U) // j "jal"   -> 110_1111\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"The user can 'jump' to a value and continue incrementing by passing a start point then using a regular Value definition."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"object BranchFunct3 extends ChiselEnum {\n    val beq, bne = Value\n    val blt = Value(4.U)\n    val bge, bltu, bgeu = Value\n}\n// We can see the mapping by printing each Value\nBranchFunct3.all.foreach(println)\n// BranchFunct3(0=beq)\n// BranchFunct3(1=bne)\n// BranchFunct3(4=blt)\n// BranchFunct3(5=bge)\n// BranchFunct3(6=bltu)\n// BranchFunct3(7=bgeu)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"casting",children:"Casting"}),"\n",(0,l.jsxs)(n.p,{children:["You can cast an enum to a ",(0,l.jsx)(n.code,{children:"UInt"})," using ",(0,l.jsx)(n.code,{children:".asUInt"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class ToUInt extends RawModule {\n  val in = IO(Input(Opcode()))\n  val out = IO(Output(UInt(in.getWidth.W)))\n  out := in.asUInt\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["You can cast from a ",(0,l.jsx)(n.code,{children:"UInt"})," to an enum by passing the ",(0,l.jsx)(n.code,{children:"UInt"})," to the apply method of the ",(0,l.jsx)(n.code,{children:"ChiselEnum"})," object:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class FromUInt extends Module {\n  val in = IO(Input(UInt(7.W)))\n  val out = IO(Output(Opcode()))\n  out := Opcode(in)\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["However, if you cast from a ",(0,l.jsx)(n.code,{children:"UInt"})," to an Enum type when there are undefined states in the Enum values\nthat the ",(0,l.jsx)(n.code,{children:"UInt"})," could hit, you will see a warning like the following:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"[warn] chisel-enum.md 133:16: [W001] Casting non-literal UInt to repl.MdocSession$MdocApp$Opcode. You can use repl.MdocSession$MdocApp$Opcode.safe to cast without this warning.\n[warn] There were 1 warning(s) during hardware elaboration.\n"})}),"\n",(0,l.jsx)(n.p,{children:"(Note that the name of the Enum is ugly as an artifact of our documentation generation flow, it will\nbe cleaner in normal use)."}),"\n",(0,l.jsxs)(n.p,{children:["You can avoid this warning by using the ",(0,l.jsx)(n.code,{children:".safe"})," factory method which returns the cast Enum in addition\nto a ",(0,l.jsx)(n.code,{children:"Bool"})," indicating if the Enum is in a valid state:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:'class SafeFromUInt extends Module {\n  val in = IO(Input(UInt(7.W)))\n  val out = IO(Output(Opcode()))\n  val (value, valid) = Opcode.safe(in)\n  assert(valid, "Enum state must be valid, got %d!", in)\n  out := value\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"Now there will be no warning:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{})}),"\n",(0,l.jsxs)(n.p,{children:["You can also suppress the warning by using ",(0,l.jsx)(n.code,{children:"suppressEnumCastWarning"}),". This is\nprimarily used for casting from [[UInt]] to a Bundle type that contains an\nEnum, where the [[UInt]] is known to be valid for the Bundle type."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class MyBundle extends Bundle {\n  val addr = UInt(8.W)\n  val op = Opcode()\n}\n\nclass SuppressedFromUInt extends Module {\n  val in = IO(Input(UInt(15.W)))\n  val out = IO(Output(new MyBundle()))\n  suppressEnumCastWarning {\n    out := in.asTypeOf(new MyBundle)\n  }\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.em,{children:"Type"})," of the enums values is ",(0,l.jsx)(n.code,{children:"<ChiselEnum Object>.Type"})," which can be useful for passing the values\nas parameters to a function (or any other time a type annotation is needed).\nCalling ",(0,l.jsx)(n.code,{children:".litValue"})," on an enum value will return the integer value of that object as a\n",(0,l.jsx)(n.a,{href:"https://www.scala-lang.org/api/2.12.13/scala/math/BigInt.html",children:(0,l.jsx)(n.code,{children:"BigInt"})}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"def expectedSel(sel: AluMux1Sel.Type): Boolean = sel match {\n  case AluMux1Sel.selectRS1 => (sel.litValue == 0)\n  case AluMux1Sel.selectPC  => (sel.litValue == 1)\n  case _                    => false\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["The enum value type also defines some convenience methods for working with ",(0,l.jsx)(n.code,{children:"ChiselEnum"})," values. For example, continuing with the RISC-V opcode\nexample, one could easily create hardware signal that is only asserted on LOAD/STORE operations (when the enum value is equal to ",(0,l.jsx)(n.code,{children:"Opcode.load"}),"\nor ",(0,l.jsx)(n.code,{children:"Opcode.store"}),") using the ",(0,l.jsx)(n.code,{children:".isOneOf"})," method:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"class LoadStoreExample extends Module {\n  val io = IO(new Bundle {\n    val opcode = Input(Opcode())\n    val load_or_store = Output(Bool())\n  })\n  io.load_or_store := io.opcode.isOneOf(Opcode.load, Opcode.store)\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Some additional useful methods defined on the ",(0,l.jsx)(n.code,{children:"ChiselEnum"})," object are:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:".all"}),": returns the enum values within the enumeration"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:".getWidth"}),": returns the width of the hardware type"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"workarounds",children:"Workarounds"}),"\n",(0,l.jsxs)(n.p,{children:["As of Chisel v3.4.3 (1 July 2020), the width of the values is always inferred.\nTo work around this, you can add an extra ",(0,l.jsx)(n.code,{children:"Value"})," that forces the width that is desired.\nThis is shown in the example below, where we add a field ",(0,l.jsx)(n.code,{children:"ukn"})," to force the width to be 3 bits wide:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"object StoreFunct3 extends ChiselEnum {\n    val sb, sh, sw = Value\n    val ukn = Value(7.U)\n}\n// We can see the mapping by printing each Value\nStoreFunct3.all.foreach(println)\n// StoreFunct3(0=sb)\n// StoreFunct3(1=sh)\n// StoreFunct3(2=sw)\n// StoreFunct3(7=ukn)\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Signed values are not supported so if you want the value signed, you must cast the UInt with ",(0,l.jsx)(n.code,{children:".asSInt"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,l.jsxs)(n.p,{children:["The ChiselEnum type is much more powerful than stated above. It allows for Sequence, Vec, and Bundle assignments, as well as a ",(0,l.jsx)(n.code,{children:".next"})," operation to allow for stepping through sequential states and an ",(0,l.jsx)(n.code,{children:".isValid"})," for checking that a hardware value is a valid ",(0,l.jsx)(n.code,{children:"Value"}),". The source code for the ChiselEnum can be found ",(0,l.jsx)(n.a,{href:"https://github.com/chipsalliance/chisel3/blob/2a96767097264eade18ff26e1d8bce192383a190/core/src/main/scala/chisel3/StrongEnum.scala",children:"here"})," in the class ",(0,l.jsx)(n.code,{children:"EnumFactory"}),". Examples of the ChiselEnum operations can be found ",(0,l.jsx)(n.a,{href:"https://github.com/chipsalliance/chisel3/blob/dd6871b8b3f2619178c2a333d9d6083805d99e16/src/test/scala/chiselTests/StrongEnum.scala",children:"here"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(r,{...e})}):r(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>c});var l=s(6540);const a={},t=l.createContext(a);function i(e){const n=l.useContext(t);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),l.createElement(t.Provider,{value:n},e.children)}}}]);