"use strict";(globalThis.webpackChunkchisel_lang=globalThis.webpackChunkchisel_lang||[]).push([[6891],{6727(e,n,l){l.r(n),l.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>u,frontMatter:()=>d,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"explanations/moduleprefix","title":"Module Prefixing","description":"Chisel supports a feature called module prefixing.","source":"@site/docs/explanations/moduleprefix.md","sourceDirName":"explanations","slug":"/explanations/moduleprefix","permalink":"/docs/explanations/moduleprefix","draft":false,"unlisted":false,"editUrl":"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/moduleprefix.md","tags":[],"version":"current","frontMatter":{},"sidebar":"chiselSidebar","previous":{"title":"Memories","permalink":"/docs/explanations/memories"},"next":{"title":"Modules","permalink":"/docs/explanations/modules"}}');var s=l(4848),o=l(8453);const d={},r="Module Prefixing",a={},c=[{value:"withModulePrefix",id:"withmoduleprefix",level:2},{value:"localModulePrefix",id:"localmoduleprefix",level:2},{value:"Multiple Prefixes",id:"multiple-prefixes",level:2},{value:"Nested Prefixes",id:"nested-prefixes",level:2},{value:"Instantiate",id:"instantiate",level:2},{value:"noModulePrefix",id:"nomoduleprefix",level:2},{value:"External Modules",id:"external-modules",level:2}];function t(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"module-prefixing",children:"Module Prefixing"})}),"\n",(0,s.jsx)(n.p,{children:"Chisel supports a feature called module prefixing.\nModule prefixing allows you to create namespaces in the Verilog output of your design.\nThey are especially useful for when you want to name a particular subsystem of your design,\nand you want to make it easy to identify which subsystem a file belongs to by its name."}),"\n",(0,s.jsx)(n.h2,{id:"withmoduleprefix",children:"withModulePrefix"}),"\n",(0,s.jsxs)(n.p,{children:["We can open a module prefix block using ",(0,s.jsx)(n.code,{children:"withModulePrefix"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  withModulePrefix("Foo") {\n    // ...\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["All modules defined inside of this block, whether an immediate submodule or a descendent, will be given a prefix ",(0,s.jsx)(n.code,{children:"Foo"}),".\n(The prefix is separated by an underscore ",(0,s.jsx)(n.code,{children:"_"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"For example, suppose we write the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  val sub = withModulePrefix("Foo") {\n    Module(new Sub)\n  }\n}\n\nclass Sub extends Module {\n  // ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The result will be a design with two module definitions: ",(0,s.jsx)(n.code,{children:"Top"})," and ",(0,s.jsx)(n.code,{children:"Foo_Sub"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that the ",(0,s.jsx)(n.code,{children:"val sub ="})," part must be pulled outside of the ",(0,s.jsx)(n.code,{children:"withModulePrefix"})," block,\nor else the module will not be accessible to the rest of the ",(0,s.jsx)(n.code,{children:"Top"})," module."]}),"\n",(0,s.jsxs)(n.p,{children:["You can omit the prefix separator (",(0,s.jsx)(n.code,{children:"_"}),") by passing ",(0,s.jsx)(n.code,{children:"false"})," as the second argument:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  val sub = withModulePrefix("Foo", false) {\n    Module(new Sub)\n  }\n}\n\nclass Sub extends Module {\n  // ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This results in two module definitions: ",(0,s.jsx)(n.code,{children:"Top"})," and ",(0,s.jsx)(n.code,{children:"FooSub"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"localmoduleprefix",children:"localModulePrefix"}),"\n",(0,s.jsxs)(n.p,{children:["We can also set a module prefix on a module by overriding the ",(0,s.jsx)(n.code,{children:"localModulePrefix"})," method.\nThis is useful if you want to set a prefix for all instances of a module."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  override def localModulePrefix = Some("Foo")\n  val sub = Module(new Sub)\n}\n\nclass Sub extends Module {\n  // ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This results in two module definitions: ",(0,s.jsx)(n.code,{children:"Foo_Top"})," and ",(0,s.jsx)(n.code,{children:"Foo_Sub"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["You can also override ",(0,s.jsx)(n.code,{children:"localModulePrefixAppliesToSelf"})," to ",(0,s.jsx)(n.code,{children:"false"})," to only apply the prefix to the children."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  override def localModulePrefix = Some("Foo")\n  override def localModulePrefixAppliesToSelf = false\n  val sub = Module(new Sub)\n}\n\nclass Sub extends Module {\n  // ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This results in the two module definitions ",(0,s.jsx)(n.code,{children:"Top"})," and ",(0,s.jsx)(n.code,{children:"Foo_Sub"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["You can also override ",(0,s.jsx)(n.code,{children:"localModulePrefixUseSeparator"})," to ",(0,s.jsx)(n.code,{children:"false"})," to omit the separator."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  override def localModulePrefix = Some("Foo")\n  override def localModulePrefixUseSeparator = false\n  val sub = Module(new Sub)\n}\n\nclass Sub extends Module {\n  // ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This results in the two module definitions ",(0,s.jsx)(n.code,{children:"FooTop"})," and ",(0,s.jsx)(n.code,{children:"FooSub"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"multiple-prefixes",children:"Multiple Prefixes"}),"\n",(0,s.jsxs)(n.p,{children:["If a generator is run in multiple prefix blocks, the result is multiple identical copies of the module definition,\neach with its own distinct prefix.\nFor example, consider if we create two instances of ",(0,s.jsx)(n.code,{children:"Sub"})," above like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  val foo_sub = withModulePrefix("Foo") {\n    Module(new Sub)\n  }\n\n  val bar_sub = withModulePrefix("Bar") {\n    Module(new Sub)\n  }\n}\n\nclass Sub extends Module {\n  // ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Then, the resulting Verilog will have three module definitions: ",(0,s.jsx)(n.code,{children:"Top"}),", ",(0,s.jsx)(n.code,{children:"Foo_Sub"}),", and ",(0,s.jsx)(n.code,{children:"Bar_Sub"}),".\nBoth ",(0,s.jsx)(n.code,{children:"Foo_Sub"})," and ",(0,s.jsx)(n.code,{children:"Bar_Sub"})," will be identical to each other."]}),"\n",(0,s.jsx)(n.h2,{id:"nested-prefixes",children:"Nested Prefixes"}),"\n",(0,s.jsx)(n.p,{children:"Module prefixes can also be nested."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  val mid = withModulePrefix("Foo") {\n    Module(new Mid)\n  }\n}\n\nclass Mid extends Module {\n  // You can mix withModulePrefix and localModulePrefix.\n  override def localModulePrefix = Some("Bar")\n  override def localModulePrefixAppliesToSelf = false\n  val sub = Module(new Sub)\n}\n\nclass Sub extends Module {\n  // ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This results in three module definitions: ",(0,s.jsx)(n.code,{children:"Top"}),", ",(0,s.jsx)(n.code,{children:"Foo_Mid"}),", and ",(0,s.jsx)(n.code,{children:"Foo_Bar_Sub"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"instantiate",children:"Instantiate"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"withModulePrefix"})," blocks also work with the ",(0,s.jsx)(n.code,{children:"Instantiate"})," API."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.experimental.hierarchy.{instantiable, Instantiate}\n\n@instantiable\nclass Sub extends Module {\n  // ...\n}\n\nclass Top extends Module {\n  val foo_sub = withModulePrefix("Foo") {\n    Instantiate(new Sub)\n  }\n\n  val bar_sub = withModulePrefix("Bar") {\n    Instantiate(new Sub)\n  }\n\n  val noprefix_sub = Instantiate(new Sub)\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, we end up with four modules: ",(0,s.jsx)(n.code,{children:"Top"}),", ",(0,s.jsx)(n.code,{children:"Foo_Sub"}),", ",(0,s.jsx)(n.code,{children:"Bar_Sub"}),", and ",(0,s.jsx)(n.code,{children:"Sub"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When using ",(0,s.jsx)(n.code,{children:"Definition"})," and ",(0,s.jsx)(n.code,{children:"Instance"}),", all ",(0,s.jsx)(n.code,{children:"Definition"})," calls will be affected by ",(0,s.jsx)(n.code,{children:"withModulePrefix"}),".\nHowever, ",(0,s.jsx)(n.code,{children:"Instance"})," will not be effected, since it always creates an instance of the captured definition."]}),"\n",(0,s.jsx)(n.h2,{id:"nomoduleprefix",children:"noModulePrefix"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"noModulePrefix"})," to instantiate a module without any prefixing from parent scopes applied."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  withModulePrefix("Foo") {\n    noModulePrefix {\n      Module(new ChildA)\n    }\n    Module(new ChildB)\n  }\n}\n\nclass ChildA extends Module {\n  // ..\n}\n\nclass ChildB extends Module {\n  // ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This results in the module definitions: ",(0,s.jsx)(n.code,{children:"ChildA"})," and ",(0,s.jsx)(n.code,{children:"Foo_ChildB"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"noModulePrefix"})," clears all nested prefixes above the current scope, but nested ",(0,s.jsx)(n.code,{children:"withModulePrefix"}),"s will still apply."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\n\nclass Top extends Module {\n  val sub = withModulePrefix("Foo") {\n    noModulePrefix {\n      withModulePrefix("Bar") {\n        Module(new Child)\n      }\n    }\n  }\n}\n\nclass Child extends Module {\n  // ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This results in the definition ",(0,s.jsx)(n.code,{children:"Bar_Child"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"external-modules",children:"External Modules"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"BlackBox"})," and ",(0,s.jsx)(n.code,{children:"ExtModule"})," are unaffected by ",(0,s.jsx)(n.code,{children:"withModulePrefix"}),".\nIf you wish to have one that is sensitive to the module prefix,\nyou can explicitly name the module like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.experimental.hierarchy.{instantiable, Instantiate}\n\nclass Sub extends ExtModule {\n  override def desiredName = modulePrefix + "Sub"\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}},8453(e,n,l){l.d(n,{R:()=>d,x:()=>r});var i=l(6540);const s={},o=i.createContext(s);function d(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);