"use strict";(globalThis.webpackChunkchisel_lang=globalThis.webpackChunkchisel_lang||[]).push([[9942],{9890(e,i,t){t.r(i),t.d(i,{assets:()=>r,contentTitle:()=>a,default:()=>d,frontMatter:()=>l,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"appendix/migrating-from-chiseltest","title":"Migrating from ChiselTest","description":"Background","source":"@site/docs/appendix/migrating-from-chiseltest.md","sourceDirName":"appendix","slug":"/appendix/migrating-from-chiseltest","permalink":"/docs/appendix/migrating-from-chiseltest","draft":false,"unlisted":false,"editUrl":"https://github.com/chipsalliance/chisel/tree/main/docs/src/appendix/migrating-from-chiseltest.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"title":"Migrating from ChiselTest","sidebar_position":0},"sidebar":"chiselSidebar","previous":{"title":"Appendix","permalink":"/docs/appendix"},"next":{"title":"Experimental Features","permalink":"/docs/appendix/experimental-features"}}');var s=t(4848),o=t(8453);const l={title:"Migrating from ChiselTest",sidebar_position:0},a="Migrating from ChiselTest to ChiselSim",r={},c=[{value:"Background",id:"background",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Migration",id:"migration",level:2}];function h(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"migrating-from-chiseltest-to-chiselsim",children:"Migrating from ChiselTest to ChiselSim"})}),"\n",(0,s.jsx)(i.h2,{id:"background",children:"Background"}),"\n",(0,s.jsxs)(i.p,{children:["With the release of Chisel 5, Chisel moved off of the legacy ",(0,s.jsx)(i.a,{href:"https://github.com/chipsalliance/firrtl",children:"Scala FIRRTL Compiler (SFC)"})," to the MLIR FIRRTL Compiler (MFC), part of the ",(0,s.jsx)(i.a,{href:"https://github.com/llvm/circt",children:"llvm/circt"})," project.\nAfter this release, the Scala FIRRTL Compiler was no longer maintained.\nThis change in underlying compiler technology has been a crucial piece in enabling the addition of many new features to Chisel, including linear-temporal logic (LTL) properties, Probes, and Layers.\nUnfortunately, Chisel 3's testing library, ",(0,s.jsx)(i.a,{href:"https://github.com/ucb-bar/chiseltest",children:"ChiselTest"}),", is built around the SFC, making it difficult to support ChiselTest in Chisel 5 and beyond.\n",(0,s.jsx)(i.em,{children:"ChiselTest is not used or maintained by the core Chisel development team or their employers."})]}),"\n",(0,s.jsx)(i.p,{children:"ChiselSim is the approved replacement for ChiselTest in Chisel 5 and beyond.\nChiselSim is maintained and used by the core Chisel development team.\nThis page describes how to migrate from ChiselTest to ChiselSim."}),"\n",(0,s.jsx)(i.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,s.jsx)(i.p,{children:"The developers of ChiselTest have maintained some amount of compatibility between ChiselTest and newer versions of Chisel.\nThis relies on a forked version of the SFC.\nUse of ChiselTest with Chisel 6 or later will prevent the usage of new Chisel 6 features.\nIt is not expected that new versions of Chisel will be compatible with the SFC."}),"\n",(0,s.jsx)(i.p,{children:"We recommend using the latest minor version of Chisel 5 and ChiselTest 5 for migrating. At the time of writing this is Chisel v5.1.0 and ChiselTest v5.0.2, but please check for later versions."}),"\n",(0,s.jsx)(i.admonition,{type:"note",children:(0,s.jsxs)(i.p,{children:["The ChiselSim APIs have changed since this migration guide was written.\nOn Chisel 7 or later, you should use newer APIs described in ",(0,s.jsx)(i.a,{href:"../explanations/testing",children:"the testing explanation"}),".\nIt may still be useful to use the Chisel 5 APIs for ChiselSim as part of your migration."]})}),"\n",(0,s.jsx)(i.h2,{id:"migration",children:"Migration"}),"\n",(0,s.jsxs)(i.p,{children:["ChiselSim provides a minimal ",(0,s.jsx)(i.code,{children:"peek"}),", ",(0,s.jsx)(i.code,{children:"poke"}),", ",(0,s.jsx)(i.code,{children:"expect"}),", and ",(0,s.jsx)(i.code,{children:"step"})," API, similar to that of ChiselTest.\nYou use ChiselSim by importing it ",(0,s.jsx)(i.code,{children:"import chisel3.simulator.EphemeralSimulator._"}),", and using its ",(0,s.jsx)(i.code,{children:"simulate"})," method which is similar to ChiselTest's ",(0,s.jsx)(i.code,{children:"test"}),".\nAt present, it does not have any integration with ScalaTest, so users should use any ScalaTest APIs directly."]}),"\n",(0,s.jsxs)(i.p,{children:["For example, given a simple design (typically in ",(0,s.jsx)(i.code,{children:"src/main/scala"}),"):"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:"import chisel3._\nclass MyModule extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n\n  io.out := RegNext(io.in)\n}\n"})}),"\n",(0,s.jsxs)(i.p,{children:["The legacy ChiselTest way to test this would be with a ",(0,s.jsx)(i.code,{children:"ChiselScalatestTester"})," in ",(0,s.jsx)(i.code,{children:"src/test/scala"}),":"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:'import chisel3._\nimport chiseltest._\nimport org.scalatest.flatspec.AnyFlatSpec\n\nclass MyModuleSpec extends AnyFlatSpec with ChiselScalatestTester {\n  behavior of "MyModule"\n  it should "do something" in {\n    test(new MyModule) { c =>\n      c.io.in.poke(0.U)\n      c.clock.step()\n      c.io.out.expect(0.U)\n      c.io.in.poke(42.U)\n      c.clock.step()\n      c.io.out.expect(42.U)\n      println("Last output value : " + c.io.out.peek().litValue)\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(i.p,{children:"This can be rewritten using ChiselSim as follows:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.simulator.EphemeralSimulator._\nimport org.scalatest.flatspec.AnyFlatSpec\n\nclass MyModuleSpec extends AnyFlatSpec {\n  behavior of "MyModule"\n  it should "do something" in {\n    simulate(new MyModule) { c =>\n      c.io.in.poke(0.U)\n      c.clock.step()\n      c.io.out.expect(0.U)\n      c.io.in.poke(42.U)\n      c.clock.step()\n      c.io.out.expect(42.U)\n      println("Last output value : " + c.io.out.peek().litValue)\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(i.p,{children:["For both ChiselTest and ChiselSim, you will typically run this with ",(0,s.jsx)(i.code,{children:"sbt test"})," or some way of running tests.\nThe output from ChiselSim will look something like the following:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:'// This is how one can run a ScalaTest Spec manually, typically one would use "sbt test"\norg.scalatest.nocolor.run(new MyModuleSpec)\n'})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"Last output value : 42\nMdocSession$MdocApp$MyModuleSpec:\nMyModule\n- should do something\n\n"})}),"\n",(0,s.jsxs)(i.p,{children:["ChiselSim also does not currently have any support for ",(0,s.jsx)(i.code,{children:"fork"}),"-",(0,s.jsx)(i.code,{children:"join"}),", so any tests using those constructs will need to be rewritten in a single-threaded manner."]})]})}function d(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453(e,i,t){t.d(i,{R:()=>l,x:()=>a});var n=t(6540);const s={},o=n.createContext(s);function l(e){const i=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),n.createElement(o.Provider,{value:i},e.children)}}}]);