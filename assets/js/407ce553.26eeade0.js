"use strict";(globalThis.webpackChunkchisel_lang=globalThis.webpackChunkchisel_lang||[]).push([[7315],{7813(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"explanations/properties","title":"Properties","description":"Chisel properties represent information about the design that is not hardware.","source":"@site/docs/explanations/properties.md","sourceDirName":"explanations","slug":"/explanations/properties","permalink":"/docs/explanations/properties","draft":false,"unlisted":false,"editUrl":"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/properties.md","tags":[],"version":"current","frontMatter":{"layout":"docs","title":"Properties","section":"chisel3"},"sidebar":"chiselSidebar","previous":{"title":"Probes","permalink":"/docs/explanations/probes"},"next":{"title":"Reset","permalink":"/docs/explanations/reset"}}');var s=t(4848),i=t(8453);const o={layout:"docs",title:"Properties",section:"chisel3"},c="Properties",d={},a=[{value:"Property Types",id:"property-types",level:2},{value:"Using Properties",id:"using-properties",level:2},{value:"Property Ports",id:"property-ports",level:3},{value:"Property Connections",id:"property-connections",level:3},{value:"Property Values",id:"property-values",level:3},{value:"Property Sequences",id:"property-sequences",level:3},{value:"Property Expressions",id:"property-expressions",level:3},{value:"Integer Arithmetic",id:"integer-arithmetic",level:4},{value:"Sequence Operations",id:"sequence-operations",level:4},{value:"Classes and Objects",id:"classes-and-objects",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"properties",children:"Properties"})}),"\n",(0,s.jsxs)(n.p,{children:["Chisel ",(0,s.jsx)(n.em,{children:"properties"})," represent information about the design that is not hardware.\nThis is useful to capture domain-specific knowledge and design intent alongside\nthe hardware description within the same generator."]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"Properties are under active development and are not yet considered stable."})}),"\n",(0,s.jsx)(n.h2,{id:"property-types",children:"Property Types"}),"\n",(0,s.jsxs)(n.p,{children:["The core primitive for using properties is the ",(0,s.jsx)(n.code,{children:"Property"})," type."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Property"})," types work similarly to the other Chisel\n",(0,s.jsx)(n.a,{href:"../explanations/data-types",children:"Data Types"}),", but rather than specifying the type of\nvalues held in state elements or flowing through wires in the circuit,\nproperties never flow through or affect the generated hardware. Instead, they\nflow through the hierarchy as ports that can be connected."]}),"\n",(0,s.jsxs)(n.p,{children:["What makes ",(0,s.jsx)(n.code,{children:"Property"})," types useful is their ability to express non-hardware\ninformation that is present in the generated hierarchy, and can be composed to\ncreate domain-specific data models that are tightly coupled to the design. An\ninput port with ",(0,s.jsx)(n.code,{children:"Property"})," type represents a part of the data model that must be\nsupplied when its module is instantiated. An output port with ",(0,s.jsx)(n.code,{children:"Property"})," type\nrepresents a part of the data model that may be accessed when its module is\ninstantiated. As the complete design is generated, an arbitrary data model can\nbe generated alongside it."]}),"\n",(0,s.jsxs)(n.p,{children:["The following are legal ",(0,s.jsx)(n.code,{children:"Property"})," types:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Property[Int]"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Property[Long]"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Property[BigInt]"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Property[String]"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Property[Boolean]"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Property[Seq[A]]"})," (where ",(0,s.jsx)(n.code,{children:"A"})," is itself a ",(0,s.jsx)(n.code,{children:"Property"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"using-properties",children:"Using Properties"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Property"})," functionality can be used with the following imports:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nimport chisel3.properties.Property\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The subsections below show example uses of ",(0,s.jsx)(n.code,{children:"Property"})," types in various Chisel\nconstructs."]}),"\n",(0,s.jsx)(n.h3,{id:"property-ports",children:"Property Ports"}),"\n",(0,s.jsxs)(n.p,{children:["The legal ",(0,s.jsx)(n.code,{children:"Property"})," types may be used in ports. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"class PortsExample extends RawModule {\n  // An Int Property type port.\n  val myPort = IO(Input(Property[Int]()))\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"property-connections",children:"Property Connections"}),"\n",(0,s.jsxs)(n.p,{children:["The legal ",(0,s.jsx)(n.code,{children:"Property"})," types may be connected using the ",(0,s.jsx)(n.code,{children:":="})," operator. For\nexample, an input ",(0,s.jsx)(n.code,{children:"Property"})," type port may be connected to an output ",(0,s.jsx)(n.code,{children:"Property"}),"\ntype port:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"class ConnectExample extends RawModule {\n  val inPort = IO(Input(Property[Int]()))\n  val outPort = IO(Output(Property[Int]()))\n  outPort := inPort\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Connections are only supported between the same ",(0,s.jsx)(n.code,{children:"Property"})," type. For example, a\n",(0,s.jsx)(n.code,{children:"Property[Int]"})," may only be connected to a ",(0,s.jsx)(n.code,{children:"Property[Int]"}),". This is enforced by\nthe Scala compiler."]}),"\n",(0,s.jsx)(n.h3,{id:"property-values",children:"Property Values"}),"\n",(0,s.jsxs)(n.p,{children:["The legal ",(0,s.jsx)(n.code,{children:"Property"})," types may be used to construct values by applying the\n",(0,s.jsx)(n.code,{children:"Property"})," object to a value of the ",(0,s.jsx)(n.code,{children:"Property"})," type. For example, a\n",(0,s.jsx)(n.code,{children:"Property"})," value may be connected to an output ",(0,s.jsx)(n.code,{children:"Property"})," type port:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"class LiteralExample extends RawModule {\n  val outPort = IO(Output(Property[Int]()))\n  outPort := Property(123)\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"property-sequences",children:"Property Sequences"}),"\n",(0,s.jsxs)(n.p,{children:["Similarly to the primitive ",(0,s.jsx)(n.code,{children:"Property"})," types, sequences of ",(0,s.jsx)(n.code,{children:"Properties"})," may also be\nfor creating ports and values and they may also be connected:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"class SequenceExample extends RawModule {\n  val inPort = IO(Input(Property[Int]()))\n  val outPort1 = IO(Output(Property[Seq[Int]]()))\n  val outPort2 = IO(Output(Property[Seq[Int]]()))\n  // A Seq of literals can by turned into a Property\n  outPort1 := Property(Seq(123, 456))\n  // Property ports and literals can be mixed together into a Seq\n  outPort2 := Property(Seq(inPort, Property(789)))\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"property-expressions",children:"Property Expressions"}),"\n",(0,s.jsxs)(n.p,{children:["Expressions can be built out of ",(0,s.jsx)(n.code,{children:"Property"})," values for certain ",(0,s.jsx)(n.code,{children:"Property"})," types.\nThis is useful for expressing design intent that is parameterized by input\n",(0,s.jsx)(n.code,{children:"Property"})," values."]}),"\n",(0,s.jsx)(n.h4,{id:"integer-arithmetic",children:"Integer Arithmetic"}),"\n",(0,s.jsxs)(n.p,{children:["The integral ",(0,s.jsx)(n.code,{children:"Property"})," types, like ",(0,s.jsx)(n.code,{children:"Property[Int]"}),", ",(0,s.jsx)(n.code,{children:"Property[Long]"})," and\n",(0,s.jsx)(n.code,{children:"Property[BigInt]"}),", can be used to build arithmetic expressions in terms of\n",(0,s.jsx)(n.code,{children:"Property"})," values."]}),"\n",(0,s.jsxs)(n.p,{children:["In the following example, an output ",(0,s.jsx)(n.code,{children:"address"})," port of ",(0,s.jsx)(n.code,{children:"Property[Int]"})," type is\ncomputed as the addition of an ",(0,s.jsx)(n.code,{children:"offset"})," ",(0,s.jsx)(n.code,{children:"Property[Int]"})," value relative to an\ninput ",(0,s.jsx)(n.code,{children:"base"})," ",(0,s.jsx)(n.code,{children:"Property[Int]"})," value."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"class IntegerArithmeticExample extends RawModule {\n  val base = IO(Input(Property[Int]()))\n  val address = IO(Output(Property[Int]()))\n  val offset = Property(1024)\n  address := base + offset\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The following table lists the possible arithmetic operators that are supported\non integral ",(0,s.jsx)(n.code,{children:"Property"})," typed values."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Operation"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"+"})}),(0,s.jsx)(n.td,{children:"Perform addition as defined by FIRRTL spec section Integer Add Operation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"*"})}),(0,s.jsx)(n.td,{children:"Perform multiplication as defined by FIRRTL spec section Integer Multiply Operation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:">>"})}),(0,s.jsx)(n.td,{children:"Perform shift right as defined by FIRRTL spec section Integer Shift Right Operation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<<"})}),(0,s.jsx)(n.td,{children:"Perform shift left as defined by FIRRTL spec section Integer Shift Left Operation"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"sequence-operations",children:"Sequence Operations"}),"\n",(0,s.jsxs)(n.p,{children:["The sequence ",(0,s.jsx)(n.code,{children:"Property"})," types, like ",(0,s.jsx)(n.code,{children:"Property[Seq[Int]]"})," support some basic\noperations to create new sequences from existing sequences."]}),"\n",(0,s.jsxs)(n.p,{children:["In the following example, and output ",(0,s.jsx)(n.code,{children:"c"})," port of ",(0,s.jsx)(n.code,{children:"Property[Seq[Int]]"})," type is\ncomputed as the concatenation of the ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"})," ports of ",(0,s.jsx)(n.code,{children:"Property[Seq[Int]]"}),"\ntype."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"class SequenceOperationExample extends RawModule {\n  val a = IO(Input(Property[Seq[Int]]()))\n  val b = IO(Input(Property[Seq[Int]]()))\n  val c = IO(Output(Property[Seq[Int]]()))\n  c := a ++ b\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The following table lists the possible sequence operators that are supported on\nsequence ",(0,s.jsx)(n.code,{children:"Property"})," typed values."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Operation"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"++"})}),(0,s.jsx)(n.td,{children:"Perform concatenation as defined by FIRRTL spec section List Concatenation Operation"})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"classes-and-objects",children:"Classes and Objects"}),"\n",(0,s.jsxs)(n.p,{children:["Classes and Objects are to ",(0,s.jsx)(n.code,{children:"Property"})," types what modules and instances are to\nhardware types. That is, they provide a means to declare hierarchies through\nwhich ",(0,s.jsx)(n.code,{children:"Property"})," typed values flow. ",(0,s.jsx)(n.code,{children:"Class"})," declares a hierarchical container\nwith input and output ",(0,s.jsx)(n.code,{children:"Property"})," ports, and a body that contains ",(0,s.jsx)(n.code,{children:"Property"}),"\nconnections and ",(0,s.jsx)(n.code,{children:"Object"}),"s. ",(0,s.jsx)(n.code,{children:"Object"}),"s represent the instantiation of a ",(0,s.jsx)(n.code,{children:"Class"}),",\nwhich requires any input ",(0,s.jsx)(n.code,{children:"Property"})," ports to be assigned, and allows any output\n",(0,s.jsx)(n.code,{children:"Property"})," ports to be read."]}),"\n",(0,s.jsxs)(n.p,{children:["This allows domain-specific data models to be built using the basic primitives\nof an object-oriented programming language, and embedded directly in the\ninstance graph Chisel is constructing. Intuitively, inputs to a ",(0,s.jsx)(n.code,{children:"Class"})," are like\nconstructor arguments, which must be supplied to create an ",(0,s.jsx)(n.code,{children:"Object"}),". Similarly,\noutputs from a ",(0,s.jsx)(n.code,{children:"Class"})," are like fields, which may be accessed from an ",(0,s.jsx)(n.code,{children:"Object"}),".\nThis separation allows ",(0,s.jsx)(n.code,{children:"Class"})," declarations to abstract over any ",(0,s.jsx)(n.code,{children:"Object"}),"s\ncreated in their body--from the outside, the inputs must be supplied and only\nthe outputs may be accessed."]}),"\n",(0,s.jsxs)(n.p,{children:["The graphs represented by ",(0,s.jsx)(n.code,{children:"Class"})," declarations and ",(0,s.jsx)(n.code,{children:"Object"})," instantiations\ncoexist within the hardware instance graph. ",(0,s.jsx)(n.code,{children:"Object"})," instances can exist\nwithin hardware modules, providing domain-specific information, but hardware\ninstances cannot exist within ",(0,s.jsx)(n.code,{children:"Class"})," declarations."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Object"}),"s can be referenced, and references to ",(0,s.jsx)(n.code,{children:"Object"}),"s are a special kind of\n",(0,s.jsx)(n.code,{children:"Property[ClassType]"})," type. This allows the data model captured by ",(0,s.jsx)(n.code,{children:"Class"}),"\ndeclarations and ",(0,s.jsx)(n.code,{children:"Object"})," instances to form arbitrary graphs."]}),"\n",(0,s.jsxs)(n.p,{children:["To understand how ",(0,s.jsx)(n.code,{children:"Object"})," graphs are represented, and can ultimately be\nqueried, consider how the hardware instance graph is elaborated. To build the\n",(0,s.jsx)(n.code,{children:"Object"})," graph, we first pick an entrypoint module to start elaboration. The\nelaboration process works according to the Verilog spec's definition of\nelaboration--instances of modules and ",(0,s.jsx)(n.code,{children:"Object"}),"s are instantiated in-memory,\nwith connections to their inputs and outputs. Inputs are supplied, and outputs\nmay be read. After elaboration completes, the ",(0,s.jsx)(n.code,{children:"Object"})," graph is exposed in terms\nof the output ports, which may contain any ",(0,s.jsx)(n.code,{children:"Property"})," types, including\nreferences to ",(0,s.jsx)(n.code,{children:"Object"}),"s."]}),"\n",(0,s.jsx)(n.p,{children:"To illustrate how these pieces come together, consider the following examples:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import chisel3.properties.Class\nimport chisel3.experimental.hierarchy.{instantiable, public, Definition, Instance}\n\n// An abstract description of a CSR, represented as a Class.\n@instantiable\nclass CSRDescription extends Class {\n  // An output Property indicating the CSR name.\n  val identifier = IO(Output(Property[String]()))\n  // An output Property describing the CSR.\n  val description = IO(Output(Property[String]()))\n  // An output Property indicating the CSR width.\n  val width = IO(Output(Property[Int]()))\n\n  // Input Properties to be passed to Objects representing instances of the Class.\n  @public val identifierIn = IO(Input(Property[String]()))\n  @public val descriptionIn = IO(Input(Property[String]()))\n  @public val widthIn = IO(Input(Property[Int]()))\n\n  // Simply connect the inputs to the outputs to expose the values.\n  identifier := identifierIn\n  description := descriptionIn\n  width := widthIn\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"CSRDescription"})," is a ",(0,s.jsx)(n.code,{children:"Class"})," that represents domain-specific information\nabout a CSR. This uses ",(0,s.jsx)(n.code,{children:"@instantiable"})," and ",(0,s.jsx)(n.code,{children:"@public"})," so the ",(0,s.jsx)(n.code,{children:"Class"})," can work\nwith the ",(0,s.jsx)(n.code,{children:"Definition"})," and ",(0,s.jsx)(n.code,{children:"Instance"})," APIs."]}),"\n",(0,s.jsxs)(n.p,{children:["The readable fields we want to expose on ",(0,s.jsx)(n.code,{children:"Object"}),"s of the ",(0,s.jsx)(n.code,{children:"CSRDescription"})," class\nare a string identifier, a string description, and an integer bitwidth, so these\nare output ",(0,s.jsx)(n.code,{children:"Property"})," type ports on the ",(0,s.jsx)(n.code,{children:"Class"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To capture concrete values at each ",(0,s.jsx)(n.code,{children:"Object"})," instantiation, we have corresponding\ninput ",(0,s.jsx)(n.code,{children:"Property"})," type ports, which are connected directly to the outputs. This\nis how we would represent something like a Scala ",(0,s.jsx)(n.code,{children:"case class"})," using ",(0,s.jsx)(n.code,{children:"Class"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"// A hardware module representing a CSR and its description.\nclass CSRModule(\n  csrDescDef:     Definition[CSRDescription],\n  width:          Int,\n  identifierStr:  String,\n  descriptionStr: String)\n    extends Module {\n  override def desiredName = identifierStr\n\n  // Create a hardware port for the CSR value.\n  val value = IO(Output(UInt(width.W)))\n\n  // Create a property port for a reference to the CSR description object.\n  val description = IO(Output(csrDescDef.getPropertyType))\n\n  // Instantiate a CSR description object, and connect its input properties.\n  val csrDescription = Instance(csrDescDef)\n  csrDescription.identifierIn := Property(identifierStr)\n  csrDescription.descriptionIn := Property(descriptionStr)\n  csrDescription.widthIn := Property(width)\n\n  // Create a register for the hardware CSR. A real implementation would be more involved.\n  val csr = RegInit(0.U(width.W))\n\n  // Assign the CSR value to the hardware port.\n  value := csr\n\n  // Assign a reference to the CSR description object to the property port.\n  description := csrDescription.getPropertyReference\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"CSRModule"})," is a ",(0,s.jsx)(n.code,{children:"Module"})," that represents the (dummy) hardware for a CSR, as\nwell as a ",(0,s.jsx)(n.code,{children:"CSRDescription"}),". Using a ",(0,s.jsx)(n.code,{children:"Definition"})," of a ",(0,s.jsx)(n.code,{children:"CSRDescription"}),", an\n",(0,s.jsx)(n.code,{children:"Object"})," is created and its inputs supplied from the ",(0,s.jsx)(n.code,{children:"CSRModule"})," constructor\narguments. Then, a reference to the ",(0,s.jsx)(n.code,{children:"Object"})," is connected to the ",(0,s.jsx)(n.code,{children:"CSRModule"}),"\noutput, so the reference will be exposed to the outside."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'// The entrypoint module.\nclass Top extends Module {\n  // Create a Definition for the CSRDescription Class.\n  val csrDescDef = Definition(new CSRDescription)\n\n  // Get the CSRDescription ClassType.\n  val csrDescType = csrDescDef.getClassType\n\n  // Create a property port to collect all the CSRDescription object references.\n  val descriptions = IO(Output(Property[Seq[csrDescType.Type]]()))\n\n  // Instantiate a couple CSR modules.\n  val mcycle = Module(new CSRModule(csrDescDef, 64, "mcycle", "Machine cycle counter."))\n  val minstret = Module(new CSRModule(csrDescDef, 64, "minstret", "Machine instructions-retired counter."))\n\n  // Assign references to the CSR description objects to the property port.\n  descriptions := Property(Seq(mcycle.description.as(csrDescType), minstret.description.as(csrDescType)))\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Top"})," module represents the entrypoint. It creates the ",(0,s.jsx)(n.code,{children:"Definition"})," of the\n",(0,s.jsx)(n.code,{children:"CSRDescription"}),", and creates some ",(0,s.jsx)(n.code,{children:"CSRModule"}),"s. It then takes the description\nreferences, collects them into a list, and outputs the list so it will be\nexposed to the outside."]}),"\n",(0,s.jsxs)(n.p,{children:["While it is not required to use the ",(0,s.jsx)(n.code,{children:"Definition"})," API to define a ",(0,s.jsx)(n.code,{children:"Class"}),', this\nis the "safe" API, with support in Chisel for working with ',(0,s.jsx)(n.code,{children:"Definition"}),"s and\n",(0,s.jsx)(n.code,{children:"Instance"}),"s of a ",(0,s.jsx)(n.code,{children:"Class"}),'. There is also an "unsafe" API. See ',(0,s.jsx)(n.code,{children:"DynamicObject"})," for\nmore information."]}),"\n",(0,s.jsx)(n.p,{children:"To illustrate what this example generates, here is a listing of the FIRRTL:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'FIRRTL version 4.0.0\ncircuit Top :\n  class CSRDescription :\n    output identifier : String\n    output description : String\n    output width : Integer\n    input identifierIn : String\n    input descriptionIn : String\n    input widthIn : Integer\n\n    propassign identifier, identifierIn\n    propassign description, descriptionIn\n    propassign width, widthIn\n\n  module mcycle :\n    input clock : Clock\n    input reset : Reset\n    output value : UInt<64>\n    output description : Inst<CSRDescription>\n\n    object csrDescription of CSRDescription\n    propassign csrDescription.identifierIn, String("mcycle")\n    propassign csrDescription.descriptionIn, String("Machine cycle counter.")\n    propassign csrDescription.widthIn, Integer(64)\n    regreset csr : UInt<64>, clock, reset, UInt<64>(0h0)\n    connect value, csr\n    propassign description, csrDescription\n\n  module minstret :\n    input clock : Clock\n    input reset : Reset\n    output value : UInt<64>\n    output description : Inst<CSRDescription>\n\n    object csrDescription of CSRDescription\n    propassign csrDescription.identifierIn, String("minstret")\n    propassign csrDescription.descriptionIn, String("Machine instructions-retired counter.")\n    propassign csrDescription.widthIn, Integer(64)\n    regreset csr : UInt<64>, clock, reset, UInt<64>(0h0)\n    connect value, csr\n    propassign description, csrDescription\n\n  public module Top :\n    input clock : Clock\n    input reset : UInt<1>\n    output descriptions : List<Inst<CSRDescription>>\n\n    inst mcycle of mcycle\n    connect mcycle.clock, clock\n    connect mcycle.reset, reset\n    inst minstret of minstret\n    connect minstret.clock, clock\n    connect minstret.reset, reset\n    propassign descriptions, List<Inst<CSRDescription>>(mcycle.description, minstret.description)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["To understand the ",(0,s.jsx)(n.code,{children:"Object"})," graph that is constructed, we will consider an\nentrypoint to elaboration, and then show a hypothetical JSON representation of\nthe ",(0,s.jsx)(n.code,{children:"Object"})," graph. The details of how we go from IR to an ",(0,s.jsx)(n.code,{children:"Object"})," graph are\noutside the scope of this document, and implemented by related tools."]}),"\n",(0,s.jsxs)(n.p,{children:["If we elaborate ",(0,s.jsx)(n.code,{children:"Top"}),", the ",(0,s.jsx)(n.code,{children:"descriptions"})," output ",(0,s.jsx)(n.code,{children:"Property"})," is our entrypoint to\nthe ",(0,s.jsx)(n.code,{children:"Object"})," graph. Within it, there are two ",(0,s.jsx)(n.code,{children:"Object"}),"s, the ",(0,s.jsx)(n.code,{children:"CSRDescription"}),"s of\nthe ",(0,s.jsx)(n.code,{children:"mcycle"})," and ",(0,s.jsx)(n.code,{children:"minstret"})," modules:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"mdoc:silent",children:'{\n  "descriptions": [\n    {\n      "identifier": "mcycle",\n      "description": "Machine cycle counter.",\n      "width": 64\n    },\n    {\n      "identifier": "minstret",\n      "description": "Machine instructions-retired counter.",\n      "width": 64\n    }\n  ]\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If instead, we elaborate one of the ",(0,s.jsx)(n.code,{children:"CSRModule"}),"s, for example, ",(0,s.jsx)(n.code,{children:"minstret"}),", the\n",(0,s.jsx)(n.code,{children:"description"})," output ",(0,s.jsx)(n.code,{children:"Property"})," is our entrypoint to the ",(0,s.jsx)(n.code,{children:"Object"})," graph, which\ncontains the single ",(0,s.jsx)(n.code,{children:"CSRDescription"})," object:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"mdoc:silent",children:'{\n  "description": {\n    "identifier": "minstret",\n    "description": "Machine instructions-retired counter.",\n    "width": 64\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In this way, the output ",(0,s.jsx)(n.code,{children:"Property"})," ports, ",(0,s.jsx)(n.code,{children:"Object"})," references, and choice of\nelaboration entrypoint allow us to view the ",(0,s.jsx)(n.code,{children:"Object"})," graph representing the\ndomain-specific data model from different points in the hierarchy."]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>c});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);