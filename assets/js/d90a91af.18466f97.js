"use strict";(globalThis.webpackChunkchisel_lang=globalThis.webpackChunkchisel_lang||[]).push([[9240],{832(e,n,i){i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"explanations/testing","title":"Testing","description":"Chisel provides several packages for testing generators with different","source":"@site/docs/explanations/testing.md","sourceDirName":"explanations","slug":"/explanations/testing","permalink":"/docs/explanations/testing","draft":false,"unlisted":false,"editUrl":"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/testing.md","tags":[],"version":"current","frontMatter":{"layout":"docs","title":"Testing","section":"chisel3"},"sidebar":"chiselSidebar","previous":{"title":"Supported Hardware","permalink":"/docs/explanations/supported-hardware"},"next":{"title":"Unconnected Wires","permalink":"/docs/explanations/unconnected-wires"}}');var t=i(4848),o=i(8453);const l={layout:"docs",title:"Testing",section:"chisel3"},a="Testing",r={},c=[{value:"ChiselSim",id:"chiselsim",level:2},{value:"Simulation APIs",id:"simulation-apis",level:3},{value:"Stimulus",id:"stimulus",level:3},{value:"Peek/Poke APIs",id:"peekpoke-apis",level:4},{value:"Reusable Stimulus Patterns",id:"reusable-stimulus-patterns",level:4},{value:"Example",id:"example",level:3},{value:"Scalatest Support",id:"scalatest-support",level:3},{value:"Directory Naming",id:"directory-naming",level:4},{value:"Command Line Arguments",id:"command-line-arguments",level:4},{value:"FileCheck",id:"filecheck",level:2},{value:"Example",id:"example-1",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"testing",children:"Testing"})}),"\n",(0,t.jsx)(n.p,{children:"Chisel provides several packages for testing generators with different\nstrategies."}),"\n",(0,t.jsxs)(n.p,{children:["The primary testing strategy is simulation.  This is done using ",(0,t.jsx)(n.em,{children:"ChiselSim"}),", a\nlibrary for simulating Chisel-generated SystemVerilog on different simulators."]}),"\n",(0,t.jsxs)(n.p,{children:["An alternative, complementary testing strategy is to directly inspect the\nSystemVerilog or FIRRTL text that a Chisel generator produces.  This is done\nusing ",(0,t.jsx)(n.a,{href:"https://llvm.org/docs/CommandGuide/FileCheck.html",children:"FileCheck"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"The apprpriate testing strategy will depend on what you are trying to test.  It\nis likely that you will want a mix of different strategies."})}),"\n",(0,t.jsx)(n.p,{children:"Both ChiselSim and FileCheck are provided as packages inside Chisel.\nSubsections below describe these packages and their use."}),"\n",(0,t.jsx)(n.h2,{id:"chiselsim",children:"ChiselSim"}),"\n",(0,t.jsx)(n.p,{children:"ChiselSim provides a number of methods that you can use to run simulations and\nprovide stimulus to Chisel modules being tested."}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"ChiselSim requires the installation of a compatible simulator tool, like\nVerilator or VCS."})}),"\n",(0,t.jsx)(n.p,{children:"To use ChiselSim, mix-in one of the following two traits into a class:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"chisel3.simulator.ChiselSim"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"chisel3.simulator.scalatest.ChiselSim"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Both traits provide the same methods.  The latter trait provides tighter\nintegration with ",(0,t.jsx)(n.a,{href:"https://www.scalatest.org/",children:"ScalaTest"})," and will cause test\nresults to be placed in a directory structure derived from ScalaTest test names\nfor easy user inspection."]}),"\n",(0,t.jsx)(n.h3,{id:"simulation-apis",children:"Simulation APIs"}),"\n",(0,t.jsx)(n.p,{children:"ChiselSim provides two simulation APIs for running simulations.  These are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"simulate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"simulateRaw"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The former may only be used with ",(0,t.jsx)(n.code,{children:"Module"}),"s or their subtypes.  The latter may\nonly be used with ",(0,t.jsx)(n.code,{children:"RawModule"}),"s or their subtypes."]}),"\n",(0,t.jsxs)(n.p,{children:["Thd difference between them is that ",(0,t.jsx)(n.code,{children:"simulate"})," will put the module through an\ninitialization procedure before user stimulus is applied."]}),"\n",(0,t.jsxs)(n.p,{children:["Conversely, ",(0,t.jsx)(n.code,{children:"simulateRaw"})," will apply no initialization procedure and it is up to\nthe user to provide suitable reset stimulus."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["The reason why ",(0,t.jsx)(n.code,{children:"simulate"})," can define a reset procedure is because a ",(0,t.jsx)(n.code,{children:"Module"})," has\na defined clock and reset port.  Because of this, a common pattern when working\nwith ChiselSim is to wrap your design under test in a test harness that is a\n",(0,t.jsx)(n.code,{children:"Module"}),".  The test harness will be provided with the initialization stimulus\nand any more complicated stimulus (e.g., multiple clocks) can be derived inside\nthe test harness."]})}),"\n",(0,t.jsxs)(n.p,{children:["For more information see the ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api",children:"Chisel API\ndocumentation"})," for\n",(0,t.jsx)(n.code,{children:"chisel3.simulator.SimulatorAPI"})]}),"\n",(0,t.jsx)(n.h3,{id:"stimulus",children:"Stimulus"}),"\n",(0,t.jsx)(n.p,{children:"Simulation APIs take user provided stimulus and apply it to the\ndesign-under-test (DUT).  There are two mechanisms provided for applying\nstimulus: (1) Peek/Poke APIs and (2) reusable stimulus patterns.  The former\nprovide simple, freeform ways to apply simple directed stimulus.  The latter\nprovide common stimulus applicable to a wide range of modules."}),"\n",(0,t.jsx)(n.h4,{id:"peekpoke-apis",children:"Peek/Poke APIs"}),"\n",(0,t.jsxs)(n.p,{children:['ChiselSim provides basic "peek", "poke", and "expect" APIs for providing simple\nstimulus to Chisel modules.  This API is implemented as ',(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Extension_method",children:"extension\nmethods"})," on Chisel types, like\n",(0,t.jsx)(n.code,{children:"Data"}),".  This means that the ports of your design under test have ",(0,t.jsx)(n.em,{children:"new"})," methods\ndefined on them that can be used to drive stimulus."]}),"\n",(0,t.jsx)(n.p,{children:"These APIs are summarized below:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"poke"})," sets a value on a port"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"peek"})," reads a value on a port"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"expect"})," reads a value on a port and asserts that it is equal another value"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"step"})," toggles a clock for a number of cycles"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"stepUntil"})," toggles a clock until a condition occurs on another port"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For more information see the ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api",children:"Chisel API\ndocumentation"})," for\n",(0,t.jsx)(n.code,{children:"chisel3.simulator.PeekPokeAPI"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"reusable-stimulus-patterns",children:"Reusable Stimulus Patterns"}),"\n",(0,t.jsxs)(n.p,{children:["While the Peek/Poke APIs are useful for freeform tests, there are a number of\ncommon stimulus patterns that are frequently applied during testing.  E.g.,\nbringing a module out of reset or running a simulation until it finishes.  These\npatterns are provided in the ",(0,t.jsx)(n.code,{children:"chisel3.simulator.stimulus"})," package.  Currently,\nthe following stimuli are available:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ResetProcedure"})," will reset a module in a predictable fashion.  This provides\nsufficient spacing for initial blocks to execute at time zero, register/memory\nrandomization to happen after that, and reset to assert for a parametric\nnumber of cycles. (This is the same stimulus used by the ",(0,t.jsx)(n.code,{children:"simulate"})," API.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"RunUntilFinished"})," runs the module for a user-provided number of cycles\nexpecting that the simulation will finish cleanly (via ",(0,t.jsx)(n.code,{children:"chisel3.stop"}),") or\nerror (via a Chisel assertion).  If the unit runs for the number of cycles\nwithout asserting or finishing, a simulation assertion is thrown."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"RunUntilSuccess"})," runs the module for a user-provided number of cycles\nexpecting that the module will assert a success port (indicating success) or\nerror (via a Chisel assertion).  The success port must be provided to the\nstimulus as a parameter."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["These stimuli are intended to be used via their factory methods.  Most stimuli\nprovide different factories for different module types.  E.g., the\n",(0,t.jsx)(n.code,{children:"ResetProcedure"})," factory has two methods: ",(0,t.jsx)(n.code,{children:"any"})," which will generate stimulus for\n",(0,t.jsx)(n.em,{children:"any"})," Chisel module and ",(0,t.jsx)(n.code,{children:"module"})," which can only generate stimulus for subtypes\nof ",(0,t.jsx)(n.code,{children:"Module"}),".  The reason for this split is that this specific stimulus needs to\nknow what the clock and reset ports are in order to apply reset stimulus to\nthem.  Chisel ",(0,t.jsx)(n.code,{children:"Module"}),"s have known clock and reset ports allowing the ",(0,t.jsx)(n.code,{children:"module"}),"\nstimulus to have just one parameter---the number of cycles to apply the reset\nfor.  However, a Chisel ",(0,t.jsx)(n.code,{children:"RawModule"})," does not have known clock and reset ports\nand user needs to provide more parameters to the factory---the number of reset\ncycles ",(0,t.jsx)(n.em,{children:"and"})," functions to get the clock and reset ports."]}),"\n",(0,t.jsxs)(n.p,{children:["For more information see the ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api",children:"Chisel API\ndocumentation"})," for\n",(0,t.jsx)(n.code,{children:"chisel3.simulator.stimulus"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,t.jsxs)(n.p,{children:["The example below shows a basic usage of ChiselSim inside ScalaTest.  This shows\na single test suite, ",(0,t.jsx)(n.code,{children:"ChiselSimExample"}),".  To gain access to ChiselSim methods,\nthe ",(0,t.jsx)(n.code,{children:"ChiselSim"})," trait is mixed in.  A ",(0,t.jsx)(n.a,{href:"https://www.scalatest.org/user_guide/selecting_a_style",children:"testing\nstyle"}),", ",(0,t.jsx)(n.code,{children:"AnyFunSpec"}),", is\nalso chosen."]}),"\n",(0,t.jsxs)(n.p,{children:["In the test, module ",(0,t.jsx)(n.code,{children:"Foo"})," is tested using custom stimulus.  Module ",(0,t.jsx)(n.code,{children:"Bar"})," is\ntested using reusable ",(0,t.jsx)(n.code,{children:"RunUntilFinished"})," stimulus.  Module ",(0,t.jsx)(n.code,{children:"Baz"})," is tested using\nreusable ",(0,t.jsx)(n.code,{children:"RunUntilSuccess"})," stimulus.  All tests, as written, will pass."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.simulator.scalatest.ChiselSim\nimport chisel3.simulator.stimulus.{RunUntilFinished, RunUntilSuccess}\nimport chisel3.util.Counter\nimport org.scalatest.funspec.AnyFunSpec\n\nclass ChiselSimExample extends AnyFunSpec with ChiselSim {\n\n  class Foo extends Module {\n    val a, b = IO(Input(UInt(8.W)))\n    val c = IO(Output(chiselTypeOf(a)))\n\n    private val r = Reg(chiselTypeOf(a))\n\n    r :<= a +% b\n    c :<= r\n  }\n\n  describe("Baz") {\n\n    it("adds two numbers") {\n\n      simulate(new Foo) { foo =>\n        // Poke different values on the two input ports.\n        foo.a.poke(1)\n        foo.b.poke(2)\n\n        // Step the clock by one cycle.\n        foo.clock.step(1)\n\n        // Expect that the sum of the two inputs is on the output port.\n        foo.c.expect(3)\n      }\n\n    }\n\n  }\n\n  class Bar extends Module {\n\n    val (_, done) = Counter(true.B, 10)\n\n    when (done) {\n      stop()\n    }\n\n  }\n\n  describe("Bar") {\n\n    it("terminates cleanly before 11 cycles have elapsed") {\n\n      simulate(new Bar)(RunUntilFinished(11))\n\n    }\n\n  }\n\n  class Baz extends Module {\n\n    val success = IO(Output(Bool()))\n\n    val (_, done) = Counter(true.B, 20)\n\n    success :<= done\n\n  }\n\n  describe("Baz") {\n\n    it("asserts success before 21 cycles have elapsed") {\n\n      simulate(new Baz)(RunUntilSuccess(21, _.success))\n\n    }\n\n  }\n\n}\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"scalatest-support",children:"Scalatest Support"}),"\n",(0,t.jsx)(n.p,{children:"ChiselSim provides a number of features that synergize with Scalatest to improve\nthe testing experience."}),"\n",(0,t.jsx)(n.h4,{id:"directory-naming",children:"Directory Naming"}),"\n",(0,t.jsx)(n.p,{children:'When using ChiselSim in a Scalatest environment, by default a testing directory\nstructure will be created that matches the Scalatest test "scopes" that are\nprovided.  Practically, this results in your tests being organized based on how\nyou organized them in Scalatest.'}),"\n",(0,t.jsxs)(n.p,{children:["The root of the testing directory is, by default, ",(0,t.jsx)(n.code,{children:"build/chiselsim/"}),".  You may\nchange this by overriding the ",(0,t.jsx)(n.code,{children:"buildDir"})," method."]}),"\n",(0,t.jsx)(n.p,{children:'Under the testing directory, you will get one directory for each test suite.  Underneath that, you will get a directory for each test "scope".  E.g., for the test shown in the example above, this will produce the following directory structure:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"build/chiselsim\n\u2514\u2500\u2500 ChiselSimExample\n    \u251c\u2500\u2500 Foo\n    \u2502   \u2514\u2500\u2500 adds-two-numbers\n    \u251c\u2500\u2500 Bar\n    \u2502   \u2514\u2500\u2500 terminates-cleanly-before-11-cycles-have-elapsed\n    \u2514\u2500\u2500 Baz\n        \u2514\u2500\u2500 asserts-success-before-21-cycles-have-elapsed\n"})}),"\n",(0,t.jsx)(n.h4,{id:"command-line-arguments",children:"Command Line Arguments"}),"\n",(0,t.jsxs)(n.p,{children:["Scalatest has support for passing command line arguments to Scalatest using its\n",(0,t.jsx)(n.code,{children:"ConfigMap"})," feature.  ChiselSim wraps this with an improved API for adding\ncommand line arguments to tests, displaying help text, and checking that only\nlegal arguments are passed."]}),"\n",(0,t.jsxs)(n.p,{children:["By default, several command line options are already available for ChiselSim\ntests using Scalatest.  You can see these by passing the ",(0,t.jsx)(n.code,{children:"-Dhelp=1"})," argument to\nScalatest.  E.g., this is the help text for the tests shown in the example above:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'Usage: <ScalaTest> [-D<name>=<value>...]\n\nThis ChiselSim ScalaTest test supports passing command line arguments via\nScalaTest\'s "config map" feature.  To access this, append `-D<name>=<value>` for\na legal option listed below.\n\nOptions:\n\n  chiselOpts\n      additional options to pass to the Chisel elaboration\n  emitVcd\n      compile with VCD waveform support and start dumping waves at time zero\n  firtoolOpts\n      additional options to pass to the firtool compiler\n  help\n      display this help text\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The most frequently used of these options is ",(0,t.jsx)(n.code,{children:"-DemitVcd=1"}),".  This will cause\nyour test to dump a Value Change Dump (VCD) waveform when the test executes.\nThis is useful if your test fails and you need a waveform to debug why."]}),"\n",(0,t.jsxs)(n.p,{children:["There are a number of other command line options that you can optionally mix-in\nto your ChiselSim Scalatest test suite that are ",(0,t.jsx)(n.em,{children:"not"})," automatically available to\nChiselSim.  These are available in the ",(0,t.jsx)(n.code,{children:"chisel3.simulator.scalatest.Cli"})," object:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"EmitFsdb"})," adds an ",(0,t.jsx)(n.code,{children:"-DemitFsdb=1"})," option which will cause the simulator, if it\nsupports it, to generate an FSDB waveform."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"EmitVpd"})," adds an ",(0,t.jsx)(n.code,{children:"-DemitVpd=1"})," option which will cause the simulator, if it\nsupports it, to generate an VPD waveform."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Scale"})," adds a ",(0,t.jsx)(n.code,{children:"-Dscale=<float>"}),' option.  This provides a way for a user to\n"scale" a test up or down at test-tiem, e.g., to make the test run longer.\nThis feature is accessed via the ',(0,t.jsx)(n.code,{children:"scaled"})," method that this trait provides."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Simulator"})," adds a ",(0,t.jsx)(n.code,{children:"-Dsimulator=<simulator-name>"})," argument.  This allows for\ntest-time selection of either VCS or verilator as the simulation backend."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Simulator"})," command line will automatically disable ",(0,t.jsx)(n.code,{children:"Temporal"})," layers when\nrunning with the Verilator backend.  When running without the ",(0,t.jsx)(n.code,{children:"Simulator"}),"\ncommand line and explicitly choosing a simulator, no layers are automatically\ndisabled, even when running with Verilator."]})}),"\n",(0,t.jsxs)(n.p,{children:["If the command line option that you want to add is not already available, you\ncan add a custom option to your test using one of several methods provided in\n",(0,t.jsx)(n.code,{children:"chisel3.simulator.scalatest.HasCliOptions"}),".  The most flexible method is\n",(0,t.jsx)(n.code,{children:"addOption"}),".  This allows you to add an option that may change anything about\nthe simulation including the Chisel elaboration, FIRRTL compilation, or generic\nor backend-specific settings."]}),"\n",(0,t.jsxs)(n.p,{children:["More commonly, you just want to add an integer, double, string, or flag-like\noptions to a test.  For this, simpler option ",(0,t.jsx)(n.em,{children:"factories"}),"\n(",(0,t.jsx)(n.code,{children:"chisel3.simulator.scalatest.CliOption.{simple, double, int, string, flag}"}),")\nare provided.  After an option has been declared, it can be accessed ",(0,t.jsx)(n.em,{children:"within a\ntest"})," using the ",(0,t.jsx)(n.code,{children:"getOption"})," method."]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"getOption"})," method may only be used ",(0,t.jsx)(n.em,{children:"inside"})," a test.  If used outside a\ntest, this will cause a runtime exception."]})}),"\n",(0,t.jsxs)(n.p,{children:["The example below shows how to use the ",(0,t.jsx)(n.code,{children:"int"})," option to set a test-time\nconfigurable seed:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.simulator.scalatest.ChiselSim\nimport chisel3.simulator.scalatest.HasCliOptions.CliOption\nimport chisel3.util.random.LFSR\nimport circt.stage.ChiselStage\nimport org.scalatest.funspec.AnyFunSpec\n\nclass ChiselSimExample extends AnyFunSpec with ChiselSim {\n\n  CliOption.int("seed", "the seed to use for the test")\n\n  class Foo(seed: Int) extends Module {\n    private val lfsr = LFSR(64, seed = Some(seed))\n  }\n\n  describe("Foo") {\n    it("generates FIRRTL for a module with a test-time configurable seed") {\n      ChiselStage.emitCHIRRTL(new Foo(getOption[Int]("seed").getOrElse(42)))\n    }\n  }\n\n}\n'})}),"\n",(0,t.jsxs)(n.admonition,{type:"warning",children:[(0,t.jsx)(n.p,{children:"Be parsimonious with test options.  While they can be useful, they may indicate\nan anti-pattern in testing.  If your test is test-time parametric, you are no\nlonger always testing the same thing.  This can create holes when testing your\nChisel generator if the correct parameters are not tested."}),(0,t.jsxs)(n.p,{children:["Consider, instead, sweeping over test parameters ",(0,t.jsx)(n.em,{children:"within your test"})," or by\nwriting multiple Scalatest tests."]})]}),"\n",(0,t.jsx)(n.h2,{id:"filecheck",children:"FileCheck"}),"\n",(0,t.jsx)(n.p,{children:"Sometimes, it is sufficient to directly inspect the result of a generator.  This\ntesting strategy is particularly relevent if you are trying to create very\nspecific FIRRTL or SystemVerilog structures or to guarantee exact naming of\nspecific constructs."}),"\n",(0,t.jsxs)(n.p,{children:["While simple testing can be done with string comparisons, this is often\ninsufficient as it is necessary to both have a mixture of regular expression\ncaptures and ordering of specific lines.  For this, Chisel provides a native way\nto write ",(0,t.jsx)(n.a,{href:"https://llvm.org/docs/CommandGuide/FileCheck.html",children:"FileCheck"})," tests."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"Use of FileCheck tests requires installation of the FileCheck binary.  FileCheck\nis typically packaged as part of LLVM."})}),"\n",(0,t.jsx)(n.p,{children:"Like with ChiselSim, two different traits are provided for writing FileCheck\ntests:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"chisel3.testing.FileCheck"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"chisel3.testing.scalatest.FileCheck"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Both provide the same APIs, but the latter will write intermediary files to\ndirectories derived from ScalaTest suite and scope names."}),"\n",(0,t.jsxs)(n.p,{children:["Presently, only one FileCheck API is provided: ",(0,t.jsx)(n.code,{children:"fileCheck"}),".  This API is\nimplemented as an extension method on ",(0,t.jsx)(n.code,{children:"String"})," and takes two arguments: (1) a\nlist of arguments to FileCheck and (2) a string that contains an inline\nFileCheck test to run.  Both the input string and the check string will be\nwritten to disk and preserved on failure so that you can rerun them manually if\nneeded."]}),"\n",(0,t.jsxs)(n.p,{children:["If the ",(0,t.jsx)(n.code,{children:"fileCheck"})," method succeeds, nothing is returned.  If it fails, it will\nthrow an exception indicating why it failed and verbose information aobut where\nan expected string did not match."]}),"\n",(0,t.jsxs)(n.p,{children:["For more information on the API see the ",(0,t.jsx)(n.a,{href:"https://www.chisel-lang.org/api",children:"Chisel API\ndocumentation"})," for ",(0,t.jsx)(n.code,{children:"chisel3.testing.FileCheck"}),".\nFor more information on FileCheck and its usage see the ",(0,t.jsx)(n.a,{href:"https://llvm.org/docs/CommandGuide/FileCheck.html",children:"FileCheck\ndocumentation"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["FileCheck is a tool used extensively in the testing of compilers in the LLVM\necosystem.  ",(0,t.jsx)(n.a,{href:"https://github.com/llvm/circt",children:"CIRCT"}),", the compiler that converts\nthe FIRRTL that Chisel produces into SystemVerilog, makes heavy use of FileCheck\nfor its own testing."]})}),"\n",(0,t.jsxs)(n.p,{children:["When writing FileCheck tests, you will often be using a Chisel API to convert\nyour Chisel circuit into FIRRTL or SystemVerilog.  Two methods exist to do this\nin the ",(0,t.jsx)(n.code,{children:"circt.stage.ChiselStage"})," object:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"emitCHIRRTL"})," to generate FIRRTL with a few Chisel extensions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"emitSystemVerilog"})," to generate SystemVerilog"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Both of these methods take an optional ",(0,t.jsx)(n.code,{children:"args"})," parameter which sets the Chisel\nelaboration options.  The latter method has an additional, optional\n",(0,t.jsx)(n.code,{children:"firtoolOpts"})," parameter which controls the ",(0,t.jsx)(n.code,{children:"firtool"})," (FIRRTL compiler) options."]}),"\n",(0,t.jsxs)(n.p,{children:["Without any ",(0,t.jsx)(n.code,{children:"firtoolOpts"})," provided to ",(0,t.jsx)(n.code,{children:"emitSystemVerilog"}),", the generated\nSystemVerilog may be difficult for you to use FileCheck with due to the default\nSystemVerilog lowering, emission, and pretty printing used by ",(0,t.jsx)(n.code,{children:"firtool"}),".  To\nmake it easier to write your tests, we suggest using the following options:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"-loweringOptions=emittedLineLength=160"})," to increase the allowable line\nlength.  By default, ",(0,t.jsx)(n.code,{children:"firtool"})," will wrap lines that exceed 80 characters.  You\nmay consider using a ",(0,t.jsx)(n.em,{children:"very long"})," line length (e.g., 8192) to avoid this\nproblem altogether."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"-loweringOptions=disallowLocalVariables"})," to disable generation of ",(0,t.jsx)(n.code,{children:"automatic logic"})," temporaries in always blocks.  This can cause temporaries to spill\nwithin an always block which may be slightly unexpected."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For more information about ",(0,t.jsx)(n.code,{children:"firtool"})," and its lowering options see the ",(0,t.jsx)(n.a,{href:"https://circt.llvm.org/docs/VerilogGeneration/#controlling-output-style-with-loweringoptions",children:"CIRCT's\nVerilog Generation\ndocumentation"}),"\nor invoke ",(0,t.jsx)(n.code,{children:"firtool -help"})," for a complete list of all supported options."]}),"\n",(0,t.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,t.jsx)(n.p,{children:"The example below shows a FileCheck test that checks that a module has a\nspecific name and that it has some expected content inside it.  Specifically,\nthis test is checking that constant propagation happens as expected.  As\nwritten, this test will pass."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.testing.scalatest.FileCheck\nimport circt.stage.ChiselStage\nimport org.scalatest.funspec.AnyFunSpec\n\nclass FileCheckExample extends AnyFunSpec with FileCheck {\n\n  class Baz extends RawModule {\n\n    val out = IO(Output(UInt(32.W)))\n\n    out :<= 1.U(32.W) + 3.U(32.W)\n\n  }\n\n  describe("Foo") {\n\n    it("should simplify the constant computation in its body") {\n\n      ChiselStage.emitSystemVerilog(new Baz).fileCheck()(\n        """|CHECK:      module Baz(\n           |CHECK-NEXT:   output [31:0] out\n           |CHECK:        assign out = 32\'h4;\n           |CHECK:      endmodule\n           |""".stripMargin\n        )\n\n    }\n\n  }\n\n}\n\n'})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsxs)(n.p,{children:["FileCheck has ",(0,t.jsx)(n.em,{children:"a lot"})," of useful features that are not shown in this example."]}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"CHECK-SAME"})," allows for checking a match on the same line.  ",(0,t.jsx)(n.code,{children:"CHECK-NOT"})," ensures\nthat a match does ",(0,t.jsx)(n.em,{children:"not"})," happen.  ",(0,t.jsx)(n.code,{children:"CHECK-COUNT-<n>"})," will check for ",(0,t.jsx)(n.code,{children:"n"}),"\nrepetitions of a match.  ",(0,t.jsx)(n.code,{children:"CHECK-DAG"})," will allow for a series of matches to occur\nin any order."]}),(0,t.jsx)(n.p,{children:"Most powerfully, FileCheck allows for inline regular expression and saving the\nresults in string substitution blocks which can then be used later.  This is\nuseful when you care about capturing a name, but do not care about the actual\nname."}),(0,t.jsx)(n.p,{children:"Please see the FileCheck documentation for more thorough documentation."})]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453(e,n,i){i.d(n,{R:()=>l,x:()=>a});var s=i(6540);const t={},o=s.createContext(t);function l(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);