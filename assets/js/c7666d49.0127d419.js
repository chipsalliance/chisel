"use strict";(self.webpackChunkchisel_lang=self.webpackChunkchisel_lang||[]).push([[6474],{6458:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var o=i(4848),r=i(8453);const s={layout:"docs",title:"Layers",section:"chisel3"},a="Layers",l={id:"explanations/layers",title:"Layers",description:"Layers are used to describe functionality of a Chisel circuit or module that a",source:"@site/docs/explanations/layers.md",sourceDirName:"explanations",slug:"/explanations/layers",permalink:"/docs/explanations/layers",draft:!1,unlisted:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/layers.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Layers",section:"chisel3"},sidebar:"chiselSidebar",previous:{title:"Intrinsics",permalink:"/docs/explanations/intrinsics"},next:{title:"Memories",permalink:"/docs/explanations/memories"}},t={},c=[{value:"Conventions",id:"conventions",level:2},{value:"Built-in Layers and User-defined Layers",id:"built-in-layers-and-user-defined-layers",level:2},{value:"Examples",id:"examples",level:2},{value:"Design Verification Example",id:"design-verification-example",level:3},{value:"Implementation Notes",id:"implementation-notes",level:4},{value:"Verilog Output",id:"verilog-output",level:4}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"layers",children:"Layers"})}),"\n",(0,o.jsxs)(n.p,{children:["Layers are used to describe functionality of a Chisel circuit or module that a\nuser would like to ",(0,o.jsx)(n.em,{children:"optionally"})," include at Verilog elaboration time.  This\nfeature is intended to be used to optionally include verification or debug logic\nthat a user does not want to always have present."]}),"\n",(0,o.jsx)(n.p,{children:"Each layer is broken into two pieces:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["A layer ",(0,o.jsx)(n.em,{children:"declaration"})]}),"\n",(0,o.jsxs)(n.li,{children:["One or more ",(0,o.jsx)(n.em,{children:"layer blocks"})," inside modules in the circuit"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["There are two kinds of layers, each kind is lowered to verilog under a different\n",(0,o.jsx)(n.em,{children:"convention"}),". The kinds of layers are:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:'"Extract" Layers: layers whose blocks are lowered to bound-in modules, and'}),"\n",(0,o.jsx)(n.li,{children:'"Inline" Layers: layers whose blocks are lowered to ifdefs macros.'}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["To declare a layer, create a singleton ",(0,o.jsx)(n.code,{children:"object"})," in scala that extends the"]}),"\n",(0,o.jsxs)(n.p,{children:["extend the abstract class ",(0,o.jsx)(n.code,{children:"chisel3.layer.Layer"}),", passing into the layer\nconstructor either ",(0,o.jsx)(n.code,{children:"chisel3.layer.LayerConfig.Extract()"}),' for an "extract" layer,\nor ',(0,o.jsx)(n.code,{children:"chisel3.layer.LayerConfig.Inline"}),' for "inline" layers.']}),"\n",(0,o.jsxs)(n.p,{children:["Layers may be nested. To declare a nested layer, extend the\n",(0,o.jsx)(n.code,{children:"chisel3.layer.Layer"})," abstract class inside another declaration."]}),"\n",(0,o.jsx)(n.p,{children:"The following example declares four layers:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import chisel3.layer.{Layer, LayerConfig}\n\nobject A extends Layer(LayerConfig.Extract()) {\n  object B extends Layer(LayerConfig.Extract()) {\n    object C extends Layer(LayerConfig.Extract())\n  }\n  object D extends Layer(LayerConfig.Extract())\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.em,{children:"layer block"}),", associated with a layer, adds optional functionality to a\nmodule that is enabled if that layer is enabled.  Each layer block must refer to\na pre-declared layer.  Layer block nesting must match the nesting of declared\nlayers."]}),"\n",(0,o.jsxs)(n.p,{children:["To define a layer block, use the ",(0,o.jsx)(n.code,{children:"chisel3.layer.block"})," inside a Chisel module.\nAn layer block may use any Chisel or Scala value visible to its Scala lexical\nscope."]}),"\n",(0,o.jsxs)(n.p,{children:["The following example defines layer blocks inside module ",(0,o.jsx)(n.code,{children:"Foo"})," and declares\nwires which are connected to values captured from visible lexical scope:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import chisel3._\nimport chisel3.layer.block\n\nclass Foo extends RawModule {\n  val port = IO(Input(Bool()))\n\n  block(A) {\n    val a = WireInit(port)\n    block(A.B) {\n      val b = WireInit(a)\n      block(A.B.C) {\n        val c = WireInit(b)\n      }\n    }\n    block(A.D) {\n      val d = WireInit(port ^ a)\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"conventions",children:"Conventions"}),"\n",(0,o.jsxs)(n.p,{children:["Currently, there is only one supported convention, ",(0,o.jsx)(n.code,{children:"Bind"}),".  This will cause layer\nblocks to be lowered to Verilog modules that are instantiated via the\nSystemVerilog ",(0,o.jsx)(n.code,{children:"bind"})," mechanism.  The lowering to Verilog of layer blocks avoids\nillegal nested usage of ",(0,o.jsx)(n.code,{children:"bind"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"More conventions may be supported in the future."}),"\n",(0,o.jsx)(n.h2,{id:"built-in-layers-and-user-defined-layers",children:"Built-in Layers and User-defined Layers"}),"\n",(0,o.jsx)(n.p,{children:"Chisel provides several built-in layers.  These are shown below with their full\nScala paths:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"`chisel3.layers.Verification`\n\u251c\u2500\u2500 `chisel3.layers.Verification.Assert`\n\u251c\u2500\u2500 `chisel3.layers.Verification.Assume`\n\u2514\u2500\u2500 `chisel3.layers.Verification.Cover`\n"})}),"\n",(0,o.jsxs)(n.p,{children:["These built-in layers are dual purpose.  First, they are layers that match\ncommon use cases for sequestering verification code.  The ",(0,o.jsx)(n.code,{children:"Verification"})," layer\nis for common verification collateral.  The ",(0,o.jsx)(n.code,{children:"Assert"}),", ",(0,o.jsx)(n.code,{children:"Assume"}),", and ",(0,o.jsx)(n.code,{children:"Cover"}),"\nlayers are for, respectively, assertions, assumptions, and cover statements.\nSecond, the Chisel standard library uses them for some of its APIs."]}),"\n",(0,o.jsx)(n.p,{children:"For predictability of output, these layers will always be show up in the FIRRTL\nthat Chisel emits."}),"\n",(0,o.jsxs)(n.p,{children:["A user is free to define their own layers, as shown previously with layer ",(0,o.jsx)(n.code,{children:"A"}),",\n",(0,o.jsx)(n.code,{children:"A.B"}),", etc.  User-defined layers are only emitted into FIRRTL if they have layer\nblock users.  Layers can be unconditionally emitted using the\n",(0,o.jsx)(n.code,{children:"chisel3.layer.addLayer"})," API."]}),"\n",(0,o.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,o.jsx)(n.h3,{id:"design-verification-example",children:"Design Verification Example"}),"\n",(0,o.jsx)(n.p,{children:"Consider a use case where a design or design verification engineer would like to\nadd some asserts and debug prints to a module.  The logic necessary for the\nasserts and debug prints requires additional computation.  All of this code\nshould selectively included at Verilog elaboration time (not at Chisel\nelaboration time).  The engineer can use three layers to do this."}),"\n",(0,o.jsx)(n.p,{children:"There are three layers used in this example:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["The built-in ",(0,o.jsx)(n.code,{children:"Verification"})," layer"]}),"\n",(0,o.jsxs)(n.li,{children:["The built-in ",(0,o.jsx)(n.code,{children:"Assert"})," layer which is nested under the built-in ",(0,o.jsx)(n.code,{children:"Verification"}),"\nlayer"]}),"\n",(0,o.jsxs)(n.li,{children:["A user-defined ",(0,o.jsx)(n.code,{children:"Debug"})," layer which is also nested under the built-in\n",(0,o.jsx)(n.code,{children:"Verification"})," layer"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Verification"})," layer can be used to store common logic used by both the\n",(0,o.jsx)(n.code,{children:"Assert"})," and ",(0,o.jsx)(n.code,{children:"Debug"})," layers.  The latter two layers allow for separation of,\nrespectively, assertions from prints."]}),"\n",(0,o.jsx)(n.p,{children:"One way to write this in Scala is the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import chisel3._\nimport chisel3.layer.{Layer, LayerConfig, block}\nimport chisel3.layers.Verification\n\n// User-defined layers are declared here.  Built-in layers do not need to be declared.\nobject UserDefined {\n  // Define an implicit val `root` of type `Layer` to cause layers which can see\n  // this to use `root` as their parent layer.  This allows us to nest the\n  // user-defined `Debug` layer under the built-in `Verification` layer.\n  implicit val root: Layer = Verification\n  object Debug extends Layer(LayerConfig.Extract())\n}\n\nclass Foo extends Module {\n  val a = IO(Input(UInt(32.W)))\n  val b = IO(Output(UInt(32.W)))\n\n  b := a +% 1.U\n\n  // This adds a `Verification` layer block inside Foo.\n  block(Verification) {\n\n    // Some common logic added here.  The input port `a` is "captured" and\n    // used here.\n    val a_d0 = RegNext(a)\n\n    // This adds an `Assert` layer block.\n    block(Verification.Assert) {\n      chisel3.assert(a >= a_d0, "a must always increment")\n    }\n\n    // This adds a `Debug` layer block.\n    block(UserDefined.Debug) {\n      printf("a: %x, a_d0: %x", a, a_d0)\n    }\n\n  }\n\n}\n\n'})}),"\n",(0,o.jsx)(n.p,{children:"After compilation, this will produce three layer include files with the\nfollowing filenames.  One file is created for each layer:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"layers_Foo_Verification.sv"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"layers_Foo_Verification_Assert.sv"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"layers_Foo_Verification_Debug.sv"})}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["A user can then include any combination of these files in their design to\ninclude the optional functionality describe by the ",(0,o.jsx)(n.code,{children:"Verification"}),", ",(0,o.jsx)(n.code,{children:"Assert"}),", or\n",(0,o.jsx)(n.code,{children:"Debug"})," layers.  The ",(0,o.jsx)(n.code,{children:"Assert"})," and ",(0,o.jsx)(n.code,{children:"Debug"})," bind files automatically include the\n",(0,o.jsx)(n.code,{children:"Verification"})," bind file for the user."]}),"\n",(0,o.jsx)(n.h4,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Note: the names of the modules and the names of any files that contain these\nmodules are FIRRTL compiler implementation defined!  The only guarantee is the\nexistence of the three layer include files.  The information in this subsection\nis for informational purposes to aid understanding."})}),"\n",(0,o.jsxs)(n.p,{children:["In implementation, a FIRRTL compiler creates four Verilog modules for the\ncircuit above (one for ",(0,o.jsx)(n.code,{children:"Foo"})," and one for each layer block in module ",(0,o.jsx)(n.code,{children:"Foo"}),"):"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"Foo"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"Foo_Verification"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"Foo_Verification_Assert"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"Foo_Verification_Cover"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"Foo_Verification_Debug"})}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["These will typically be created in separate files with names that match the\nmodules, i.e., ",(0,o.jsx)(n.code,{children:"Foo.sv"}),", ",(0,o.jsx)(n.code,{children:"Foo_Verification.sv"}),", ",(0,o.jsx)(n.code,{children:"Foo_Verification_Assert.sv"}),",\n",(0,o.jsx)(n.code,{children:"Foo_Verification_Debug.sv"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The ports of each module created from a layer block will be automatically\ndetermined based on what that layer block captured from outside the layer block.\nIn the example above, the ",(0,o.jsx)(n.code,{children:"Verification"})," layer block captured port ",(0,o.jsx)(n.code,{children:"a"}),".  Both\nthe ",(0,o.jsx)(n.code,{children:"Assert"})," and ",(0,o.jsx)(n.code,{children:"Debug"})," layer blocks captured ",(0,o.jsx)(n.code,{children:"a"})," and ",(0,o.jsx)(n.code,{children:"a_d0"}),".  Layer blocks may\nbe optimized to remove/add ports or to move logic into a layer block."]}),"\n",(0,o.jsx)(n.h4,{id:"verilog-output",children:"Verilog Output"}),"\n",(0,o.jsx)(n.p,{children:"The complete Verilog output for this example is reproduced below:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-verilog",children:'// Generated by CIRCT firtool-1.91.0\nmodule Foo(\n  input         clock,\n                reset,\n  input  [31:0] a,\n  output [31:0] b\n);\n\n  assign b = a + 32\'h1;\nendmodule\n\n\n// ----- 8< ----- FILE "Verification/Cover/layers-Foo-Verification-Cover.sv" ----- 8< -----\n\n// Generated by CIRCT firtool-1.91.0\n`include "Verification/layers-Foo-Verification.sv"\n`ifndef layers_Foo_Verification_Cover\n`define layers_Foo_Verification_Cover\n`endif // layers_Foo_Verification_Cover\n\n// ----- 8< ----- FILE "Verification/Assume/layers-Foo-Verification-Assume.sv" ----- 8< -----\n\n// Generated by CIRCT firtool-1.91.0\n`include "Verification/layers-Foo-Verification.sv"\n`ifndef layers_Foo_Verification_Assume\n`define layers_Foo_Verification_Assume\n`endif // layers_Foo_Verification_Assume\n\n// ----- 8< ----- FILE "Verification/Debug/layers-Foo-Verification-Debug.sv" ----- 8< -----\n\n// Generated by CIRCT firtool-1.91.0\n`include "Verification/layers-Foo-Verification.sv"\n`ifndef layers_Foo_Verification_Debug\n`define layers_Foo_Verification_Debug\nbind Foo Foo_Verification_Debug verification_debug (\n  .reset (reset),\n  .clock (Foo.verification.clock_probe_0),\n  .a     (Foo.verification.a_probe_0),\n  .a_d0  (Foo.verification.a_d0_probe_0)\n);\n`endif // layers_Foo_Verification_Debug\n\n// ----- 8< ----- FILE "Verification/Assert/layers-Foo-Verification-Assert.sv" ----- 8< -----\n\n// Generated by CIRCT firtool-1.91.0\n`include "Verification/layers-Foo-Verification.sv"\n`ifndef layers_Foo_Verification_Assert\n`define layers_Foo_Verification_Assert\nbind Foo Foo_Verification_Assert verification_assert (\n  .a     (Foo.verification.a_probe),\n  .a_d0  (Foo.verification.a_d0_probe),\n  .reset (reset),\n  .clock (Foo.verification.clock_probe)\n);\n`endif // layers_Foo_Verification_Assert\n\n// ----- 8< ----- FILE "Verification/layers-Foo-Verification.sv" ----- 8< -----\n\n// Generated by CIRCT firtool-1.91.0\n`ifndef layers_Foo_Verification\n`define layers_Foo_Verification\nbind Foo Foo_Verification verification (\n  .clock (clock),\n  .a     (a)\n);\n`endif // layers_Foo_Verification\n\n// ----- 8< ----- FILE "Verification/Assert/Foo_Verification_Assert.sv" ----- 8< -----\n\n// Generated by CIRCT firtool-1.91.0\n\n// Users can define \'STOP_COND\' to add an extra gate to stop conditions.\n`ifndef STOP_COND_\n  `ifdef STOP_COND\n    `define STOP_COND_ (`STOP_COND)\n  `else  // STOP_COND\n    `define STOP_COND_ 1\n  `endif // STOP_COND\n`endif // not def STOP_COND_\n\n// Users can define \'ASSERT_VERBOSE_COND\' to add an extra gate to assert error printing.\n`ifndef ASSERT_VERBOSE_COND_\n  `ifdef ASSERT_VERBOSE_COND\n    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\n  `else  // ASSERT_VERBOSE_COND\n    `define ASSERT_VERBOSE_COND_ 1\n  `endif // ASSERT_VERBOSE_COND\n`endif // not def ASSERT_VERBOSE_COND_\nmodule Foo_Verification_Assert(\n  input [31:0] a,\n               a_d0,\n  input        reset,\n               clock\n);\n\n  `ifndef SYNTHESIS\n    always @(posedge clock) begin\n      if (~reset & a < a_d0) begin\n        if (`ASSERT_VERBOSE_COND_)\n          $error("Assertion failed: a must always increment\\n");\n        if (`STOP_COND_)\n          $fatal;\n      end\n    end // always @(posedge)\n  `endif // not def SYNTHESIS\nendmodule\n\n\n// ----- 8< ----- FILE "Verification/Debug/Foo_Verification_Debug.sv" ----- 8< -----\n\n// Generated by CIRCT firtool-1.91.0\n\n// Users can define \'PRINTF_COND\' to add an extra gate to prints.\n`ifndef PRINTF_COND_\n  `ifdef PRINTF_COND\n    `define PRINTF_COND_ (`PRINTF_COND)\n  `else  // PRINTF_COND\n    `define PRINTF_COND_ 1\n  `endif // PRINTF_COND\n`endif // not def PRINTF_COND_\nmodule Foo_Verification_Debug(\n  input        reset,\n               clock,\n  input [31:0] a,\n               a_d0\n);\n\n  `ifndef SYNTHESIS\n    always @(posedge clock) begin\n      if ((`PRINTF_COND_) & ~reset)\n        $fwrite(32\'h80000002, "a: %x, a_d0: %x", a, a_d0);\n    end // always @(posedge)\n  `endif // not def SYNTHESIS\nendmodule\n\n\n// ----- 8< ----- FILE "Verification/Foo_Verification.sv" ----- 8< -----\n\n// Generated by CIRCT firtool-1.91.0\nmodule Foo_Verification(\n  input        clock,\n  input [31:0] a\n);\n\n  wire        clock_probe = clock;\n  wire [31:0] a_probe = a;\n  wire [31:0] a_probe_0 = a;\n  wire        clock_probe_0 = clock;\n  reg  [31:0] a_d0;\n  wire [31:0] a_d0_probe = a_d0;\n  wire [31:0] a_d0_probe_0 = a_d0;\n  always @(posedge clock)\n    a_d0 <= a;\nendmodule\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var o=i(6540);const r={},s=o.createContext(r);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);