// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Annotations",
      "url": "/chisel3/docs/explanations/annotations.html",
      "content": "Annotations Annotations are metadata containers associated with zero or more “things” in a FIRRTL circuit. Commonly, Annotations are used to communicate information from Chisel to a specific, custom FIRRTL Transform. In this way Annotations can be viewed as the “arguments” that a specific Transform consumes. This article focuses on the approach to building a basic library that contains Annotations and Transforms. Imports We need a few basic imports to reference the components we need. import chisel3._ import chisel3.experimental.{annotate, ChiselAnnotation, RunFirrtlTransform} import chisel3.internal.InstanceId import firrtl._ import firrtl.annotations.{Annotation, SingleTargetAnnotation} import firrtl.annotations.{CircuitTarget, ModuleTarget, InstanceTarget, ReferenceTarget, Target} import scala.annotation.nowarn Define an Annotation and a Transform First, define an Annotation that contains a string associated with a Target thing in the Chisel circuit. This InfoAnnotation extends SingleTargetAnnotation, an Annotation associated with one thing in a FIRRTL circuit: /** An annotation that contains some string information */ case class InfoAnnotation(target: Target, info: String) extends SingleTargetAnnotation[Target] { def duplicate(newTarget: Target) = this.copy(target = newTarget) } Second, define a Transform that consumes this InfoAnnotation. This InfoTransform simply reads all annotations, prints any InfoAnnotations it finds, and removes them. /** A transform that reads InfoAnnotations and prints information about them */ class InfoTransform() extends Transform with DependencyAPIMigration { override def prerequisites = firrtl.stage.Forms.HighForm override def execute(state: CircuitState): CircuitState = { println(\"Starting transform 'IdentityTransform'\") val annotationsx = state.annotations.flatMap{ case InfoAnnotation(a: CircuitTarget, info) =&gt; println(s\" - Circuit '${a.serialize}' annotated with '$info'\") None case InfoAnnotation(a: ModuleTarget, info) =&gt; println(s\" - Module '${a.serialize}' annotated with '$info'\") None case InfoAnnotation(a: InstanceTarget, info) =&gt; println(s\" - Instance '${a.serialize}' annotated with '$info'\") None case InfoAnnotation(a: ReferenceTarget, info) =&gt; println(s\" - Component '${a.serialize} annotated with '$info''\") None case a =&gt; Some(a) } state.copy(annotations = annotationsx) } } Note: inputForm and outputForm will be deprecated in favor of a new dependency API that allows transforms to specify their dependencies more specifically than with circuit forms. Full backwards compatibility for inputForm and outputForm will be maintained, however. Create a Chisel API/Annotator Now, define a Chisel API to annotate Chisel things with this InfoAnnotation. This is commonly referred to as an “annotator”. Here, define an object, InfoAnnotator with a method info that generates InfoAnnotations. This uses the chisel3.experimental.annotate passed an anonymous ChiselAnnotation object. The need for this ChiselAnnotation (which is different from an actual FIRRTL Annotation) is that no FIRRTL circuit exists at the time the info method is called. This is delaying the generation of the InfoAnnotation until the full circuit is available. This annotator also mixes in the RunFirrtlTransform trait (abstract in the transformClass method) because this annotator, whenever used, should result in the FIRRTL compiler running the custom InfoTransform. @nowarn(\"msg=InstanceId\") object InfoAnnotator { def info(component: InstanceId, info: String): Unit = { annotate(new ChiselAnnotation with RunFirrtlTransform { def toFirrtl: Annotation = InfoAnnotation(component.toTarget, info) def transformClass = classOf[InfoTransform] }) } } Note: there are a number of different approaches to writing an annotator. You could use a trait that you mix into a Module, an object (like is done above), or any other software approach. The specific choice of how you implement this is up to you! Using the Chisel API Now, we can use the method InfoAnnotation.info to create annotations that associate strings with specific things in a FIRRTL circuit. Below is a Chisel Module, ModC, where both the actual module is annotated as well as an output. class ModC(widthC: Int) extends Module { val io = IO(new Bundle { val in = Input(UInt(widthC.W)) val out = Output(UInt(widthC.W)) }) io.out := io.in InfoAnnotator.info(this, s\"ModC($widthC)\") InfoAnnotator.info(io.out, s\"ModC(ignore param)\") } Running the Compilation Compiling this circuit to Verilog will then result in the InfoTransform running and the added printlns showing information about the components annotated. import chisel3.stage.ChiselGeneratorAnnotation import circt.stage.ChiselStage (new ChiselStage).execute(Array.empty, Seq(ChiselGeneratorAnnotation(() =&gt; new ModC(4))))"
    } ,    
    {
      "title": "Appendix",
      "url": "/chisel3/docs/appendix/appendix.html",
      "content": "Appendix This section covers some less-common Chisel topics. Differences between Chisel3 and Chisel2 Experimental Features Upgrading from Scala 2.11 Upgrading from Chisel 3.4 Versioning"
    } ,    
    {
      "title": "Blackboxes",
      "url": "/chisel3/docs/explanations/blackboxes.html",
      "content": "BlackBoxes Chisel BlackBoxes are used to instantiate externally defined modules. This construct is useful for hardware constructs that cannot be described in Chisel and for connecting to FPGA or other IP not defined in Chisel. Modules defined as a BlackBox will be instantiated in the generated Verilog, but no code will be generated to define the behavior of module. Unlike Module, BlackBox has no implicit clock and reset. BlackBox’s clock and reset ports must be explicitly declared and connected to input signals. Ports declared in the IO Bundle will be generated with the requested name (ie. no preceding io_). Parameterization Verilog parameters can be passed as an argument to the BlackBox constructor. For example, consider instantiating a Xilinx differential clock buffer (IBUFDS) in a Chisel design: import chisel3._ import chisel3.util._ import chisel3.experimental._ // To enable experimental features class IBUFDS extends BlackBox(Map(\"DIFF_TERM\" -&gt; \"TRUE\", \"IOSTANDARD\" -&gt; \"DEFAULT\")) { val io = IO(new Bundle { val O = Output(Clock()) val I = Input(Clock()) val IB = Input(Clock()) }) } class Top extends Module { val io = IO(new Bundle {}) val ibufds = Module(new IBUFDS) // connecting one of IBUFDS's input clock ports to Top's clock signal ibufds.io.I := clock } In the Chisel-generated Verilog code, IBUFDS will be instantiated as: IBUFDS #(.DIFF_TERM(\"TRUE\"), .IOSTANDARD(\"DEFAULT\")) ibufds ( .IB(ibufds_IB), .I(ibufds_I), .O(ibufds_O) ); Providing Implementations for Blackboxes Chisel provides the following ways of delivering the code underlying the blackbox. Consider the following blackbox that adds two real numbers together. The numbers are represented in chisel3 as 64-bit unsigned integers. import chisel3._ class BlackBoxRealAdd extends BlackBox { val io = IO(new Bundle { val in1 = Input(UInt(64.W)) val in2 = Input(UInt(64.W)) val out = Output(UInt(64.W)) }) } The implementation is described by the following verilog module BlackBoxRealAdd( input [63:0] in1, input [63:0] in2, output reg [63:0] out ); always @* begin out &lt;= $realtobits($bitstoreal(in1) + $bitstoreal(in2)); end endmodule Blackboxes with Verilog in a Resource File In order to deliver the verilog snippet above to the backend simulator, chisel3 provides the following tools based on the chisel/firrtl annotation system. Add the trait HasBlackBoxResource to the declaration, and then call a function in the body to say where the system can find the verilog. The Module now looks like import chisel3._ import chisel3.util.HasBlackBoxResource class BlackBoxRealAdd extends BlackBox with HasBlackBoxResource { val io = IO(new Bundle { val in1 = Input(UInt(64.W)) val in2 = Input(UInt(64.W)) val out = Output(UInt(64.W)) }) addResource(\"/real_math.v\") } The verilog snippet above gets put into a resource file names real_math.v. What is a resource file? It comes from a java convention of keeping files in a project that are automatically included in library distributions. In a typical chisel3 project, see chisel-template, this would be a directory in the source hierarchy: src/main/resources/real_math.v. Blackboxes with In-line Verilog It is also possible to place this verilog directly in the scala source. Instead of HasBlackBoxResource use HasBlackBoxInline and instead of setResource use setInline. The code will look like this. import chisel3._ import chisel3.util.HasBlackBoxInline class BlackBoxRealAdd extends BlackBox with HasBlackBoxInline { val io = IO(new Bundle { val in1 = Input(UInt(64.W)) val in2 = Input(UInt(64.W)) val out = Output(UInt(64.W)) }) setInline(\"BlackBoxRealAdd.v\", \"\"\"module BlackBoxRealAdd( | input [15:0] in1, | input [15:0] in2, | output [15:0] out |); |always @* begin | out &lt;= $realtobits($bitstoreal(in1) + $bitstoreal(in2)); |end |endmodule \"\"\".stripMargin) } This technique will copy the inline verilog into the target directory under the name BlackBoxRealAdd.v Under the Hood This mechanism of delivering verilog content to the testing backends is implemented via chisel/firrtl annotations. The two methods, inline and resource, are two kinds of annotations that are created via the setInline and setResource methods calls. Those annotations are passed through to the chisel-testers which in turn passes them on to firrtl. The default firrtl verilog compilers have a pass that detects the annotations and moves the files or inline test into the build directory. For each unique file added, the transform adds a line to a file black_box_verilog_files.f, this file is added to the command line constructed for verilator or vcs to inform them where to look. The dsptools project is a good example of using this feature to build a real number simulation tester based on black boxes. The interpreter Note that the FIRRTL Interpreter is deprecated. Please use Treadle, the new Chisel/FIRRTL simulator The firrtl interpreter uses a separate system that allows users to construct scala implementations of the black boxes. The scala implementation code built into a BlackBoxFactory which is passed down to the interpreter by the execution harness. The interpreter is a scala simulation tester. Once again the dsptools project uses this mechanism and is a good place to look at it. It is planned that the BlackBoxFactory will be replaced by integration with the annotation based blackbox methods stuff soon."
    } ,    
    {
      "title": "Bundles and Vecs",
      "url": "/chisel3/docs/explanations/bundles-and-vecs.html",
      "content": "Bundles and Vecs Bundle and Vec are classes that allow the user to expand the set of Chisel datatypes with aggregates of other types. Bundles group together several named fields of potentially different types into a coherent unit, much like a struct in C. Users define their own bundles by defining a class as a subclass of Bundle. import chisel3._ class MyFloat extends Bundle { val sign = Bool() val exponent = UInt(8.W) val significand = UInt(23.W) } class ModuleWithFloatWire extends RawModule { val x = Wire(new MyFloat) val xs = x.sign } You can create literal Bundles using the experimental Bundle Literals feature. Scala convention is to name classes using UpperCamelCase, and we suggest you follow that convention in your Chisel code. Vecs create an indexable vector of elements, and are constructed as follows: class ModuleWithVec extends RawModule { // Vector of 5 23-bit signed integers. val myVec = Wire(Vec(5, SInt(23.W))) // Connect to one element of vector. val reg3 = myVec(3) } (Note that we specify the number followed by the type of the Vec elements. We also specifiy the width of the SInt) The set of primitive classes (SInt, UInt, and Bool) plus the aggregate classes (Bundles and Vecs) all inherit from a common superclass, Data. Every object that ultimately inherits from Data can be represented as a bit vector in a hardware design. Bundles and Vecs can be arbitrarily nested to build complex data structures: class BigBundle extends Bundle { // Vector of 5 23-bit signed integers. val myVec = Vec(5, SInt(23.W)) val flag = Bool() // Previously defined bundle. val f = new MyFloat } Note that the builtin Chisel primitive and aggregate classes do not require the new when creating an instance, whereas new user datatypes will. A Scala apply constructor can be defined so that a user datatype also does not require new, as described in Function Constructor. Flipping Bundles The Flipped() function recursively flips all elements in a Bundle/Record. This is very useful for building bidirectional interfaces that connect to each other (e.g. Decoupled). See below for an example. class ABBundle extends Bundle { val a = Input(Bool()) val b = Output(Bool()) } class MyFlippedModule extends RawModule { // Normal instantiation of the bundle // 'a' is an Input and 'b' is an Output val normalBundle = IO(new ABBundle) normalBundle.b := normalBundle.a // Flipped recursively flips the direction of all Bundle fields // Now 'a' is an Output and 'b' is an Input val flippedBundle = IO(Flipped(new ABBundle)) flippedBundle.a := flippedBundle.b } This generates the following Verilog: // Generated by CIRCT sifive/1/20/0 module MyFlippedModule( // &lt;stdin&gt;:3:10 input normalBundle_a, flippedBundle_b, output normalBundle_b, flippedBundle_a); assign normalBundle_b = normalBundle_a; // &lt;stdin&gt;:3:10 assign flippedBundle_a = flippedBundle_b; // &lt;stdin&gt;:3:10 endmodule MixedVec (Chisel 3.2+) All elements of a Vec must be of the same type. If we want to create a Vec where the elements have different types, we can use a MixedVec: import chisel3.util.MixedVec class ModuleMixedVec extends Module { val io = IO(new Bundle { val x = Input(UInt(3.W)) val y = Input(UInt(10.W)) val vec = Output(MixedVec(UInt(3.W), UInt(10.W))) }) io.vec(0) := io.x io.vec(1) := io.y } We can also programmatically create the types in a MixedVec: class ModuleProgrammaticMixedVec(x: Int, y: Int) extends Module { val io = IO(new Bundle { val vec = Input(MixedVec((x to y) map { i =&gt; UInt(i.W) })) // ... }) // ...rest of the module goes here... } A note on cloneType (For Chisel &lt; 3.5) NOTE: This section only applies to Chisel before Chisel 3.5. As of Chisel 3.5, Bundles should not override def cloneType, as this is a compiler error when using the chisel3 compiler plugin for inferring cloneType. Since Chisel is built on top of Scala and the JVM, it needs to know how to construct copies of Bundles for various purposes (creating wires, IOs, etc). If you have a parametrized Bundle and Chisel can’t automatically figure out how to clone it, you will need to create a custom cloneType method in your bundle. In the vast majority of cases, this is not required as Chisel can figure out how to clone most Bundles automatically: class MyCloneTypeBundle(val bitwidth: Int) extends Bundle { val field = UInt(bitwidth.W) // ... } The only caveat is if you are passing something of type Data as a “generator” parameter, in which case you should make it a private val, and define a cloneType method with override def cloneType = (new YourBundleHere(...)).asInstanceOf[this.type]. For example, consider the following Bundle. Because its gen variable is not a private val, the user has to explicitly define the cloneType method: import chisel3.util.{Decoupled, Irrevocable} class RegisterWriteIOExplicitCloneType[T &lt;: Data](gen: T) extends Bundle { val request = Flipped(Decoupled(gen)) val response = Irrevocable(Bool()) override def cloneType = new RegisterWriteIOExplicitCloneType(gen).asInstanceOf[this.type] } We can make this this infer cloneType by making gen private since it is a “type parameter”: import chisel3.util.{Decoupled, Irrevocable} class RegisterWriteIO[T &lt;: Data](private val gen: T) extends Bundle { val request = Flipped(Decoupled(gen)) val response = Irrevocable(Bool()) }"
    } ,    
    {
      "title": "Enumerations",
      "url": "/chisel3/docs/explanations/chisel-enum.html",
      "content": "ChiselEnum The ChiselEnum type can be used to reduce the chance of error when encoding mux selectors, opcodes, and functional unit operations. In contrast with Chisel.util.Enum, ChiselEnum are subclasses of Data, which means that they can be used to define fields in Bundles, including in IOs. Functionality and Examples // Imports used in the following examples import chisel3._ import chisel3.util._ import circt.stage.ChiselStage Below we see ChiselEnum being used as mux select for a RISC-V core. While wrapping the object in a package is not required, it is highly recommended as it allows for the type to be used in multiple files more easily. // package CPUTypes { object AluMux1Sel extends ChiselEnum { val selectRS1, selectPC = Value } // We can see the mapping by printing each Value AluMux1Sel.all.foreach(println) // AluMux1Sel(0=selectRS1) // AluMux1Sel(1=selectPC) Here we see a mux using the AluMux1Sel to select between different inputs. import AluMux1Sel._ class AluMux1Bundle extends Bundle { val aluMux1Sel = Input(AluMux1Sel()) val rs1Out = Input(Bits(32.W)) val pcOut = Input(Bits(32.W)) val aluMux1Out = Output(Bits(32.W)) } class AluMux1File extends Module { val io = IO(new AluMux1Bundle) // Default value for aluMux1Out io.aluMux1Out := 0.U switch (io.aluMux1Sel) { is (selectRS1) { io.aluMux1Out := io.rs1Out } is (selectPC) { io.aluMux1Out := io.pcOut } } } // Generated by CIRCT sifive/1/20/0 module AluMux1File( // &lt;stdin&gt;:3:10 input clock, reset, io_aluMux1Sel, input [31:0] io_rs1Out, io_pcOut, output [31:0] io_aluMux1Out); assign io_aluMux1Out = io_aluMux1Sel ? io_pcOut : io_rs1Out; // &lt;stdin&gt;:3:10, chisel-enum.md:68:26, :70:21 endmodule ChiselEnum also allows for the user to directly set the Values by passing an UInt to Value(...) as shown below. Note that the magnitude of each Value must be strictly greater than the one before it. object Opcode extends ChiselEnum { val load = Value(0x03.U) // i \"load\" -&gt; 000_0011 val imm = Value(0x13.U) // i \"imm\" -&gt; 001_0011 val auipc = Value(0x17.U) // u \"auipc\" -&gt; 001_0111 val store = Value(0x23.U) // s \"store\" -&gt; 010_0011 val reg = Value(0x33.U) // r \"reg\" -&gt; 011_0011 val lui = Value(0x37.U) // u \"lui\" -&gt; 011_0111 val br = Value(0x63.U) // b \"br\" -&gt; 110_0011 val jalr = Value(0x67.U) // i \"jalr\" -&gt; 110_0111 val jal = Value(0x6F.U) // j \"jal\" -&gt; 110_1111 } The user can ‘jump’ to a value and continue incrementing by passing a start point then using a regular Value definition. object BranchFunct3 extends ChiselEnum { val beq, bne = Value val blt = Value(4.U) val bge, bltu, bgeu = Value } // We can see the mapping by printing each Value BranchFunct3.all.foreach(println) // BranchFunct3(0=beq) // BranchFunct3(1=bne) // BranchFunct3(4=blt) // BranchFunct3(5=bge) // BranchFunct3(6=bltu) // BranchFunct3(7=bgeu) Casting You can cast an enum to a UInt using .asUInt: class ToUInt extends RawModule { val in = IO(Input(Opcode())) val out = IO(Output(UInt())) out := in.asUInt } You can cast from a UInt to an enum by passing the UInt to the apply method of the ChiselEnum object: class FromUInt extends Module { val in = IO(Input(UInt(7.W))) val out = IO(Output(Opcode())) out := Opcode(in) } However, if you cast from a UInt to an Enum type when there are undefined states in the Enum values that the UInt could hit, you will see a warning like the following: [\u001b[33mwarn\u001b[0m] chisel-enum.md:136:16: Casting non-literal UInt to repl.MdocSession$MdocApp$Opcode. You can use repl.MdocSession$MdocApp$Opcode.safe to cast without this warning. [\u001b[33mwarn\u001b[0m] There were \u001b[33m1 warning(s)\u001b[0m during hardware elaboration. (Note that the name of the Enum is ugly as an artifact of our documentation generation flow, it will be cleaner in normal use). You can avoid this warning by using the .safe factory method which returns the cast Enum in addition to a Bool indicating if the Enum is in a valid state: class SafeFromUInt extends Module { val in = IO(Input(UInt(7.W))) val out = IO(Output(Opcode())) val (value, valid) = Opcode.safe(in) assert(valid, \"Enum state must be valid, got %d!\", in) out := value } Now there will be no warning: You can also suppress the warning by using suppressEnumCastWarning. This is primarily used for casting from [[UInt]] to a Bundle type that contains an Enum, where the [[UInt]] is known to be valid for the Bundle type. class MyBundle extends Bundle { val addr = UInt(8.W) val op = Opcode() } class SuppressedFromUInt extends Module { val in = IO(Input(UInt(15.W))) val out = IO(Output(new MyBundle())) suppressEnumCastWarning { out := in.asTypeOf(new MyBundle) } } Testing The Type of the enums values is &lt;ChiselEnum Object&gt;.Type which can be useful for passing the values as parameters to a function (or any other time a type annotation is needed). Calling .litValue on an enum value will return the integer value of that object as a BigInt. def expectedSel(sel: AluMux1Sel.Type): Boolean = sel match { case AluMux1Sel.selectRS1 =&gt; (sel.litValue == 0) case AluMux1Sel.selectPC =&gt; (sel.litValue == 1) case _ =&gt; false } The enum value type also defines some convenience methods for working with ChiselEnum values. For example, continuing with the RISC-V opcode example, one could easily create hardware signal that is only asserted on LOAD/STORE operations (when the enum value is equal to Opcode.load or Opcode.store) using the .isOneOf method: class LoadStoreExample extends Module { val io = IO(new Bundle { val opcode = Input(Opcode()) val load_or_store = Output(Bool()) }) io.load_or_store := io.opcode.isOneOf(Opcode.load, Opcode.store) } Some additional useful methods defined on the ChiselEnum object are: .all: returns the enum values within the enumeration .getWidth: returns the width of the hardware type Workarounds As of Chisel v3.4.3 (1 July 2020), the width of the values is always inferred. To work around this, you can add an extra Value that forces the width that is desired. This is shown in the example below, where we add a field ukn to force the width to be 3 bits wide: object StoreFunct3 extends ChiselEnum { val sb, sh, sw = Value val ukn = Value(7.U) } // We can see the mapping by printing each Value StoreFunct3.all.foreach(println) // StoreFunct3(0=sb) // StoreFunct3(1=sh) // StoreFunct3(2=sw) // StoreFunct3(7=ukn) Signed values are not supported so if you want the value signed, you must cast the UInt with .asSInt. Additional Resources The ChiselEnum type is much more powerful than stated above. It allows for Sequence, Vec, and Bundle assignments, as well as a .next operation to allow for stepping through sequential states and an .isValid for checking that a hardware value is a valid Value. The source code for the ChiselEnum can be found here in the class EnumFactory. Examples of the ChiselEnum operations can be found here."
    } ,    
    {
      "title": "Chisel Type vs Scala Type",
      "url": "/chisel3/docs/explanations/chisel-type-vs-scala-type.html",
      "content": "Chisel Type vs Scala Type The Scala compiler cannot distinguish between Chisel’s representation of hardware such as false.B, Reg(Bool()) and pure Chisel types (e.g. Bool()). You can get runtime errors passing a Chisel type when hardware is expected, and vice versa. Scala Type vs Chisel Type vs Hardware The Scala type of the Data is recognized by the Scala compiler, such as Bool, Decoupled[UInt] or MyBundle in class MyBundle(w: Int) extends Bundle { val foo = UInt(w.W) val bar = UInt(w.W) } The Chisel type of a Data is a Scala object. It captures all the fields actually present, by names, and their types including widths. For example, MyBundle(3) creates a Chisel Type with fields foo: UInt(3.W), bar: UInt(3.W)). Hardware is Data that is “bound” to synthesizable hardware. For example false.B or Reg(Bool()). The binding is what determines the actual directionality of each field, it is not a property of the Chisel type. A literal is a Data that is respresentable as a literal value without being wrapped in Wire, Reg, or IO. Chisel Type vs Hardware vs Literals The below code demonstrates how objects with the same Scala type (MyBundle) can have different properties. import chisel3.experimental.BundleLiterals._ class MyModule(gen: () =&gt; MyBundle) extends Module { // Hardware Literal val xType: MyBundle = new MyBundle(3) // - - val dirXType: MyBundle = Input(new MyBundle(3)) // - - val xReg: MyBundle = Reg(new MyBundle(3)) // x - val xIO: MyBundle = IO(Input(new MyBundle(3))) // x - val xRegInit: MyBundle = RegInit(xIO) // x - val xLit: MyBundle = xType.Lit( // x x _.foo -&gt; 0.U(3.W), _.bar -&gt; 0.U(3.W) ) val y: MyBundle = gen() // ? ? // Need to initialize all hardware values xReg := DontCare } Chisel Type vs Hardware – Specific Functions and Errors .asTypeOf works for both hardware and Chisel type: elaborate(new Module { val chiselType = new MyBundle(3) val hardware = Wire(new MyBundle(3)) hardware := DontCare val a = 0.U.asTypeOf(chiselType) val b = 0.U.asTypeOf(hardware) }) Can only := to hardware: // Do this... elaborate(new Module { val hardware = Wire(new MyBundle(3)) hardware := DontCare }) // Not this... elaborate(new Module { val chiselType = new MyBundle(3) chiselType := DontCare }) // chisel3.package$ExpectedHardwareException: data to be connected 'MyBundle' must be hardware, not a bare Chisel type. Perhaps you forgot to wrap it in Wire(_) or IO(_)? // at ... () // at repl.MdocSession$MdocApp$$anonfun$21$$anonfun$apply$21$$anon$3.&lt;init&gt;(chisel-type-vs-scala-type.md:90) // at repl.MdocSession$MdocApp$$anonfun$21$$anonfun$apply$21.apply(chisel-type-vs-scala-type.md:88) // at repl.MdocSession$MdocApp$$anonfun$21$$anonfun$apply$21.apply(chisel-type-vs-scala-type.md:88) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) Can only := from hardware: // Do this... elaborate(new Module { val hardware = IO(new MyBundle(3)) val moarHardware = Wire(new MyBundle(3)) moarHardware := DontCare hardware := moarHardware }) // Not this... elaborate(new Module { val hardware = IO(new MyBundle(3)) val chiselType = new MyBundle(3) hardware := chiselType }) // chisel3.package$ExpectedHardwareException: data to be connected 'MyBundle' must be hardware, not a bare Chisel type. Perhaps you forgot to wrap it in Wire(_) or IO(_)? // at ... () // at repl.MdocSession$MdocApp$$anonfun$29$$anonfun$apply$27$$anon$5.&lt;init&gt;(chisel-type-vs-scala-type.md:115) // at repl.MdocSession$MdocApp$$anonfun$29$$anonfun$apply$27.apply(chisel-type-vs-scala-type.md:112) // at repl.MdocSession$MdocApp$$anonfun$29$$anonfun$apply$27.apply(chisel-type-vs-scala-type.md:112) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) Have to pass hardware to chiselTypeOf: // Do this... elaborate(new Module { val hardware = Wire(new MyBundle(3)) hardware := DontCare val chiselType = chiselTypeOf(hardware) }) // Not this... elaborate(new Module { val chiselType = new MyBundle(3) val crash = chiselTypeOf(chiselType) }) // chisel3.package$ExpectedHardwareException: 'MyBundle' must be hardware, not a bare Chisel type. Perhaps you forgot to wrap it in Wire(_) or IO(_)? // at ... () // at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34$$anon$7$$anonfun$39$$anonfun$apply$36.apply(chisel-type-vs-scala-type.md:138) // at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34$$anon$7$$anonfun$39$$anonfun$apply$36.apply(chisel-type-vs-scala-type.md:138) // at chisel3.internal.prefix$.apply(prefix.scala:48) // at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34$$anon$7$$anonfun$39.apply(chisel-type-vs-scala-type.md:138) // at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34$$anon$7$$anonfun$39.apply(chisel-type-vs-scala-type.md) // at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33) // at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34$$anon$7.&lt;init&gt;(chisel-type-vs-scala-type.md:138) // at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34.apply(chisel-type-vs-scala-type.md:136) // at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34.apply(chisel-type-vs-scala-type.md:136) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) Have to pass hardware to *Init: // Do this... elaborate(new Module { val hardware = Wire(new MyBundle(3)) hardware := DontCare val moarHardware = WireInit(hardware) }) // Not this... elaborate(new Module { val crash = WireInit(new MyBundle(3)) }) // chisel3.package$ExpectedHardwareException: wire initializer 'MyBundle' must be hardware, not a bare Chisel type. Perhaps you forgot to wrap it in Wire(_) or IO(_)? // at ... () // at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40$$anon$9$$anonfun$45$$anonfun$apply$41.apply(chisel-type-vs-scala-type.md:160) // at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40$$anon$9$$anonfun$45$$anonfun$apply$41.apply(chisel-type-vs-scala-type.md:160) // at chisel3.internal.prefix$.apply(prefix.scala:48) // at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40$$anon$9$$anonfun$45.apply(chisel-type-vs-scala-type.md:160) // at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40$$anon$9$$anonfun$45.apply(chisel-type-vs-scala-type.md) // at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33) // at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40$$anon$9.&lt;init&gt;(chisel-type-vs-scala-type.md:160) // at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40.apply(chisel-type-vs-scala-type.md:159) // at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40.apply(chisel-type-vs-scala-type.md:159) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) Can’t pass hardware to a Wire, Reg, IO: // Do this... elaborate(new Module { val hardware = Wire(new MyBundle(3)) hardware := DontCare }) // Not this... elaborate(new Module { val hardware = Wire(new MyBundle(3)) val crash = Wire(hardware) }) // chisel3.package$ExpectedChiselTypeException: wire type '_44_Anon.hardware: Wire[MyBundle]' must be a Chisel type, not hardware // at ... () // at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44$$anon$11$$anonfun$51$$anonfun$apply$47.apply(chisel-type-vs-scala-type.md:182) // at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44$$anon$11$$anonfun$51$$anonfun$apply$47.apply(chisel-type-vs-scala-type.md:182) // at chisel3.internal.prefix$.apply(prefix.scala:48) // at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44$$anon$11$$anonfun$51.apply(chisel-type-vs-scala-type.md:182) // at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44$$anon$11$$anonfun$51.apply(chisel-type-vs-scala-type.md) // at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33) // at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44$$anon$11.&lt;init&gt;(chisel-type-vs-scala-type.md:182) // at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44.apply(chisel-type-vs-scala-type.md:180) // at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44.apply(chisel-type-vs-scala-type.md:180) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) .Lit can only be called on Chisel type: // Do this... elaborate(new Module { val hardwareLit = (new MyBundle(3)).Lit( _.foo -&gt; 0.U, _.bar -&gt; 0.U ) }) //Not this... elaborate(new Module { val hardware = Wire(new MyBundle(3)) val crash = hardware.Lit( _.foo -&gt; 0.U, _.bar -&gt; 0.U ) }) // chisel3.package$ExpectedChiselTypeException: bundle literal constructor model '_52_Anon.hardware: Wire[MyBundle]' must be a Chisel type, not hardware // at ... () // at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52$$anon$13$$anonfun$56$$anonfun$apply$55.apply(chisel-type-vs-scala-type.md:206) // at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52$$anon$13$$anonfun$56$$anonfun$apply$55.apply(chisel-type-vs-scala-type.md:206) // at chisel3.internal.prefix$.apply(prefix.scala:48) // at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52$$anon$13$$anonfun$56.apply(chisel-type-vs-scala-type.md:206) // at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52$$anon$13$$anonfun$56.apply(chisel-type-vs-scala-type.md) // at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33) // at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52$$anon$13.&lt;init&gt;(chisel-type-vs-scala-type.md:206) // at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52.apply(chisel-type-vs-scala-type.md:204) // at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52.apply(chisel-type-vs-scala-type.md:204) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) Can only use a Chisel type within a Bundle definition: // Do this... elaborate(new Module { val hardware = Wire(new Bundle { val nested = new MyBundle(3) }) hardware := DontCare }) // Not this... elaborate(new Module { val crash = Wire(new Bundle { val nested = Wire(new MyBundle(3)) }) }) // chisel3.package$ExpectedChiselTypeException: Bundle: AnonymousBundle contains hardware fields: nested: _60_Anon.crash_nested: Wire[MyBundle] // at ... () // at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60$$anon$16$$anonfun$62$$anonfun$apply$61.apply(chisel-type-vs-scala-type.md:232) // at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60$$anon$16$$anonfun$62$$anonfun$apply$61.apply(chisel-type-vs-scala-type.md:232) // at chisel3.internal.prefix$.apply(prefix.scala:48) // at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60$$anon$16$$anonfun$62.apply(chisel-type-vs-scala-type.md:232) // at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60$$anon$16$$anonfun$62.apply(chisel-type-vs-scala-type.md) // at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33) // at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60$$anon$16.&lt;init&gt;(chisel-type-vs-scala-type.md:232) // at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60.apply(chisel-type-vs-scala-type.md:231) // at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60.apply(chisel-type-vs-scala-type.md:231) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) Can only call directionOf on Hardware: import chisel3.reflect.DataMirror class Child extends Module{ val hardware = IO(new MyBundle(3)) hardware := DontCare val chiselType = new MyBundle(3) } // Do this... elaborate(new Module { val child = Module(new Child()) child.hardware := DontCare val direction = DataMirror.directionOf(child.hardware) }) // Not this... elaborate(new Module { val child = Module(new Child()) child.hardware := DontCare val direction = DataMirror.directionOf(child.chiselType) }) // chisel3.package$ExpectedHardwareException: node requested directionality on 'MyBundle' must be hardware, not a bare Chisel type. Perhaps you forgot to wrap it in Wire(_) or IO(_)? // at ... () // at repl.MdocSession$MdocApp$$anonfun$70$$anonfun$apply$68$$anon$19.&lt;init&gt;(chisel-type-vs-scala-type.md:271) // at repl.MdocSession$MdocApp$$anonfun$70$$anonfun$apply$68.apply(chisel-type-vs-scala-type.md:268) // at repl.MdocSession$MdocApp$$anonfun$70$$anonfun$apply$68.apply(chisel-type-vs-scala-type.md:268) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) Can call specifiedDirectionOf on hardware or Chisel type: elaborate(new Module { val child = Module(new Child()) child.hardware := DontCare val direction0 = DataMirror.specifiedDirectionOf(child.hardware) val direction1 = DataMirror.specifiedDirectionOf(child.chiselType) }) .asInstanceOf vs .asTypeOf vs chiselTypeOf .asInstanceOf is a Scala runtime cast, usually used for telling the compiler that you have more information than it can infer to convert Scala types: class ScalaCastingModule(gen: () =&gt; Bundle) extends Module { val io = IO(Output(gen().asInstanceOf[MyBundle])) io.foo := 0.U } This works if we do indeed have more information than the compiler: elaborate(new ScalaCastingModule( () =&gt; new MyBundle(3))) But if we are wrong, we can get a Scala runtime exception: class NotMyBundle extends Bundle {val baz = Bool()} elaborate(new ScalaCastingModule(() =&gt; new NotMyBundle())) // java.lang.ClassCastException: repl.MdocSession$MdocApp$$anonfun$79$NotMyBundle$1 cannot be cast to repl.MdocSession$MdocApp$MyBundle // at ... () // at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76$$anonfun$apply$71$$anonfun$apply$72$$anonfun$apply$73.apply(chisel-type-vs-scala-type.md:293) // at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76$$anonfun$apply$71$$anonfun$apply$72$$anonfun$apply$73.apply(chisel-type-vs-scala-type.md:293) // at chisel3.SpecifiedDirection$.specifiedDirection(Data.scala:65) // at chisel3.Output$.apply(Data.scala:343) // at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76$$anonfun$apply$71$$anonfun$apply$72.apply(chisel-type-vs-scala-type.md:293) // at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76$$anonfun$apply$71$$anonfun$apply$72.apply(chisel-type-vs-scala-type.md:293) // at chisel3.IO$.apply(IO.scala:27) // at chisel3.experimental.BaseModule.IO(Module.scala:566) // at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76$$anonfun$apply$71.apply(chisel-type-vs-scala-type.md:293) // at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76$$anonfun$apply$71.apply(chisel-type-vs-scala-type.md:293) // at chisel3.internal.prefix$.apply(prefix.scala:48) // at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76.apply(chisel-type-vs-scala-type.md:293) // at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76.apply(chisel-type-vs-scala-type.md) // at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33) // at repl.MdocSession$MdocApp$ScalaCastingModule.&lt;init&gt;(chisel-type-vs-scala-type.md:293) // at repl.MdocSession$MdocApp$$anonfun$79$$anonfun$apply$75.apply(chisel-type-vs-scala-type.md:309) // at repl.MdocSession$MdocApp$$anonfun$79$$anonfun$apply$75.apply(chisel-type-vs-scala-type.md:309) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) .asTypeOf is a conversion from one Data subclass to another. It is commonly used to assign data to all-zeros, as described in this cookbook recipe, but it can also be used (though not really recommended, as there is no checking on width matches) to convert one Chisel type to another: class SimilarToMyBundle(w: Int) extends Bundle{ val foobar = UInt((2*w).W) } ChiselStage.emitSystemVerilog(new Module { val in = IO(Input(new MyBundle(3))) val out = IO(Output(new SimilarToMyBundle(3))) out := in.asTypeOf(out) }) // Running CIRCT: 'firtool -format=fir -warn-on-unprocessed-annotations -verify-each=false -dedup -output-annotation-file circt.anno.json -disable-infer-rw -annotation-file _82_Anon.anno.json &lt; $input' // res12: String = \"\"\"// Generated by CIRCT sifive/1/20/0 // module _82_Anon( // &lt;stdin&gt;:3:10 // input clock, // reset, // input [2:0] in_foo, // in_bar, // output [5:0] out_foobar); // // assign out_foobar = {in_foo, in_bar}; // &lt;stdin&gt;:3:10, chisel-type-vs-scala-type.md:327:21 // endmodule // // \"\"\" In contrast to asInstanceOf and asTypeOf, chiselTypeOf is not a casting operation. It returns a Scala object which can be used as shown in the examples above to create more Chisel types and hardware with the same Chisel type as existing hardware."
    } ,    
    {
      "title": "Chisel3 vs. Chisel2",
      "url": "/chisel3/docs/appendix/chisel3-vs-chisel2.html",
      "content": "Chisel3 vs Chisel2 Note Chisel2 Compatibility Mode is entirely deprecated in 3.6, so this entire page is relevant only for 3.6 and earlier. Chisel2 Migration For those moving from Chisel2, there were some backwards incompatible changes and your RTL needs to be modified to work with Chisel3. The required modifications are: Wire declaration style: val wire = UInt(width = 15) becomes (in Chisel3): val wire = Wire(UInt(15.W)) I/O declaration style: val done = Bool(OUTPUT) becomes (in Chisel3): val wire = Output(Bool()) Sequential memories: val addr = Reg(UInt()) val mem = Mem(UInt(8.W), 1024, seqRead = true) val dout = when(enable) { mem(addr) } becomes (in Chisel3): val addr = UInt() val mem = SyncReadMem(1024, UInt(8.W)) val dout = mem.read(addr, enable) Notice the address register is now internal to the SyncReadMem(), but the data will still return on the subsequent cycle. Generating Verilog for a module: object Hello { def main(args: Array[String]): Unit = { chiselMain(Array(\"--backend\", \"v\"), () =&gt; Module(new Hello())) } } becomes (in Chisel3): import circt.stage.ChiselStage object Hello { def main(args: Array[String]): Unit = { ChiselStage.emitSystemVerilog(new Hello()) } } Package changes: Chisel.log2Ceil -&gt; chisel3.util.log2Ceil BitPat Decoupled is also in chisel3.util Please refer to the Chisel3 compatibility section for instructions on preparing your Chisel2 designs for Chisel3. Deprecated Usage Vec(Reg) should be replaced with Reg(Vec), type-only vals (no associated data) must be wrapped in a Wire() if they will be the destination of a wiring operation (“:=” or “ &lt; &gt;”), masked bit patterns (‘b??’) should be created using BitPat(), not UInt() or Bits(), the clone method required for parameterized Bundles has been renamed cloneType, the con and alt inputs to a Mux must be type-compatible - both signed or both unsigned, bulk-connection to a node that has been procedurally assigned-to is illegal, != is deprecated, use =/= instead, use SyncReadMem(...) instead of Mem(..., seqRead), use SyncReadMem(n:Int, out: =&gt; T) instead of SyncReadMem(out: =&gt; T, n:Int), use SyncReadMem(...) instead of SeqMem(...), use Mem(n:Int, t:T) instead of Mem(out:T, n:Int), use Vec(n:Int, gen: =&gt; T) instead of Vec(gen: =&gt; T, n:Int), module io’s must be wrapped in IO(). The methods asInput, asOutput, and flip should be replaced by the Input(), Output(), and Flipped() object apply methods. Unsupported constructs Mem(..., orderedWrites) is no longer supported, masked writes are only supported for Mem[Vec[_]], Chisel3 Vecs must all have the same type, unlike with Chisel2. Use MixedVec (see Bundles and Vecs) for Vecs where the elements are of different types. connections between UInt and SInt are illegal. the Node class and object no longer exist (the class should have been private in Chisel2) printf() is defined in the Chisel object and produces simulation printf()’s. To use the Scala Predef.printf(), you need to qualify it with Predef. in Chisel2, bulk-connects &lt;&gt; with unconnected source components do not update connections from the unconnected components. ** In Chisel3, bulk-connects strictly adhere to last connection semantics and unconnected OUTPUTs will be connected to INPUTs resulting in the assignment of random values to those inputs. In Chisel3, adding hardware inside BlackBox for simulation is no longer supported. (#289) ChiselError is gone Change ChiselError.error(\"error msg\") to throw new Error(\"error msg\") Change ChiselError.info(\"info msg\") to println(\"info msg\") In Chisel3, subword assignments are not supported. Alternative constructions exist in Chisel3. Further changes The clock signal was renamed from clk to clock in Chisel3. Change getWidth() to getWidth Packaging Chisel3 is implemented as several packages. The core DSL is differentiated from utility or library classes and objects, testers, and interpreters. The prime components of the Chisel3 front end (the DSL and library objects) are: coreMacros - source locators provide Chisel line numbers for firrtl detected errors, chiselFrontend - main DSL components, chisel3 - compiler driver, interface packages, compatibility layer. Due to the wonders of sbt, you need only declare a dependency on the chisel3 package, and the others will be downloaded as required. The firrtl compiler is distributed as a separate package, and release versions will also be downloaded automatically as required. If you choose to integrate the compiler into your own toolchain, or you’re working with the development (master) branch of chisel3, you should clone the firrtl repo and follow the instructions for installing the firrtl compiler. The testers in Chisel3 are distributed as a separate package. If you intend to use them in your tests, you will either need to clone the chisel-testers repo or declare a dependency on the published version of the package. See the build.sbt file in either the chisel-template or chisel-tutorial repos for examples of the latter. Simulation Chisel2 was capable of directly generating a C++ simulation from the Chisel code, or a harness for use with a vcs simulation. Chisel3 relies on verilator to generate the C++ simulation from the Verilog output of firrtl. See the Chisel3 README for directions on installing verilator. Compile Options and Front End Checks (Strict vs. NotStrict) Chisel3 introduces a formal specification for hardware circuit graphs: FIRRTL, and Chisel3 itself (the Scala library implementing the Chisel DSL), is a relatively thin front end that generates FIRRTL. Since the firrtl parser needs to validate FIRRTL input, most of the checks that were performed in Chisel2 were eliminated from the initial Chisel3 front end (the DRY principle). However, this does impact the ability to provide detailed messages for error conditions that could be detected in the Chisel3 front end. The decision was made to optionally enable stricter error checking (for connections and the use of raw types versus hardware objects), based on specific imports. This allows designs to move from less strict front end checks (largely compatible with Chisel2), to stricter checking, on a file by file basis, by adjusting specific import statements. import chisel3.ExplicitCompileOptions.Strict enables stricter connection and usage checks, while import chisel3.ExplicitCompileOptions.NotStrict defers these checks to the firrtl compiler. By default, the Chisel compatibility layer, invoked by: import Chisel._ implicitly defines the compile options as chisel3.core.ExplicitCompileOptions.NotStrict whereas the Chisel3 package, invoked by: import chisel3._ implicitly defines the compile options as chisel3.core.ExplicitCompileOptions.Strict Again, these implicit compile options definitions may be overridden by explicit imports. Currently, the specific error checks (found in CompileOptions.scala) are: trait CompileOptions { // Should Bundle connections require a strict match of fields. // If true and the same fields aren't present in both source and sink, a MissingFieldException, // MissingLeftFieldException, or MissingRightFieldException will be thrown. val connectFieldsMustMatch: Boolean // When creating an object that takes a type argument, the argument must be unbound (a pure type). val declaredTypeMustBeUnbound: Boolean // Module IOs should be wrapped in an IO() to define their bindings before the reset of the module is defined. val requireIOWrap: Boolean // If a connection operator fails, don't try the connection with the operands (source and sink) reversed. val dontTryConnectionsSwapped: Boolean // If connection directionality is not explicit, do not use heuristics to attempt to determine it. val dontAssumeDirectionality: Boolean // Issue a deprecation warning if Data.{flip, asInput,asOutput} is used // instead of Flipped, Input, or Output. val deprecateOldDirectionMethods: Boolean // Check that referenced Data have actually been declared. val checkSynthesizable: Boolean } chisel3.core.ExplicitCompileOptions.Strict sets all CompileOptions fields to true and chisel3.core.ExplicitCompileOptions.NotStrict sets them all to false. Clients are free to define their own settings for these options. Examples may be found in the test CompileOptionsSpec"
    } ,    
    {
      "title": "Combinational Circuits",
      "url": "/chisel3/docs/explanations/combinational-circuits.html",
      "content": "Combinational Circuits A circuit is represented as a graph of nodes in Chisel. Each node is a hardware operator that has zero or more inputs and that drives one output. A literal, introduced above, is a degenerate kind of node that has no inputs and drives a constant value on its output. One way to create and wire together nodes is using textual expressions. For example, we can express a simple combinational logic circuit using the following expression: (a &amp; b) | (~c &amp; d) The syntax should look familiar, with &amp; and | representing bitwise-AND and -OR respectively, and ~ representing bitwise-NOT. The names a through d represent named wires of some (unspecified) width. Any simple expression can be converted directly into a circuit tree, with named wires at the leaves and operators forming the internal nodes. The final circuit output of the expression is taken from the operator at the root of the tree, in this example, the bitwise-OR. Simple expressions can build circuits in the shape of trees, but to construct circuits in the shape of arbitrary directed acyclic graphs (DAGs), we need to describe fan-out. In Chisel, we do this by naming a wire that holds a subexpression that we can then reference multiple times in subsequent expressions. We name a wire in Chisel by declaring a variable. For example, consider the select expression, which is used twice in the following multiplexer description: val sel = a | b val out = (sel &amp; in1) | (~sel &amp; in0) The keyword val is part of Scala, and is used to name variables that have values that won’t change. It is used here to name the Chisel wire, sel, holding the output of the first bitwise-OR operator so that the output can be used multiple times in the second expression. Wires Chisel also supports wires as hardware nodes to which one can assign values or connect other nodes. val myNode = Wire(UInt(8.W)) when (isReady) { myNode := 255.U } .otherwise { myNode := 0.U } val myNode = Wire(UInt(8.W)) when (input &gt; 128.U) { myNode := 255.U } .elsewhen (input &gt; 64.U) { myNode := 1.U } .otherwise { myNode := 0.U } Note that the last connection to a Wire takes effect. For example, the following two Chisel circuits are equivalent: val myNode = Wire(UInt(8.W)) myNode := 10.U myNode := 0.U val myNode = Wire(UInt(8.W)) myNode := 0.U"
    } ,    
    {
      "title": "Community",
      "url": "/community.html",
      "content": "Chisel Users Community If you’re a Chisel user and want to stay connected to the wider user community, any of the following are great avenues: Interact with other Chisel users in one of our Gitter chat rooms: Chisel FIRRTL Ask/Answer Questions on Stack Overflow using the [chisel] tag Ask questions and discuss ideas on the Chisel/FIRRTL Mailing Lists: Chisel Users Chisel Developers Follow us on our @chisel_lang Twitter Account Subscribe to our chisel-lang YouTube Channel Projects Using Chisel/FIRRTL If you want to add your project to the list, let us know on the Chisel users mailing list! Chisel Project Description Author Links Rocket Chip Generator RISC-V System-on-Chip Generator, 5-stage RISC-V Microprocessor @ucb-bar, @sifive Report Berkeley Out-of-order Machine RISC-V Out-of-order/Multi-issue Microprocessor @ucb-bar Site, Thesis RISC-V Mini 3-stage RISC-V Microprocessor @ucb-bar   Sodor Processor Collection Educational RISC-V Microprocessors (1, 2, 3, 5-stage) @ucb-bar   Patmos Time-predictable VLIW processor @t-crest Site OpenSoC Fabric Parametrizable Network-on-Chip Generator @LBL-CoDEx Site Hwacha Decoupled Vector-fetch Accelerator @ucb-bar Report DANA Multilayer Perceptron Accelerator for Rocket @bu-icsg Paper Gemmini Systolic-array Accelerator Generator @ucb-bar Paper Edge TPU AI Inference Accelerator @google Video ChiselFlow Information Flow Types in Chisel3 @apl-cornell Paper PHMon Programmable Hardware Monitor @bu-icsg Paper DINO CPU Davis In-Order (DINO) CPU models @jlpteaching Paper Quasar CHISEL implementation of SweRV-EL2 @Lampro-Mellon Video FP Divider Pipelined / Not Pipelined IEEE binary 32-bit divider using Harmonized Parabolic Synthesis @Ssavas Paper Square Root Pipelined / Not Pipelined Square Root using Harmonized Parabolic Synthesis @Ssavas Paper Pillars A Consistent CGRA Design Framework @pku-dasys Paper, Video Tensil Machine Learning Accelerators @tensil-ai Website Twine A Chisel Extension for Component-Level Heterogeneous Design @shibo-chen Paper FIRRTL Project Description Author Links MIDAS/DESSERT/Golden Gate FPGA Accelerated Simulation @ucb-bar Papers 1, 2, 3, Video Chiffre Run-time Fault Injection @IBM Paper SIRRTL Security-typed FIRRTL @apl-cornell Paper obfuscation Transforms to Obfuscate FIRRTL Circuits @jpsety   Area/Timing Estimates Transforms for Area and Timing Estimates @intel Video Chisel Developers Community If you want to get more involved with the Chisel/FIRRTL ecosystem of projects, feel free to reach out to us on any of the mediums above. If you prefer to dive right in (or have bugs to report), a complete list of the associated Chisel/FIRRTL ecosystem of projects is below: Chisel FIRRTL Chisel Testers/chisel3.iotesters Chisel Testers2/chisel3.testers Treadle Diagrammer Contributors Chisel, FIRRTL, and all related projects would not be possible without the contributions of our fantastic developer community. The following people have contributed to the current release of the projects: @abejgonzalez @adkian-sifive @albert-magyar @albertchen-sifive @andreaTP @aswaterman @azidar @AzureSkyResearch @ben-k @blhguo @Burnleydev1 @bwrcbcr @carlosedp @caryan @ccelio @chick @colin4124 @colinschmidt @danluu @David-Durst @davidbiancolin @debs-sifive @dependabot-preview[bot] @dependabot[bot] @diningyo @djmmoss @dkravitz-sifive @Dobios @donggyukim @dt27182 @ducky64 @edcote @edwardcwang @ekiwi @ekiwi-sifive @Eymay @fabianschuiki @felixonmars @ferresb @grebe @hcook @hngenc @howardlau1999 @huytbvo @ImeshBalasuriya @ingallsj @jackbackrack @jackkoenig @jared-barocsi @jascondley @jcmartin @jiegec @jimmysitu @johnsbrew @kammoh @kasanovic @learning-chip @lmy441900 @lsteveol @lu-ping @marmbrus @Martoni @michael-etzkorn @mwachs5 @NELEwb @nullobject @nyuichi @oharboe @palmer-dabbelt @parzival3 @pineapplehunter @pranith @ptorru @rachelzoll @Ravencus @richardxia @rupertlssmith @ryan-lund @sbeamer @scala-steward @schoeberl @sdtwigg @SebastianBoe @seldridge @sequencer @sgandham2 @Shorla @shunshou @ShuyunJia @SihaoLiu @SingularityKChen @sinofp @sterin @stevobailey @terpstra @TsaiAnson @ucbjrl @wunderabt @yqszxx @yunsup @zhemao @zhutmost @zyedidia Papers While Chisel has come a long way since 2012, the original Chisel paper provides some background on motivations and an overview of the (now deprecated) Chisel 2 language: Bachrach, Jonathan, et al. “Chisel: constructing hardware in a scala embedded language.” DAC Design Automation Conference 2012. IEEE, 2012. The FIRRTL IR and FIRRTL compiler, introduced as part of Chisel 3, are discussed in both the following paper and specification1: Izraelevitz, Adam, et al. “Reusability is FIRRTL ground: Hardware construction languages, compiler frameworks, and transformations.” Proceedings of the 36th International Conference on Computer-Aided Design. IEEE Press, 2017. Li, Patrick S., Adam M. Izraelevitz, and Jonathan Bachrach. “Specification for the FIRRTL Language.” EECS Department, University of California, Berkeley, Tech. Rep. UCB/EECS-2016-9 (2016). Finally, Chisel’s functional programming and bit-width inference ideas were inspired by earlier work on a hardware description language called Gel: Bachrach, Jonathan, Dany Qumsiyeh, and Mark Tobenkin. “Hardware scripting in gel.” 2008 16th International Symposium on Field-Programmable Custom Computing Machines. IEEE, 2008. Attribution If you use Chisel in your research, consider citing: @inproceedings{bachrach:2012:chisel, author={J. {Bachrach} and H. {Vo} and B. {Richards} and Y. {Lee} and A. {Waterman} and R {Avižienis} and J. {Wawrzynek} and K. {Asanović}}, booktitle={DAC Design Automation Conference 2012}, title={Chisel: Constructing hardware in a Scala embedded language}, year={2012}, volume={}, number={}, pages={1212-1221}, keywords={application specific integrated circuits;C++ language;field programmable gate arrays;hardware description languages;Chisel;Scala embedded language;hardware construction language;hardware design abstraction;functional programming;type inference;high-speed C++-based cycle-accurate software simulator;low-level Verilog;FPGA;standard ASIC flow;Hardware;Hardware design languages;Generators;Registers;Wires;Vectors;Finite impulse response filter;CAD}, doi={10.1145/2228360.2228584}, ISSN={0738-100X}, month={June},} If you use FIRRTL in your research consider citing: @INPROCEEDINGS{8203780, author={A. Izraelevitz and J. Koenig and P. Li and R. Lin and A. Wang and A. Magyar and D. Kim and C. Schmidt and C. Markley and J. Lawson and J. Bachrach}, booktitle={2017 IEEE/ACM International Conference on Computer-Aided Design (ICCAD)}, title={Reusability is FIRRTL ground: Hardware construction languages, compiler frameworks, and transformations}, year={2017}, volume={}, number={}, pages={209-216}, keywords={field programmable gate arrays;hardware description languages;program compilers;software reusability;hardware development practices;hardware libraries;open-source hardware intermediate representation;hardware compiler transformations;Hardware construction languages;retargetable compilers;software development;virtual Cambrian explosion;hardware compiler frameworks;parameterized libraries;FIRRTL;FPGA mappings;Chisel;Flexible Intermediate Representation for RTL;Reusability;Hardware;Libraries;Hardware design languages;Field programmable gate arrays;Tools;Open source software;RTL;Design;FPGA;ASIC;Hardware;Modeling;Reusability;Hardware Design Language;Hardware Construction Language;Intermediate Representation;Compiler;Transformations;Chisel;FIRRTL}, doi={10.1109/ICCAD.2017.8203780}, ISSN={1558-2434}, month={Nov},} @techreport{Li:EECS-2016-9, Author = {Li, Patrick S. and Izraelevitz, Adam M. and Bachrach, Jonathan}, Title = {Specification for the FIRRTL Language}, Institution = {EECS Department, University of California, Berkeley}, Year = {2016}, Month = {Feb}, URL = {http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-9.html}, Number = {UCB/EECS-2016-9} } This specification is provided for historical perspective. For the latest version of the FIRRTL specification you can use this link. &#8617;"
    } ,    
    {
      "title": "Connectable Operators",
      "url": "/chisel3/docs/explanations/connectable.html",
      "content": "Table of Contents Terminology Overview Alignment: Flipped vs Aligned Input/Output Connecting components with fully aligned members Mono-direction connection operator (:=) Connecting components with mixed alignment members Bi-direction connection operator (:&lt;&gt;=) Port-Direction Computation versus Connection-Direction Computation Aligned connection operator (:&lt;=) Flipped connection operator (:&gt;=) Coercing mono-direction connection operator (:#=) Connectable Connecting Records Defaults with waived connections Connecting types with optional members Always ignore extra members (partial connection operator) Connecting components with different widths Techniques for connecting structurally inequivalent Chisel types Connecting different sub-types of the same super-type, with colliding names Connecting sub-types to super-types by waiving extra members Connecting different sub-types Terminology “Chisel type” - a Data that is not bound to hardware, i.e. not a component. (more details here). E.g. UInt(3.W), new Bundle {..}, Vec(3, SInt(2.W)) are all Chisel types Aggregate - a Chisel type or component that contains other Chisel types or components (i.e. Vec, Record, or Bundle) Element - a Chisel type or component that does not contain other Chisel types or components (e.g. UInt, SInt, Clock, Bool etc.) “component” - a Data that is bound to hardware (IO, Reg, Wire, etc.) E.g. Wire(UInt(3.W)) is a component, whose Chisel type is UInt(3.W) “member” - a Chisel type or component, or any of its children (could be an Aggregate or an Element) E.g. Vec(3, UInt(2.W))(0) is a member of the parent Vec Chisel type E.g. Wire(Vec(3, UInt(2.W)))(0) is a member of the parent Wire component E.g. IO(Decoupled(Bool)).ready is a member of the parent IO component “relative alignment” - whether two members of the same component or Chisel type are aligned/flipped, relative to one another see section below for a detailed definition “structural type check” - Chisel type A is structurally equivalent to Chisel type B if A and B have matching bundle field names and types (Record vs Vector vs Element), vector sizes, Element types (UInt/SInt/Bool/Clock etc)) ignores relative alignment (flippedness) “alignment type check” - a Chisel type A matches alignment with another Chisel type B if every member of A’s relative alignment to A is the same as the structurally corresponding member of B’s relative alignment to B. Overview The Connectable operators are the standard way to connect Chisel hardware components to one another. Note: For descriptions of the semantics for the previous operators, see Connection Operators. All connection operators require the two hardware components (consumer and producer) to be structurally type equivalent. The one exception to the structural type-equivalence rule is using the Connectable mechanism, detailed at this section towards the end of this document. Aggregate (Record, Vec, Bundle) Chisel types can include data members which are flipped relative to one another. Due to this, there are many desired connection behaviors between two Chisel components. The following are the Chisel connection operators: c := p (mono-direction): connects all p members to c; requires c &amp; p to not have any flipped members c :#= p (coercing mono-direction): connects all p members to c; regardless of alignment c :&lt;= p (aligned-direction): connects all aligned (non-flipped) c members from p c :&gt;= p (flipped-direction): connects all flipped p members from c c :&lt;&gt;= p (bi-direction operator): connects all aligned c members from p; all flipped p members from c These operators may appear to be a random collection of symbols; however, the characters are consistent between operators and self-describe the semantics of each operator: : always indicates the consumer, or left-hand-side, of the operator. = always indicates the producer, or right-hand-side, of the operator. Hence, c := p connects a consumer (c) and a producer (p). &lt; always indicates that some members will be driven producer-to-consumer, or right-to-left. Hence, c :&lt;= p drives members in producer (p) to members in consumer (c). &gt; always indicates that some signals will be driven consumer-to-producer, or left-to-right. Hence, c :&gt;= p drives members in consumer (c) to members producer (p). Hence, c :&lt;&gt;= p both drives members from p to c and from c to p. # always indicates to ignore member alignment and to drive producer-to-consumer. Hence, c :#= p always drives members from p to c ignoring direction. Note: in addition, an operator that ends in = has assignment-precendence, which means that x :&lt;&gt;= y + z will translate to x :&lt;&gt;= (y + z), rather than (x :&lt;&gt;= y) + z. This was not true of the &lt;&gt; operator and was a minor painpoint for users. Alignment: Flipped vs Aligned A member’s alignment is a relative property: a member is aligned/flipped relative to another member of the same component or Chisel type. Hence, one must always say whether a member is flipped/aligned with respect to (w.r.t) another member of that type (parent, sibling, child etc.). We use the following example of a non-nested bundle Parent to let us state all of the alignment relationships between members of p. import chisel3._ class Parent extends Bundle { val alignedChild = UInt(32.W) val flippedChild = Flipped(UInt(32.W)) } class MyModule0 extends Module { val p = Wire(new Parent) } First, every member is always aligned with themselves: p is aligned w.r.t p p.alignedChild is aligned w.r.t p.alignedChild p.flippedChild is aligned w.r.t p.flippedChild Next, we list all parent/child relationships. Because the flippedChild field is Flipped, it changes its aligment relative to its parent. p is aligned w.r.t p.alignedChild p is flipped w.r.t p.flippedChild Finally, we can list all sibling relationships: p.alignedChild is flipped w.r.t p.flippedChild The next example has a nested bundle GrandParent who instantiates an aligned Parent field and flipped Parent field. import chisel3._ class GrandParent extends Bundle { val alignedParent = new Parent val flippedParent = Flipped(new Parent) } class MyModule1 extends Module { val g = Wire(new GrandParent) } Consider the following alignements between grandparent and grandchildren. An odd number of flips indicate a flipped relationship; even numbers of flips indicate an aligned relationship. g is aligned w.r.t g.flippedParent.flippedChild g is aligned w.r.t g.alignedParent.alignedChild g is flipped w.r.t g.flippedParent.alignedChild g is flipped w.r.t g.alignedParent.flippedChild Consider the following alignment relationships starting from g.alignedParent and g.flippedParent. Note that whether g.alignedParent is aligned/flipped relative to g has no effect on the aligned/flipped relationship between g.alignedParent and g.alignedParent.alignedChild because alignment is only relative to the two members in question!: g.alignedParent is aligned w.r.t. g.alignedParent.alignedChild g.flippedParent is aligned w.r.t. g.flippedParent.alignedChild g.alignedParent is flipped w.r.t. g.alignedParent.flippedChild g.flippedParent is flipped w.r.t. g.flippedParent.flippedChild In summary, a member is aligned or flipped w.r.t. another member of the hardware component. This means that the type of the consumer/producer is the only information needed to determine the behavior of any operator. Whether the consumer/producer is a member of a larger bundle is irrelevant; you ONLY need to know the type of the consumer/producer. Input/Output Input(gen)/Output(gen) are coercing operators. They perform two functions: (1) create a new Chisel type that has all flips removed from all recursive children members (still structurally equivalent to gen but no longer alignment type equivalent), and (2) apply Flipped if Input, keep aligned (do nothing) if Output. E.g. if we imagine a function called cloneChiselTypeButStripAllFlips, then Input(gen) is structurally and alignment type equivalent to Flipped(cloneChiselTypeButStripAllFlips(gen)). Note that if gen is a non-aggregate, then Input(nonAggregateGen) is equivalent to Flipped(nonAggregateGen). Future work will refactor how these primitives are exposed to the user to make Chisel’s type system more intuitive. See [https://github.com/chipsalliance/chisel3/issues/2643]. With this in mind, we can consider the following examples and detail relative alignments of members. First, we can use a similar example to Parent but use Input/Output instead of Flipped. Because alignedChild and flippedChild are non-aggregates, Input is basically just a Flipped and thus the alignments are unchanged compared to the previous Parent example. import chisel3._ class ParentWithOutputInput extends Bundle { val alignedCoerced = Output(UInt(32.W)) // Equivalent to just UInt(32.W) val flippedCoerced = Input(UInt(32.W)) // Equivalent to Flipped(UInt(32.W)) } class MyModule2 extends Module { val p = Wire(new ParentWithOutputInput) } The aligments are the same as the previous Parent example: p is aligned w.r.t p p.alignedCoerced is aligned w.r.t p.alignedCoerced p.flippedCoerced is aligned w.r.t p.flippedCoerced p is aligned w.r.t p.alignedCoerced p is flipped w.r.t p.flippedCoerced p.alignedCoerced is flipped w.r.t p.flippedCoerced The next example has a nested bundle GrandParent who instantiates an Output ParentWithOutputInput field and an Input ParentWithOutputInput field. import chisel3._ class GrandParentWithOutputInput extends Bundle { val alignedCoerced = Output(new ParentWithOutputInput) val flippedCoerced = Input(new ParentWithOutputInput) } class MyModule3 extends Module { val g = Wire(new GrandParentWithOutputInput) } Remember that Output(gen)/Input(gen) recursively strips the Flipped of any recursive children. This makes every member of gen aligned with every other member of gen. Consider the following alignments between grandparent and grandchildren. Because alignedCoerced and flippedCoerced are aligned with all their recursive members, they are fully aligned. Thus, only their alignment to g influences grandchildren alignment: g is aligned w.r.t g.alignedCoerced.alignedChild g is aligned w.r.t g.alignedCoerced.flippedChild g is flipped w.r.t g.flippedCoerced.alignedChild g is flipped w.r.t g.flippedCoerced.flippedChild Consider the following alignment relationships starting from g.alignedCoerced and g.flippedCoerced. Note that whether g.alignedCoerced is aligned/flipped relative to g has no effect on the aligned/flipped relationship between g.alignedCoerced and g.alignedCoerced.alignedChild or g.alignedCoerced.flippedChild because alignment is only relative to the two members in question! However, because alignment is coerced, everything is aligned between g.alignedCoerced/g.flippedAligned and their children: g.alignedCoerced is aligned w.r.t. g.alignedCoerced.alignedChild g.alignedCoerced is aligned w.r.t. g.alignedCoerced.flippedChild g.flippedCoerced is aligned w.r.t. g.flippedCoerced.alignedChild g.flippedCoerced is aligned w.r.t. g.flippedCoerced.flippedChild In summary, Input(gen) and Output(gen) recursively coerce children alignment, as well as dictate gen’s alignment to its parent bundle (if it exists). Connecting components with fully aligned members Mono-direction connection operator (:=) For simple connections where all members are aligned (non-flipped) w.r.t. one another, use :=: import chisel3._ class FullyAlignedBundle extends Bundle { val a = Bool() val b = Bool() } class Example0 extends RawModule { val incoming = IO(Flipped(new FullyAlignedBundle)) val outgoing = IO(new FullyAlignedBundle) outgoing := incoming } This generates the following Verilog, where each member of incoming drives every member of outgoing: module Example0( input incoming_a, // @[connectable.md 86:20] input incoming_b, // @[connectable.md 86:20] output outgoing_a, // @[connectable.md 87:20] output outgoing_b // @[connectable.md 87:20] ); assign outgoing_a = incoming_a; // @[connectable.md 88:12] assign outgoing_b = incoming_b; // @[connectable.md 88:12] endmodule You may be thinking “Wait, I’m confused! Isn’t incoming flipped and outgoing aligned?” – Noo! Whether incoming is aligned with outgoing makes no sense; remember, you only evaluate alignment between members of the same component or Chisel type. Because components are always aligned to themselves, outgoing is aligned to outgoing, and incoming is aligned to incoming, there is no problem. Their relative flippedness to anything else is irrelevant. Connecting components with mixed alignment members Aggregate Chisel types can include data members which are flipped relative to one another; in the example below, alignedChild and flippedChild are aligned/flipped relative to MixedAlignmentBundle. import chisel3._ class MixedAlignmentBundle extends Bundle { val alignedChild = Bool() val flippedChild = Flipped(Bool()) } Due to this, there are many desired connection behaviors between two Chisel components. First we will introduce the most common Chisel connection operator, :&lt;&gt;=, useful for connecting components with members of mixed-alignments, then take a moment to investigate a common source of confusion between port-direction and connection-direction. Then, we will explore the remainder of the the Chisel connection operators. Bi-direction connection operator (:&lt;&gt;=) For connections where you want ‘bulk-connect-like-semantics’ where the aligned members are driven producer-to-consumer and flipped members are driven consumer-to-producer, use :&lt;&gt;=. class Example1 extends RawModule { val incoming = IO(Flipped(new MixedAlignmentBundle)) val outgoing = IO(new MixedAlignmentBundle) outgoing :&lt;&gt;= incoming } This generates the following Verilog, where the aligned members are driven incoming to outgoing and flipped members are driven outgoing to incoming: module Example1( input incoming_alignedChild, // @[connectable.md 114:20] output incoming_flippedChild, // @[connectable.md 114:20] output outgoing_alignedChild, // @[connectable.md 115:20] input outgoing_flippedChild // @[connectable.md 115:20] ); assign incoming_flippedChild = outgoing_flippedChild; // @[connectable.md 116:12] assign outgoing_alignedChild = incoming_alignedChild; // @[connectable.md 116:12] endmodule Port-Direction Computation versus Connection-Direction Computation A common question is if you use a mixed-alignment connection (such as :&lt;&gt;=) to connect submembers of parent components, does the alignment of the submember to their parent affect anything? The answer is no, because alignment is always computed relative to what is being connected to, and members are always aligned with themselves. In the following example connecting from incoming.alignedChild to outgoing.alignedChild, whether incoming.alignedChild is aligned with incoming is irrelevant because the :&lt;&gt;= only computes alignment relative to the thing being connected to, and incoming.alignedChild is aligned with incoming.alignedChild. class Example1a extends RawModule { val incoming = IO(Flipped(new MixedAlignmentBundle)) val outgoing = IO(new MixedAlignmentBundle) outgoing.alignedChild :&lt;&gt;= incoming.alignedChild // whether incoming.alignedChild is aligned/flipped to incoming is IRRELEVANT to what gets connected with :&lt;&gt;= } While incoming.flippedChild’s alignment with incoming does not affect our operators, it does influence whether incoming.flippedChild is an output or input port of my module. A common source of confusion is to mistake the process for determining whether incoming.flippedChild will resolve to a verilog output/input (the port-direction computation) with the process for determining how :&lt;&gt;= drives what with what (the connection-direction computation). While both processes consider relative alignment, they are distinct. The port-direction computation always computes alignment relative to the component marked with IO. An IO(Flipped(gen)) is an incoming port, and any member of gen that is aligned/flipped with gen is an incoming/outgoing port. An IO(gen) is an outgoing port, and any member of gen that is aligned/flipped with gen is an outgoing/incoming port. The connection-direction computation always computes alignment based on the explicit consumer/producer referenced for the connection. If one connects incoming :&lt;&gt;= outgoing, alignments are computed based on incoming and outgoing. If one connects incoming.alignedChild :&lt;&gt;= outgoing.alignedChild, then alignments are computed based on incoming.alignedChild and outgoing.alignedChild (and the alignment of incoming to incoming.alignedChild is irrelevant). This means that users can try to connect to input ports of their module! If I write x :&lt;&gt;= y, and x is an input to the current module, then that is what the connection is trying to do. However, because input ports are not drivable from within the current module, Chisel will throw an error. This is the same error a user would get using a mono-directioned operator: x := y will throw the same error if x is an input to the current module. Whether a component is drivable is irrelevant to the semantics of any connection operator attempting to drive to it. In summary, the port-direction computation is relative to the root marked IO, but connection-direction computation is relative to the consumer/producer that the connection is doing. This has the positive property that connection semantics are solely based on the Chisel structural type and its relative alignments of the consumer/producer (nothing more, nothing less). Aligned connection operator (:&lt;=) For connections where you want the aligned-half of ‘bulk-connect-like-semantics’ where the aligned members are driven producer-to-consumer and flipped members are ignored, use :&lt;= (the “aligned connection”). class Example2 extends RawModule { val incoming = IO(Flipped(new MixedAlignmentBundle)) val outgoing = IO(new MixedAlignmentBundle) incoming.flippedChild := DontCare // Otherwise FIRRTL throws an uninitialization error outgoing :&lt;= incoming } This generates the following Verilog, where the aligned members are driven incoming to outgoing and flipped members are ignored: module Example2( input incoming_alignedChild, // @[connectable.md 140:20] output incoming_flippedChild, // @[connectable.md 140:20] output outgoing_alignedChild, // @[connectable.md 141:20] input outgoing_flippedChild // @[connectable.md 141:20] ); assign incoming_flippedChild = 1'h0; assign outgoing_alignedChild = incoming_alignedChild; // @[connectable.md 143:12] endmodule Flipped connection operator (:&gt;=) For connections where you want the flipped-half of ‘bulk-connect-like-semantics’ where the aligned members are ignored and flipped members are connected consumer-to-producer, use :&gt;= (the “flipped connection”, or “backpressure connection”). class Example3 extends RawModule { val incoming = IO(Flipped(new MixedAlignmentBundle)) val outgoing = IO(new MixedAlignmentBundle) outgoing.alignedChild := DontCare // Otherwise FIRRTL throws an uninitialization error outgoing :&gt;= incoming } This generates the following Verilog, where the aligned members are ignore and the flipped members are driven outgoing to incoming: module Example3( input incoming_alignedChild, // @[connectable.md 157:20] output incoming_flippedChild, // @[connectable.md 157:20] output outgoing_alignedChild, // @[connectable.md 158:20] input outgoing_flippedChild // @[connectable.md 158:20] ); assign incoming_flippedChild = outgoing_flippedChild; // @[connectable.md 160:12] assign outgoing_alignedChild = 1'h0; endmodule Note: Astute observers will realize that semantically c :&lt;&gt;= p is exactly equivalent to c :&lt;= p followed by c :&gt;= p. Coercing mono-direction connection operator (:#=) For connections where you want to every producer member to always drive every consumer member, regardless of alignment, use :#= (the “coercion connection”). This operator is useful for initializing wires whose types contain members of mixed alignment. import chisel3.experimental.BundleLiterals._ class Example4 extends RawModule { val w = Wire(new MixedAlignmentBundle) dontTouch(w) // So we see it in the output verilog w :#= (new MixedAlignmentBundle).Lit(_.alignedChild -&gt; true.B, _.flippedChild -&gt; true.B) } This generates the following Verilog, where all members are driven from the literal to w, regardless of alignment: module Example4( ); wire w_alignedChild = 1'h1; // @[connectable.md 177:15 179:5] wire w_flippedChild = 1'h1; // @[connectable.md 177:15 179:5] endmodule Note: Astute observers will realize that semantically c :#= p is exactly equivalent to c :&lt;= p followed by p :&gt;= c (note p and c switched places in the second connection). Another use case for :#= is for connecting a mixed-directional bundle to a fully-aligned monitor. import chisel3.experimental.BundleLiterals._ class Example4b extends RawModule { val monitor = IO(Output(new MixedAlignmentBundle)) val w = Wire(new MixedAlignmentBundle) dontTouch(w) // So we see it in the output verilog w :#= DontCare monitor :#= w } This generates the following Verilog, where all members are driven from the literal to w, regardless of alignment: module Example4b( output monitor_alignedChild, // @[connectable.md 196:19] output monitor_flippedChild // @[connectable.md 196:19] ); wire w_alignedChild = 1'h0; wire w_flippedChild = 1'h0; assign monitor_alignedChild = w_alignedChild; // @[connectable.md 200:11] assign monitor_flippedChild = w_alignedChild; // @[connectable.md 200:11] endmodule Connectable It is not uncommon for a user to want to connect Chisel components which are not type equivalent. For example, a user may want to hook up anonymous Record components who may have an intersection of their fields being equivalent, but cannot because they are not structurally equivalent. Alternatively, one may want to connect two types that have different widths. Connectable is the mechanism to specialize connection operator behavior in these scenarios. For additional members which are not present in the other component being connected to or for mismatched widths, they can be explicitly waived from the operator to be ignored, rather than trigger an error. In addition, there are other techniques that can be used to address similar use cases including .viewAsSuperType, a static cast to a supertype (e.g. (x: T)), or creating a custom dataview. For a discussion about when to use each technique, please continue here. This section demonstrates how Connectable specifically can be used in a multitude of scenarios. Connecting Records A not uncommon usecase is to try to connect two Records; for matching members, they should be connected, but for unmatched members, they should be ignored. To accomplish this, use the other operators to initialize all Record members, then use :&lt;&gt;= with waiveAll to connect only the matching members. Note that none of .viewAsSuperType, static casts, nor a custom DataView helps this case because the Scala types are still Record. import scala.collection.immutable.SeqMap import chisel3.experimental.AutoCloneType class Example9 extends RawModule { val abType = new Record with AutoCloneType { val elements = SeqMap(\"a\" -&gt; Bool(), \"b\" -&gt; Flipped(Bool())) } val bcType = new Record with AutoCloneType { val elements = SeqMap(\"b\" -&gt; Flipped(Bool()), \"c\" -&gt; Bool()) } val p = IO(Flipped(abType)) val c = IO(bcType) DontCare :&gt;= p c :&lt;= DontCare c.waive(_.elements(\"c\")):&lt;&gt;= p.waive(_.elements(\"a\")) } This generates the following Verilog, where p.b is driven from c.b: module Example9( output p_b, // @[connectable.md 223:13] input p_a, // @[connectable.md 223:13] output c_c, // @[connectable.md 224:13] input c_b // @[connectable.md 224:13] ); assign p_b = c_b; // @[connectable.md 229:27] assign c_c = 1'h0; endmodule Defaults with waived connections Another not uncommon usecase is to try to connect two Records; for matching members, they should be connected, but for unmatched members, they should be connected a default value. To accomplish this, use the other operators to initialize all Record members, then use :&lt;&gt;= with waiveAll to connect only the matching members. import scala.collection.immutable.SeqMap import chisel3.experimental.AutoCloneType class Example10 extends RawModule { val abType = new Record with AutoCloneType { val elements = SeqMap(\"a\" -&gt; Bool(), \"b\" -&gt; Flipped(Bool())) } val bcType = new Record with AutoCloneType { val elements = SeqMap(\"b\" -&gt; Flipped(Bool()), \"c\" -&gt; Bool()) } val p = Wire(abType) val c = Wire(bcType) dontTouch(p) // So it doesn't get constant-propped away for the example dontTouch(c) // So it doesn't get constant-propped away for the example p :#= abType.Lit(_.elements(\"a\") -&gt; true.B, _.elements(\"b\") -&gt; true.B) c :#= bcType.Lit(_.elements(\"b\") -&gt; true.B, _.elements(\"c\") -&gt; true.B) c.waive(_.elements(\"c\")) :&lt;&gt;= p.waive(_.elements(\"a\")) } This generates the following Verilog, where p.b is driven from c.b, and p.a, c.b, and c.c are initialized to default values: module Example10( ); wire c_b = 1'h1; // @[connectable.md 253:15 259:5] wire p_b = c_b; // @[connectable.md 252:15 261:28] wire p_a = 1'h1; // @[connectable.md 252:15 258:5] wire c_c = 1'h1; // @[connectable.md 253:15 259:5] endmodule Connecting types with optional members In the following example, we can use :&lt;&gt;= and waive to connect two MyDecoupledOpts’s, where only one has a bits member. class MyDecoupledOpt(hasBits: Boolean) extends Bundle { val valid = Bool() val ready = Flipped(Bool()) val bits = if (hasBits) Some(UInt(32.W)) else None } class Example6 extends RawModule { val in = IO(Flipped(new MyDecoupledOpt(true))) val out = IO(new MyDecoupledOpt(false)) out :&lt;&gt;= in.waive(_.bits.get) // We can know to call .get because we can inspect in.bits.isEmpty } This generates the following Verilog, where ready and valid are connected, and bits is ignored: module Example6( input in_valid, // @[connectable.md 282:15] output in_ready, // @[connectable.md 282:15] input [31:0] in_bits, // @[connectable.md 282:15] output out_valid, // @[connectable.md 283:15] input out_ready // @[connectable.md 283:15] ); assign in_ready = out_ready; // @[connectable.md 284:7] assign out_valid = in_valid; // @[connectable.md 284:7] endmodule Always ignore extra members (partial connection operator) The most unsafe connection is to connect only members that are present in both consumer and producer, and ignore all other members. This is unsafe because this connection will never error on any Chisel types. To do this, you can use .waiveAll and static cast to Data: class OnlyA extends Bundle { val a = UInt(32.W) } class OnlyB extends Bundle { val b = UInt(32.W) } class Example11 extends RawModule { val in = IO(Flipped(new OnlyA)) val out = IO(new OnlyB) out := DontCare (out: Data).waiveAll :&lt;&gt;= (in: Data).waiveAll } This generates the following Verilog, where nothing is connected: module Example11( input [31:0] in_a, // @[connectable.md 308:15] output [31:0] out_b // @[connectable.md 309:15] ); assign out_b = 32'h0; endmodule Connecting components with different widths Non-connectable operators implicitly truncate if a component with a larger width is connected to a component with a smaller width. Connectable operators disallow this implicit truncation behavior and require the driven component to be equal or larger in width that the sourcing component. If implicit truncation behavior is desired, then Connectable provides a squeeze mechanism which will allow the connection to continue and implicit trunction to continue. import scala.collection.immutable.SeqMap import chisel3.experimental.AutoCloneType class Example14 extends RawModule { val p = IO(Flipped(UInt(4.W))) val c = IO(UInt(3.W)) c :&lt;&gt;= p.squeeze } This generates the following Verilog, where p is implicitly truncated prior to driving c: module Example14( input [3:0] p, // @[connectable.md 333:13] output [2:0] c // @[connectable.md 334:13] ); assign c = p[2:0]; // @[connectable.md 336:5] endmodule Techniques for connecting structurally inequivalent Chisel types DataView and viewAsSupertype create a view of the component that has a different Chisel type. This means that a user can first create a DataView of the consumer or producer (or both) so that the Chisel types are structurally equivalent. This is useful when the difference between the consumer and producers aren’t super nested, and also if they have rich Scala types which encode their structure. In general, DataView is the preferred mechanism to use (if you can) because it maintains the most about of Chisel information in the Scala type, but there are many instances where it doesn’t work and thus one must fall back on Connectable. Connectable does not change the Chisel type, but instead changes the semantics of the operator to not error on the waived members if they are dangling or unconnected. This is useful for when differences between the consumer and producer do not show up in the Scala type system (e.g. present/missing fields of type Option[Data], or anonymous Records) or are deeply nested in a bundle that is especially onerous to create a DataView. Static casts (e.g. (x: T)) allows connecting components that have different Scala types, but leaves the Chisel type unchanged. Use this to force a connection to occur, even if the Scala types are different. One may wonder why the operators require identical Scala types in the first place, if they can easily be bypassed. The reason is to encourage users to use the Scala type system to encode Chisel information as it can make their code more robust; however, we don’t want to be draconian about it because there are times when we want to enable the user to “just connect the darn thing”. When all else fails one can always manually expand the connection to do what they want to happen, member by member. The down-side to this approach is its verbosity and that adding new members to a component will require updating the manual connections. Things to remember about Connectable vs viewAsSupertype/DataView vs static cast (e.g. (x: T)): DataView and viewAsSupertype will preemptively remove members that are not present in the new view which has a different Chisel type, thus DataView does affect what is connected Connectable can be used to waive the error on members who end up being dangling or unconnected. Importantly, Connectable does not affect what is connected Static cast does not remove extra members, thus a static cast does not affect what is connected Connecting different sub-types of the same super-type, with colliding names In these examples, we are connecting MyDecoupled with MyDecoupledOtherBits. Both are subtypes of MyReadyValid, and both have a bits field of UInt(32.W). The first example will use .viewAsSupertype to connect them as MyReadyValid. Because it changes the Chisel type to omit both bits fields, the bits fields are unconnected. import experimental.dataview._ class MyDecoupledOtherBits extends MyReadyValid { val bits = UInt(32.W) } class Example12 extends RawModule { val in = IO(Flipped(new MyDecoupled)) val out = IO(new MyDecoupledOtherBits) out := DontCare out.viewAsSupertype(new MyReadyValid) :&lt;&gt;= in.viewAsSupertype(new MyReadyValid) } Note that the bits fields are unconnected. module Example12( input in_valid, // @[connectable.md 358:15] output in_ready, // @[connectable.md 358:15] input [31:0] in_bits, // @[connectable.md 358:15] output out_valid, // @[connectable.md 359:15] input out_ready, // @[connectable.md 359:15] output [31:0] out_bits // @[connectable.md 359:15] ); assign in_ready = out_ready; // @[connectable.md 363:41] assign out_valid = in_valid; // @[connectable.md 363:41] assign out_bits = 32'h0; endmodule The second example will use a static cast and .waive(_.bits) to connect them as MyReadyValid. Note that because the static cast does not change the Chisel type, the connection finds that both consumer and producer have a bits field. This means that since they are structurally equivalent, they match and are connected. The waive(_.bits) does nothing, because the bits are not dangling nor unconnected. import experimental.dataview._ class Example13 extends RawModule { val in = IO(Flipped(new MyDecoupled)) val out = IO(new MyDecoupledOtherBits) out := DontCare out.waiveAs[MyReadyValid](_.bits) :&lt;&gt;= in.waiveAs[MyReadyValid](_.bits) } Note that the bits fields ARE connected, even though they are waived, as waive just changes whether an error should be thrown if they are missing, NOT to not connect them if they are structurally equivalent. module Example13( input in_valid, // @[connectable.md 380:15] output in_ready, // @[connectable.md 380:15] input [31:0] in_bits, // @[connectable.md 380:15] output out_valid, // @[connectable.md 381:15] input out_ready, // @[connectable.md 381:15] output [31:0] out_bits // @[connectable.md 381:15] ); assign in_ready = out_ready; // @[connectable.md 385:37] assign out_valid = in_valid; // @[connectable.md 385:37] assign out_bits = in_bits; // @[connectable.md 385:37] endmodule Connecting sub-types to super-types by waiving extra members Note that in this example, it would be better to use .viewAsSupertype. In the following example, we can use :&lt;&gt;= to connect a MyReadyValid to a MyDecoupled by waiving the bits member. class MyReadyValid extends Bundle { val valid = Bool() val ready = Flipped(Bool()) } class MyDecoupled extends MyReadyValid { val bits = UInt(32.W) } class Example5 extends RawModule { val in = IO(Flipped(new MyDecoupled)) val out = IO(new MyReadyValid) out :&lt;&gt;= in.waiveAs[MyReadyValid](_.bits) } This generates the following Verilog, where ready and valid are connected, and bits is ignored: module Example5( input in_valid, // @[connectable.md 410:15] output in_ready, // @[connectable.md 410:15] input [31:0] in_bits, // @[connectable.md 410:15] output out_valid, // @[connectable.md 411:15] input out_ready // @[connectable.md 411:15] ); assign in_ready = out_ready; // @[connectable.md 412:7] assign out_valid = in_valid; // @[connectable.md 412:7] endmodule Connecting different sub-types Note that in this example, it would be better to use .viewAsSupertype. Note that the connection operator requires the consumer and producer to be the same Scala type to encourage capturing more information statically, but they can always be cast to Data or another common supertype prior to connecting. In the following example, we can use :&lt;&gt;= and waiveAs to connect two different sub-types of MyReadyValid. class HasBits extends MyReadyValid { val bits = UInt(32.W) } class HasEcho extends MyReadyValid { val echo = Flipped(UInt(32.W)) } class Example7 extends RawModule { val in = IO(Flipped(new HasBits)) val out = IO(new HasEcho) out.waiveAs[MyReadyValid](_.echo) :&lt;&gt;= in.waiveAs[MyReadyValid](_.bits) } This generates the following Verilog, where ready and valid are connected, and bits and echo are ignored: module Example7( input in_valid, // @[connectable.md 436:15] output in_ready, // @[connectable.md 436:15] input [31:0] in_bits, // @[connectable.md 436:15] output out_valid, // @[connectable.md 437:15] input out_ready, // @[connectable.md 437:15] input [31:0] out_echo // @[connectable.md 437:15] ); assign in_ready = out_ready; // @[connectable.md 438:37] assign out_valid = in_valid; // @[connectable.md 438:37] endmodule"
    } ,    
    {
      "title": "Deep Dive into <> and := Connection Operators",
      "url": "/chisel3/docs/explanations/connection-operators.html",
      "content": "Deep Dive into Connection Operators Chisel contains two connection operators, := and &lt;&gt;. This document provides a deeper explanation of the differences of the two and when to use one or the other. The differences are demonstrated with experiments using Scastie examples which use DecoupledIO. Experiment Setup // Imports used by the following examples import chisel3._ import chisel3.util.DecoupledIO import circt.stage.ChiselStage The diagram for the experiment can be viewed here. class Wrapper extends Module{ val io = IO(new Bundle { val in = Flipped(DecoupledIO(UInt(8.W))) val out = DecoupledIO(UInt(8.W)) }) val p = Module(new PipelineStage) val c = Module(new PipelineStage) // connect Producer to IO p.io.a &lt;&gt; io.in // connect producer to consumer c.io.a &lt;&gt; p.io.b // connect consumer to IO io.out &lt;&gt; c.io.b } class PipelineStage extends Module{ val io = IO(new Bundle{ val a = Flipped(DecoupledIO(UInt(8.W))) val b = DecoupledIO(UInt(8.W)) }) io.b &lt;&gt; io.a } Below we can see the resulting Verilog for this example: ChiselStage.emitSystemVerilog(new Wrapper) // Running CIRCT: 'firtool -format=fir -warn-on-unprocessed-annotations -verify-each=false -dedup -output-annotation-file circt.anno.json -disable-infer-rw -annotation-file Wrapper.anno.json &lt; $input' // res0: String = \"\"\"// Generated by CIRCT sifive/1/20/0 // module PipelineStage( // &lt;stdin&gt;:3:10, :10:10 // input io_a_valid, // input [7:0] io_a_bits, // input io_b_ready, // output io_a_ready, // io_b_valid, // output [7:0] io_b_bits); // // assign io_a_ready = io_b_ready; // &lt;stdin&gt;:3:10, :10:10 // assign io_b_valid = io_a_valid; // &lt;stdin&gt;:3:10, :10:10 // assign io_b_bits = io_a_bits; // &lt;stdin&gt;:3:10, :10:10 // endmodule // // module Wrapper( // &lt;stdin&gt;:17:10 // input clock, // reset, // io_in_valid, // input [7:0] io_in_bits, // input io_out_ready, // output io_in_ready, // io_out_valid, // output [7:0] io_out_bits); // // wire _c_io_a_ready; // connection-operators.md:26:17 // wire _p_io_b_valid; // connection-operators.md:25:17 // wire [7:0] _p_io_b_bits; // connection-operators.md:25:17 // PipelineStage p ( // connection-operators.md:25:17 // .io_a_valid (io_in_valid), // .io_a_bits (io_in_bits), // .io_b_ready (_c_io_a_ready), // connection-operators.md:26:17 // .io_a_ready (io_in_ready), // .io_b_valid (_p_io_b_valid), // .io_b_bits (_p_io_b_bits) // ); // PipelineStage c ( // connection-operators.md:26:17 // .io_a_valid (_p_io_b_valid), // connection-operators.md:25:17 // .io_a_bits (_p_io_b_bits), // connection-operators.md:25:17 // .io_b_ready (io_out_ready), // .io_a_ready (_c_io_a_ready), // .io_b_valid (io_out_valid), // .io_b_bits (io_out_bits) // ); // endmodule // // \"\"\" Concept 1: &lt;&gt; is Commutative This experiment is set up to test for the function of &lt;&gt; using the experiment above. Achieving this involves flipping the RHS and LHS of the &lt;&gt; operator and seeing how &lt;&gt; will react. ( Scastie link for the experiment:https://scastie.scala-lang.org/Shorla/LVhlbkFQQnq7X3trHfgZZQ ) import chisel3._ import chisel3.util.DecoupledIO import circt.stage.ChiselStage class Wrapper extends Module{ val io = IO(new Bundle { val in = Flipped(DecoupledIO(UInt(8.W))) val out = DecoupledIO(UInt(8.W)) }) val p = Module(new PipelineStage) val c = Module(new PipelineStage) // connect producer to I/O io.in &lt;&gt; p.io.a // connect producer to consumer p.io.b &lt;&gt; c.io.a // connect consumer to I/O c.io.b &lt;&gt; io.out } class PipelineStage extends Module{ val io = IO(new Bundle{ val a = Flipped(DecoupledIO(UInt(8.W))) val b = DecoupledIO(UInt(8.W)) }) io.a &lt;&gt; io.b } Below we can see the resulting Verilog for this example: ChiselStage.emitSystemVerilog(new Wrapper) // Running CIRCT: 'firtool -format=fir -warn-on-unprocessed-annotations -verify-each=false -dedup -output-annotation-file circt.anno.json -disable-infer-rw -annotation-file Wrapper.anno.json &lt; $input' // res2: String = \"\"\"// Generated by CIRCT sifive/1/20/0 // module PipelineStage( // &lt;stdin&gt;:3:10, :10:10 // input io_a_valid, // input [7:0] io_a_bits, // input io_b_ready, // output io_a_ready, // io_b_valid, // output [7:0] io_b_bits); // // assign io_a_ready = io_b_ready; // &lt;stdin&gt;:3:10, :10:10 // assign io_b_valid = io_a_valid; // &lt;stdin&gt;:3:10, :10:10 // assign io_b_bits = io_a_bits; // &lt;stdin&gt;:3:10, :10:10 // endmodule // // module Wrapper( // &lt;stdin&gt;:17:10 // input clock, // reset, // io_in_valid, // input [7:0] io_in_bits, // input io_out_ready, // output io_in_ready, // io_out_valid, // output [7:0] io_out_bits); // // wire _c_io_a_ready; // connection-operators.md:72:17 // wire _p_io_b_valid; // connection-operators.md:71:17 // wire [7:0] _p_io_b_bits; // connection-operators.md:71:17 // PipelineStage p ( // connection-operators.md:71:17 // .io_a_valid (io_in_valid), // .io_a_bits (io_in_bits), // .io_b_ready (_c_io_a_ready), // connection-operators.md:72:17 // .io_a_ready (io_in_ready), // .io_b_valid (_p_io_b_valid), // .io_b_bits (_p_io_b_bits) // ); // PipelineStage c ( // connection-operators.md:72:17 // .io_a_valid (_p_io_b_valid), // connection-operators.md:71:17 // .io_a_bits (_p_io_b_bits), // connection-operators.md:71:17 // .io_b_ready (io_out_ready), // .io_a_ready (_c_io_a_ready), // .io_b_valid (io_out_valid), // .io_b_bits (io_out_bits) // ); // endmodule // // \"\"\" Conclusion: The Verilog remained the same without incurring errors, showing that the &lt;&gt; operator is commutative. Concept 2: := means assign ALL LHS signals from the RHS, regardless of the direction on the LHS. Using the same experiment code as above, we set to test for the function of := We replace all instances of &lt;&gt; with := in the sample code above. (Scastie link to the experiment: https://scastie.scala-lang.org/Shorla/o1ShdaY3RWKf0IIFwwQ1UQ/1) import chisel3._ import chisel3.util.DecoupledIO import circt.stage.ChiselStage class Wrapper extends Module{ val io = IO(new Bundle { val in = Flipped(DecoupledIO(UInt(8.W))) val out = DecoupledIO(UInt(8.W)) }) val p = Module(new PipelineStage) val c = Module(new PipelineStage) // connect producer to I/O p.io.a := io.in // connect producer to consumer c.io.a := p.io.b // connect consumer to I/O io.out := c.io.b } class PipelineStage extends Module{ val io = IO(new Bundle{ val a = Flipped(DecoupledIO(UInt(8.W))) val b = DecoupledIO(UInt(8.W)) }) io.a := io.b } Below we can see the resulting error message for this example: ChiselStage.emitSystemVerilog(new Wrapper) // chisel3.internal.ChiselException: Connection between sink (PipelineStage.io.a: IO[DecoupledIO]) and source (PipelineStage.io.b: IO[DecoupledIO]) failed @: .bitsio.a.bits in PipelineStage cannot be written from module PipelineStage. // at ... () // at repl.MdocSession$MdocApp3$PipelineStage.&lt;init&gt;(connection-operators.md:133) // at repl.MdocSession$MdocApp3$Wrapper$$anonfun$30$$anonfun$apply$20.apply(connection-operators.md:117) // at repl.MdocSession$MdocApp3$Wrapper$$anonfun$30$$anonfun$apply$20.apply(connection-operators.md:117) // at chisel3.Module$.do_apply(Module.scala:53) // at repl.MdocSession$MdocApp3$Wrapper$$anonfun$30.apply(connection-operators.md:117) // at repl.MdocSession$MdocApp3$Wrapper$$anonfun$30.apply(connection-operators.md:117) // at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33) // at repl.MdocSession$MdocApp3$Wrapper.&lt;init&gt;(connection-operators.md:117) // at repl.MdocSession$MdocApp3$$anonfun$39$$anonfun$apply$25.apply(connection-operators.md:141) // at repl.MdocSession$MdocApp3$$anonfun$39$$anonfun$apply$25.apply(connection-operators.md:141) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) Conclusion: The := operator goes field-by-field on the LHS and attempts to connect it to the same-named signal from the RHS. If something on the LHS is actually an Input, or the corresponding signal on the RHS is an Output, you will get an error as shown above. Concept 3: Always Use := to assign DontCare to Wires When assigning DontCare to something that is not directioned, should you use := or &lt;&gt;? We will find out using the sample codes below: ( Scastie link for the experiment:https://scastie.scala-lang.org/Shorla/ZIGsWcylRqKJhZCkKWlSIA/1) import chisel3._ import chisel3.util.DecoupledIO import circt.stage.ChiselStage class Wrapper extends Module{ val io = IO(new Bundle { val in = Flipped(DecoupledIO(UInt(8.W))) val out = DecoupledIO(UInt(8.W)) }) val p = Module(new PipelineStage) val c = Module(new PipelineStage) //connect Producer to IO io.in := DontCare p.io.a &lt;&gt; DontCare val tmp = Wire(Flipped(DecoupledIO(UInt(8.W)))) tmp := DontCare p.io.a &lt;&gt; io.in // connect producer to consumer c.io.a &lt;&gt; p.io.b //connect consumer to IO io.out &lt;&gt; c.io.b } class PipelineStage extends Module{ val io = IO(new Bundle{ val a = Flipped(DecoupledIO(UInt(8.W))) val b = DecoupledIO(UInt(8.W)) }) io.b &lt;&gt; io.a } Below we can see the resulting Verilog for this example: ChiselStage.emitSystemVerilog(new Wrapper) // Running CIRCT: 'firtool -format=fir -warn-on-unprocessed-annotations -verify-each=false -dedup -output-annotation-file circt.anno.json -disable-infer-rw -annotation-file Wrapper.anno.json &lt; $input' // res5: String = \"\"\"// Generated by CIRCT sifive/1/20/0 // module PipelineStage( // &lt;stdin&gt;:3:10, :10:10 // input io_a_valid, // input [7:0] io_a_bits, // input io_b_ready, // output io_a_ready, // io_b_valid, // output [7:0] io_b_bits); // // assign io_a_ready = io_b_ready; // &lt;stdin&gt;:3:10, :10:10 // assign io_b_valid = io_a_valid; // &lt;stdin&gt;:3:10, :10:10 // assign io_b_bits = io_a_bits; // &lt;stdin&gt;:3:10, :10:10 // endmodule // // module Wrapper( // &lt;stdin&gt;:17:10 // input clock, // reset, // io_in_valid, // input [7:0] io_in_bits, // input io_out_ready, // output io_in_ready, // io_out_valid, // output [7:0] io_out_bits); // // wire _c_io_a_ready; // connection-operators.md:168:17 // wire _p_io_b_valid; // connection-operators.md:167:17 // wire [7:0] _p_io_b_bits; // connection-operators.md:167:17 // PipelineStage p ( // connection-operators.md:167:17 // .io_a_valid (io_in_valid), // .io_a_bits (io_in_bits), // .io_b_ready (_c_io_a_ready), // connection-operators.md:168:17 // .io_a_ready (io_in_ready), // .io_b_valid (_p_io_b_valid), // .io_b_bits (_p_io_b_bits) // ); // PipelineStage c ( // connection-operators.md:168:17 // .io_a_valid (_p_io_b_valid), // connection-operators.md:167:17 // .io_a_bits (_p_io_b_bits), // connection-operators.md:167:17 // .io_b_ready (io_out_ready), // .io_a_ready (_c_io_a_ready), // .io_b_valid (io_out_valid), // .io_b_bits (io_out_bits) // ); // endmodule // // \"\"\" Conclusion: If &lt;&gt; were used to assign the unidrectioned wire tmp to DontCare, we would get an error. But in the example above, we used := and no errors occurred. But when := was used to assign the wire to DontCare, no errors will occur. Thus, when assigning DontCare to a Wire, always use :=. Concept 4: You can use &lt;&gt; or := to assign DontCare to directioned things (IOs) When assigning DontCare to something that is directioned, should you use := or &lt;&gt;? We will find out using the sample codes below: ( Scastie link for the experiment:https://scastie.scala-lang.org/Shorla/ZIGsWcylRqKJhZCkKWlSIA/1) import chisel3._ import chisel3.util.DecoupledIO import circt.stage.ChiselStage class Wrapper extends Module{ val io = IO(new Bundle { val in = Flipped(DecoupledIO(UInt(8.W))) val out = DecoupledIO(UInt(8.W)) }) val p = Module(new PipelineStage) val c = Module(new PipelineStage) //connect Producer to IO io.in := DontCare p.io.a &lt;&gt; DontCare val tmp = Wire(Flipped(DecoupledIO(UInt(8.W)))) tmp := DontCare p.io.a &lt;&gt; io.in // connect producer to consumer c.io.a &lt;&gt; p.io.b //connect consumer to IO io.out &lt;&gt; c.io.b } class PipelineStage extends Module{ val io = IO(new Bundle{ val a = Flipped(DecoupledIO(UInt(8.W))) val b = DecoupledIO(UInt(8.W)) }) io.b &lt;&gt; io.a } Below we can see the resulting Verilog for this example: ChiselStage.emitSystemVerilog(new Wrapper) // Running CIRCT: 'firtool -format=fir -warn-on-unprocessed-annotations -verify-each=false -dedup -output-annotation-file circt.anno.json -disable-infer-rw -annotation-file Wrapper.anno.json &lt; $input' // res7: String = \"\"\"// Generated by CIRCT sifive/1/20/0 // module PipelineStage( // &lt;stdin&gt;:3:10, :10:10 // input io_a_valid, // input [7:0] io_a_bits, // input io_b_ready, // output io_a_ready, // io_b_valid, // output [7:0] io_b_bits); // // assign io_a_ready = io_b_ready; // &lt;stdin&gt;:3:10, :10:10 // assign io_b_valid = io_a_valid; // &lt;stdin&gt;:3:10, :10:10 // assign io_b_bits = io_a_bits; // &lt;stdin&gt;:3:10, :10:10 // endmodule // // module Wrapper( // &lt;stdin&gt;:17:10 // input clock, // reset, // io_in_valid, // input [7:0] io_in_bits, // input io_out_ready, // output io_in_ready, // io_out_valid, // output [7:0] io_out_bits); // // wire _c_io_a_ready; // connection-operators.md:218:17 // wire _p_io_b_valid; // connection-operators.md:217:17 // wire [7:0] _p_io_b_bits; // connection-operators.md:217:17 // PipelineStage p ( // connection-operators.md:217:17 // .io_a_valid (io_in_valid), // .io_a_bits (io_in_bits), // .io_b_ready (_c_io_a_ready), // connection-operators.md:218:17 // .io_a_ready (io_in_ready), // .io_b_valid (_p_io_b_valid), // .io_b_bits (_p_io_b_bits) // ); // PipelineStage c ( // connection-operators.md:218:17 // .io_a_valid (_p_io_b_valid), // connection-operators.md:217:17 // .io_a_bits (_p_io_b_bits), // connection-operators.md:217:17 // .io_b_ready (io_out_ready), // .io_a_ready (_c_io_a_ready), // .io_b_valid (io_out_valid), // .io_b_bits (io_out_bits) // ); // endmodule // // \"\"\" Conclusion: Both &lt;&gt; and := can be used to assign directioned things (IOs) to DontCare as shown in io.in and p.io.a respectively. This is basically equivalent because in this case both &lt;&gt; and := will determine the direction from the LHS. Concept 5: &lt;&gt; works between things with at least one known flow (An IO or child’s IO). If there is at least one known flow what will &lt;&gt; do? This will be shown using the experiment code below: ( Scastie link for the experiment:https://scastie.scala-lang.org/Shorla/gKx9ReLVTTqDTk9vmw5ozg) import chisel3._ import chisel3.util.DecoupledIO import circt.stage.ChiselStage class Wrapper extends Module{ val io = IO(new Bundle { val in = Flipped(DecoupledIO(UInt(8.W))) val out = DecoupledIO(UInt(8.W)) }) val p = Module(new PipelineStage) val c = Module(new PipelineStage) //connect Producer to IO // For this experiment, we add a temporary wire and see if it works... //p.io.a &lt;&gt; io.in val tmp = Wire(DecoupledIO(UInt(8.W))) // connect intermediate wire tmp &lt;&gt; io.in p.io.a &lt;&gt; tmp // connect producer to consumer c.io.a &lt;&gt; p.io.b //connect consumer to IO io.out &lt;&gt; c.io.b } class PipelineStage extends Module{ val io = IO(new Bundle{ val a = Flipped(DecoupledIO(UInt(8.W))) val b = DecoupledIO(UInt(8.W)) }) io.b &lt;&gt; io.a } Below we can see the resulting Verilog for this example: ChiselStage.emitSystemVerilog(new Wrapper) // Running CIRCT: 'firtool -format=fir -warn-on-unprocessed-annotations -verify-each=false -dedup -output-annotation-file circt.anno.json -disable-infer-rw -annotation-file Wrapper.anno.json &lt; $input' // res9: String = \"\"\"// Generated by CIRCT sifive/1/20/0 // module PipelineStage( // &lt;stdin&gt;:3:10, :10:10 // input io_a_valid, // input [7:0] io_a_bits, // input io_b_ready, // output io_a_ready, // io_b_valid, // output [7:0] io_b_bits); // // assign io_a_ready = io_b_ready; // &lt;stdin&gt;:3:10, :10:10 // assign io_b_valid = io_a_valid; // &lt;stdin&gt;:3:10, :10:10 // assign io_b_bits = io_a_bits; // &lt;stdin&gt;:3:10, :10:10 // endmodule // // module Wrapper( // &lt;stdin&gt;:17:10 // input clock, // reset, // io_in_valid, // input [7:0] io_in_bits, // input io_out_ready, // output io_in_ready, // io_out_valid, // output [7:0] io_out_bits); // // wire _c_io_a_ready; // connection-operators.md:268:17 // wire _p_io_b_valid; // connection-operators.md:267:17 // wire [7:0] _p_io_b_bits; // connection-operators.md:267:17 // PipelineStage p ( // connection-operators.md:267:17 // .io_a_valid (io_in_valid), // .io_a_bits (io_in_bits), // .io_b_ready (_c_io_a_ready), // connection-operators.md:268:17 // .io_a_ready (io_in_ready), // .io_b_valid (_p_io_b_valid), // .io_b_bits (_p_io_b_bits) // ); // PipelineStage c ( // connection-operators.md:268:17 // .io_a_valid (_p_io_b_valid), // connection-operators.md:267:17 // .io_a_bits (_p_io_b_bits), // connection-operators.md:267:17 // .io_b_ready (io_out_ready), // .io_a_ready (_c_io_a_ready), // .io_b_valid (io_out_valid), // .io_b_bits (io_out_bits) // ); // endmodule // // \"\"\" Conclusion: The connection above went smoothly with no errors, this goes to show &lt;&gt; will work as long as there is at least one directioned thing (IO or submodule’s IO) to “fix” the direction. Concept 6: &lt;&gt; and := connect signals by field name. This experiment creates a MockDecoupledIO which has the same fields by name as a DecoupledIO. Chisel lets us connect it and produces the same verilog, even though MockDecoupledIO and DecoupledIO are different types. ( Scastie link for the experiment:https://scastie.scala-lang.org/Uf4tQquvQYigZAW705NFIQ) import chisel3._ import chisel3.util.DecoupledIO import circt.stage.ChiselStage class MockDecoupledIO extends Bundle { val valid = Output(Bool()) val ready = Input(Bool()) val bits = Output(UInt(8.W)) } class Wrapper extends Module{ val io = IO(new Bundle { val in = Flipped(new MockDecoupledIO()) val out = new MockDecoupledIO() }) val p = Module(new PipelineStage) val c = Module(new PipelineStage) // connect producer to I/O p.io.a &lt;&gt; io.in // connect producer to consumer c.io.a &lt;&gt; p.io.b // connect consumer to I/O io.out &lt;&gt; c.io.b } class PipelineStage extends Module{ val io = IO(new Bundle{ val a = Flipped(DecoupledIO(UInt(8.W))) val b = DecoupledIO(UInt(8.W)) }) io.a &lt;&gt; io.b } Below we can see the resulting Verilog for this example: ChiselStage.emitSystemVerilog(new Wrapper) // Running CIRCT: 'firtool -format=fir -warn-on-unprocessed-annotations -verify-each=false -dedup -output-annotation-file circt.anno.json -disable-infer-rw -annotation-file Wrapper.anno.json &lt; $input' // res11: String = \"\"\"// Generated by CIRCT sifive/1/20/0 // module PipelineStage( // &lt;stdin&gt;:3:10, :10:10 // input io_a_valid, // input [7:0] io_a_bits, // input io_b_ready, // output io_a_ready, // io_b_valid, // output [7:0] io_b_bits); // // assign io_a_ready = io_b_ready; // &lt;stdin&gt;:3:10, :10:10 // assign io_b_valid = io_a_valid; // &lt;stdin&gt;:3:10, :10:10 // assign io_b_bits = io_a_bits; // &lt;stdin&gt;:3:10, :10:10 // endmodule // // module Wrapper( // &lt;stdin&gt;:17:10 // input clock, // reset, // io_in_valid, // input [7:0] io_in_bits, // input io_out_ready, // output io_in_ready, // io_out_valid, // output [7:0] io_out_bits); // // wire _c_io_a_ready; // connection-operators.md:326:17 // wire _p_io_b_valid; // connection-operators.md:325:17 // wire [7:0] _p_io_b_bits; // connection-operators.md:325:17 // PipelineStage p ( // connection-operators.md:325:17 // .io_a_valid (io_in_valid), // .io_a_bits (io_in_bits), // .io_b_ready (_c_io_a_ready), // connection-operators.md:326:17 // .io_a_ready (io_in_ready), // .io_b_valid (_p_io_b_valid), // .io_b_bits (_p_io_b_bits) // ); // PipelineStage c ( // connection-operators.md:326:17 // .io_a_valid (_p_io_b_valid), // connection-operators.md:325:17 // .io_a_bits (_p_io_b_bits), // connection-operators.md:325:17 // .io_b_ready (io_out_ready), // .io_a_ready (_c_io_a_ready), // .io_b_valid (io_out_valid), // .io_b_bits (io_out_bits) // ); // endmodule // // \"\"\" And here is another experiment, where we remove one of the fields of MockDecoupledIO: ( Scastie link for the experiment:https://scastie.scala-lang.org/ChtkhKCpS9CvJkjjqpdeIA) import chisel3._ import chisel3.util.DecoupledIO import circt.stage.ChiselStage class MockDecoupledIO extends Bundle { val valid = Output(Bool()) val ready = Input(Bool()) //val bits = Output(UInt(8.W)) } class Wrapper extends Module{ val io = IO(new Bundle { val in = Flipped(new MockDecoupledIO()) val out = new MockDecoupledIO() }) val p = Module(new PipelineStage) val c = Module(new PipelineStage) // connect producer to I/O p.io.a &lt;&gt; io.in // connect producer to consumer c.io.a &lt;&gt; p.io.b // connect consumer to I/O io.out &lt;&gt; c.io.b } class PipelineStage extends Module{ val io = IO(new Bundle{ val a = Flipped(DecoupledIO(UInt(8.W))) val b = DecoupledIO(UInt(8.W)) }) io.a &lt;&gt; io.b } Below we can see the resulting error for this example: ChiselStage.emitSystemVerilog(new Wrapper) // chisel3.internal.ChiselException: Connection between left (PipelineStage.io.a: IO[DecoupledIO]) and source (Wrapper.io.in: IO[MockDecoupledIO]) failed @.bits: Right Record missing field (bits). // at ... () // at repl.MdocSession$MdocApp12$Wrapper.&lt;init&gt;(connection-operators.md:381) // at repl.MdocSession$MdocApp12$$anonfun$119$$anonfun$apply$79.apply(connection-operators.md:402) // at repl.MdocSession$MdocApp12$$anonfun$119$$anonfun$apply$79.apply(connection-operators.md:402) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) This one fails because there is a field bits missing. Conclusion: For :=, the Scala types do not need to match but all the signals on the LHS must be provided by the RHS or you will get a Chisel elaboration error. There may be additional signals on the RHS, these will be ignored. For &lt;&gt;, the Scala types do not need to match, but all signals must match exactly between LHS and RHS. In both cases, the order of the fields does not matter."
    } ,    
    {
      "title": "General Cookbook",
      "url": "/chisel3/docs/cookbooks/cookbook.html",
      "content": "General Cookbook Please note that these examples make use of Chisel’s scala-style printing. Type Conversions How do I create a UInt from an instance of a Bundle? How do I create a Bundle from a UInt? How can I tieoff a Bundle/Vec to 0? How do I create a Vec of Bools from a UInt? How do I create a UInt from a Vec of Bool? How do I connect a subset of Bundle fields? Vectors and Registers Can I make a 2D or 3D Vector? How do I create a Vector of Registers? How do I create a Reg of type Vec? How do I partially reset an Aggregate Reg? Bundles How do I deal with aliased Bundle fields? How do I create a finite state machine? How do I unpack a value (“reverse concatenation”) like in Verilog? How do I do subword assignment (assign to some bits in a UInt)? How do I create an optional I/O? How do I create I/O without a prefix? How do I minimize the number of bits used in an output vector Predictable Naming How do I get Chisel to name signals properly in blocks like when/withClockAndReset? How do I get Chisel to name the results of vector reads properly? How can I dynamically set/parametrize the name of a module? Directionality How do I strip directions from a bidirectional Bundle (or other Data)? Type Conversions How do I create a UInt from an instance of a Bundle? Call asUInt on the Bundle instance. import chisel3._ class MyBundle extends Bundle { val foo = UInt(4.W) val bar = UInt(4.W) } class Foo extends Module { val bundle = Wire(new MyBundle) bundle.foo := 0xc.U bundle.bar := 0x3.U val uint = bundle.asUInt printf(cf\"$uint\") // 195 // Test assert(uint === 0xc3.U) } How do I create a Bundle from a UInt? Use the asTypeOf method to reinterpret the UInt as the type of the Bundle. import chisel3._ class MyBundle extends Bundle { val foo = UInt(4.W) val bar = UInt(4.W) } class Foo extends Module { val uint = 0xb4.U val bundle = uint.asTypeOf(new MyBundle) printf(cf\"$bundle\") // Bundle(foo -&gt; 11, bar -&gt; 4) // Test assert(bundle.foo === 0xb.U) assert(bundle.bar === 0x4.U) } How can I tieoff a Bundle/Vec to 0? You can use asTypeOf as above. If you don’t want to worry about the type of the thing you are tying off, you can use chiselTypeOf: import chisel3._ import circt.stage.ChiselStage class MyBundle extends Bundle { val foo = UInt(4.W) val bar = Vec(4, UInt(1.W)) } class Foo(typ: MyBundle) extends Module { val bundleA = IO(Output(typ)) val bundleB = IO(Output(typ)) // typ is already a Chisel Data Type, so can use it directly here, but you // need to know that bundleA is of type typ bundleA := 0.U.asTypeOf(typ) // bundleB is a Hardware data IO(Output(...)) so need to call chiselTypeOf, // but this will work no matter the type of bundleB: bundleB := 0.U.asTypeOf(chiselTypeOf(bundleB)) } ChiselStage.emitSystemVerilog(new Foo(new MyBundle)) How do I create a Vec of Bools from a UInt? Use VecInit given a Seq[Bool] generated using the asBools method. import chisel3._ class Foo extends Module { val uint = 0xc.U val vec = VecInit(uint.asBools) printf(cf\"$vec\") // Vec(0, 0, 1, 1) // Test assert(vec(0) === false.B) assert(vec(1) === false.B) assert(vec(2) === true.B) assert(vec(3) === true.B) } How do I create a UInt from a Vec of Bool? Use the builtin function asUInt import chisel3._ class Foo extends Module { val vec = VecInit(true.B, false.B, true.B, true.B) val uint = vec.asUInt printf(cf\"$uint\") // 13 // Test // (remember leftmost Bool in Vec is low order bit) assert(0xd.U === uint) } How do I connect a subset of Bundle fields? See the DataView cookbook. Vectors and Registers Can I make a 2D or 3D Vector? Yes. Using VecInit you can make Vectors that hold Vectors of Chisel types. Methods fill and tabulate make these multi-dimensional Vectors. import chisel3._ class MyBundle extends Bundle { val foo = UInt(4.W) val bar = UInt(4.W) } class Foo extends Module { //2D Fill val twoDVec = VecInit.fill(2, 3)(5.U) //3D Fill val myBundle = Wire(new MyBundle) myBundle.foo := 0xc.U myBundle.bar := 0x3.U val threeDVec = VecInit.fill(1, 2, 3)(myBundle) assert(threeDVec(0)(0)(0).foo === 0xc.U &amp;&amp; threeDVec(0)(0)(0).bar === 0x3.U) //2D Tabulate val indexTiedVec = VecInit.tabulate(2, 2){ (x, y) =&gt; (x + y).U } assert(indexTiedVec(0)(0) === 0.U) assert(indexTiedVec(0)(1) === 1.U) assert(indexTiedVec(1)(0) === 1.U) assert(indexTiedVec(1)(1) === 2.U) //3D Tabulate val indexTiedVec3D = VecInit.tabulate(2, 3, 4){ (x, y, z) =&gt; (x + y * z).U } assert(indexTiedVec3D(0)(0)(0) === 0.U) assert(indexTiedVec3D(1)(1)(1) === 2.U) assert(indexTiedVec3D(1)(1)(2) === 3.U) assert(indexTiedVec3D(1)(1)(3) === 4.U) assert(indexTiedVec3D(1)(2)(3) === 7.U) } How do I create a Vector of Registers? Rule! Use Reg of Vec not Vec of Reg! You create a Reg of type Vec. Because Vecs are a type (like UInt, Bool) rather than a value, we must bind the Vec to some concrete value. How do I create a Reg of type Vec? For more information, the API Documentation for Vec provides more information. import chisel3._ class Foo extends Module { val regOfVec = Reg(Vec(4, UInt(32.W))) // Register of 32-bit UInts regOfVec(0) := 123.U // Assignments to elements of the Vec regOfVec(1) := 456.U regOfVec(2) := 789.U regOfVec(3) := regOfVec(0) // Reg of Vec of 32-bit UInts initialized to zero // Note that Seq.fill constructs 4 32-bit UInt literals with the value 0 // VecInit(...) then constructs a Wire of these literals // The Reg is then initialized to the value of the Wire (which gives it the same type) val initRegOfVec = RegInit(VecInit(Seq.fill(4)(0.U(32.W)))) } How do I partially reset an Aggregate Reg? The easiest way is to use a partially-specified Bundle Literal or Vec Literal to match the type of the Reg. import chisel3._ import chisel3.experimental.BundleLiterals._ class MyBundle extends Bundle { val foo = UInt(8.W) val bar = UInt(8.W) } class MyModule extends Module { // Only .foo will be reset, .bar will have no reset value val reg = RegInit((new MyBundle).Lit(_.foo -&gt; 123.U)) } If your initial value is not a literal, or if you just prefer, you can use a Wire as the initial value for the Reg. Simply connect fields to DontCare that you do not wish to be reset. class MyModule2 extends Module { val reg = RegInit({ // The wire could be constructed before the reg rather than in the RegInit scope, // but this style has nice lexical scoping behavior, keeping the Wire private val init = Wire(new MyBundle) init := DontCare // No fields will be reset init.foo := 123.U // Last connect override, .foo is reset init }) } Bundles How do I deal with aliased Bundle fields? Following the gen pattern when creating Bundles can result in some opaque error messages: class AliasedBundle[T &lt;: Data](gen: T) extends Bundle { val foo = gen val bar = gen } getVerilogString(new Top(new AliasedBundle(UInt(8.W)))) // chisel3.AliasedAggregateFieldException: AliasedBundle contains aliased fields named (bar,foo) // at ... () // at repl.MdocSession$MdocApp17$Top$$anonfun$50$$anonfun$apply$37.apply(cookbook.md:301) // at repl.MdocSession$MdocApp17$Top$$anonfun$50$$anonfun$apply$37.apply(cookbook.md:301) // at chisel3.internal.prefix$.apply(prefix.scala:48) // at repl.MdocSession$MdocApp17$Top$$anonfun$50.apply(cookbook.md:301) // at repl.MdocSession$MdocApp17$Top$$anonfun$50.apply(cookbook.md) // at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33) // at repl.MdocSession$MdocApp17$Top.&lt;init&gt;(cookbook.md:301) // at repl.MdocSession$MdocApp17$$anonfun$55$$anonfun$apply$43.apply(cookbook.md:320) // at repl.MdocSession$MdocApp17$$anonfun$55$$anonfun$apply$43.apply(cookbook.md:320) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) This error is saying that fields foo and bar of AliasedBundle are the exact same object in memory. This is a problem for Chisel because we need to be able to distinguish uses of foo and bar but cannot when they are referentially the same. Note that the following example looks different but will give you exactly the same issue: class AlsoAliasedBundle[T &lt;: Data](val gen: T) extends Bundle { // ^ This val makes `gen` a field, just like `foo` val foo = gen } By making gen a val, it becomes a public field of the class, just like foo. getVerilogString(new Top(new AlsoAliasedBundle(UInt(8.W)))) // chisel3.AliasedAggregateFieldException: AlsoAliasedBundle contains aliased fields named (foo,gen) // at ... () // at repl.MdocSession$MdocApp17$Top$$anonfun$50$$anonfun$apply$37.apply(cookbook.md:301) // at repl.MdocSession$MdocApp17$Top$$anonfun$50$$anonfun$apply$37.apply(cookbook.md:301) // at chisel3.internal.prefix$.apply(prefix.scala:48) // at repl.MdocSession$MdocApp17$Top$$anonfun$50.apply(cookbook.md:301) // at repl.MdocSession$MdocApp17$Top$$anonfun$50.apply(cookbook.md) // at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33) // at repl.MdocSession$MdocApp17$Top.&lt;init&gt;(cookbook.md:301) // at repl.MdocSession$MdocApp17$$anonfun$57$$anonfun$apply$44.apply(cookbook.md:339) // at repl.MdocSession$MdocApp17$$anonfun$57$$anonfun$apply$44.apply(cookbook.md:339) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) There are several ways to solve this issue with their own advantages and disadvantages. 1. 0-arity function parameters Instead of passing an object as a parameter, you can pass a 0-arity function (a function with no arguments): class UsingAFunctionBundle[T &lt;: Data](gen: () =&gt; T) extends Bundle { val foo = gen() val bar = gen() } Note that the type of gen is now () =&gt; T. Because it is now a function and not a subtype of Data, you can safely make gen a val without it becoming a hardware field of the Bundle. Note that this also means you must pass gen as a function, for example: getVerilogString(new Top(new UsingAFunctionBundle(() =&gt; UInt(8.W)))) Warning: you must ensure that gen creates fresh objects rather than capturing an already constructed value: class MisusedFunctionArguments extends Module { // This usage is correct val in = IO(Input(new UsingAFunctionBundle(() =&gt; UInt(8.W)))) // This usage is incorrect val fizz = UInt(8.W) val out = IO(Output(new UsingAFunctionBundle(() =&gt; fizz))) } getVerilogString(new MisusedFunctionArguments) // chisel3.AutoClonetypeException: Automatically cloned UsingAFunctionBundle has field 'foo' aliased with base UsingAFunctionBundle. In the future, this will be solved automatically by the compiler plugin. For now, ensure Chisel types used in the Bundle definition are passed through constructor arguments, or wrapped in Input(...), Output(...), or Flipped(...) if appropriate. As a last resort, you can override cloneType manually. // at ... () // at repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1$$anonfun$62$$anonfun$apply$51$$anonfun$apply$52.apply(cookbook.md:370) // at repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1$$anonfun$62$$anonfun$apply$51$$anonfun$apply$52.apply(cookbook.md:370) // at chisel3.IO$.apply(IO.scala:27) // at chisel3.experimental.BaseModule.IO(Module.scala:566) // at repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1$$anonfun$62$$anonfun$apply$51.apply(cookbook.md:370) // at repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1$$anonfun$62$$anonfun$apply$51.apply(cookbook.md:370) // at chisel3.internal.prefix$.apply(prefix.scala:48) // at repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1$$anonfun$62.apply(cookbook.md:370) // at repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1$$anonfun$62.apply(cookbook.md) // at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33) // at repl.MdocSession$MdocApp17$$anonfun$59$MisusedFunctionArguments$1.&lt;init&gt;(cookbook.md:370) // at repl.MdocSession$MdocApp17$$anonfun$59$$anonfun$apply$55.apply(cookbook.md:372) // at repl.MdocSession$MdocApp17$$anonfun$59$$anonfun$apply$55.apply(cookbook.md:372) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) In the above example, value fizz and fields foo and bar of out are all the same object in memory. 2. By-name function parameters Functionally the same as (1) but with more subtle syntax, you can use Scala by-name function parameters: class UsingByNameParameters[T &lt;: Data](gen: =&gt; T) extends Bundle { val foo = gen val bar = gen } With this usage, you do not include () =&gt; when passing the argument: getVerilogString(new Top(new UsingByNameParameters(UInt(8.W)))) Note that as this is just syntactic sugar over (1), the same warning applies. 3. Directioned Bundle fields You can alternatively wrap the fields with Output(...), which creates fresh instances of the passed argument. Chisel treats Output as the “default direction” so if all fields are outputs, the Bundle is functionally equivalent to a Bundle with no directioned fields. class DirectionedBundle[T &lt;: Data](gen: T) extends Bundle { val foo = Output(gen) val bar = Output(gen) } This approach is admittedly a little ugly and may mislead others reading the code because it implies that this Bundle is intended to be used as an Output. 4. Call .cloneType directly You can also just call .cloneType on your gen argument directly. While we try to hide this implementation detail from the user, .cloneType is the mechanism by which Chisel creates fresh instances of Data objects: class UsingCloneTypeBundle[T &lt;: Data](gen: T) extends Bundle { val foo = gen.cloneType val bar = gen.cloneType } How do I create a finite state machine (FSM)? The advised way is to use ChiselEnum to construct enumerated types representing the state of the FSM. State transitions are then handled with switch/is and when/.elsewhen/.otherwise. import chisel3._ import chisel3.util.{switch, is} object DetectTwoOnes { object State extends ChiselEnum { val sNone, sOne1, sTwo1s = Value } } /* This FSM detects two 1's one after the other */ class DetectTwoOnes extends Module { import DetectTwoOnes.State import DetectTwoOnes.State._ val io = IO(new Bundle { val in = Input(Bool()) val out = Output(Bool()) val state = Output(State()) }) val state = RegInit(sNone) io.out := (state === sTwo1s) io.state := state switch (state) { is (sNone) { when (io.in) { state := sOne1 } } is (sOne1) { when (io.in) { state := sTwo1s } .otherwise { state := sNone } } is (sTwo1s) { when (!io.in) { state := sNone } } } } Note: the is statement can take multiple conditions e.g. is (sTwo1s, sOne1) { ... }. How do I unpack a value (“reverse concatenation”) like in Verilog? In Verilog, you can do something like the following which will unpack a the value z: wire [1:0] a; wire [3:0] b; wire [2:0] c; wire [8:0] z = [...]; assign {a,b,c} = z; Unpacking often corresponds to reinterpreting an unstructured data type as a structured data type. Frequently, this structured type is used prolifically in the design, and has been declared as in the following example: import chisel3._ class MyBundle extends Bundle { val a = UInt(2.W) val b = UInt(4.W) val c = UInt(3.W) } The easiest way to accomplish this in Chisel would be: class Foo extends Module { val z = Wire(UInt(9.W)) z := DontCare // This is a dummy connection val unpacked = z.asTypeOf(new MyBundle) printf(\"%d\", unpacked.a) printf(\"%d\", unpacked.b) printf(\"%d\", unpacked.c) } If you really need to do this for a one-off case (Think thrice! It is likely you can better structure the code using bundles), then rocket-chip has a Split utility which can accomplish this. How do I do subword assignment (assign to some bits in a UInt)? You may try to do something like the following where you want to assign only some bits of a Chisel type. Below, the left-hand side connection to io.out(0) is not allowed. import chisel3._ import circt.stage.ChiselStage class Foo extends Module { val io = IO(new Bundle { val bit = Input(Bool()) val out = Output(UInt(10.W)) }) io.out(0) := io.bit } If you try to compile this, you will get an error. getVerilogString(new Foo) // chisel3.internal.ChiselException: Cannot reassign to read-only Foo.?: OpResult[Bool] // at ... () // at repl.MdocSession$MdocApp26$Foo.&lt;init&gt;(cookbook.md:537) // at repl.MdocSession$MdocApp26$$anonfun$95$$anonfun$apply$79.apply(cookbook.md:545) // at repl.MdocSession$MdocApp26$$anonfun$95$$anonfun$apply$79.apply(cookbook.md:545) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) Chisel3 does not support subword assignment. The reason for this is that subword assignment generally hints at a better abstraction with an aggregate/structured types, i.e., a Bundle or a Vec. If you must express it this way, one approach is to blast your UInt to a Vec of Bool and back: import chisel3._ class Foo extends Module { val io = IO(new Bundle { val in = Input(UInt(10.W)) val bit = Input(Bool()) val out = Output(UInt(10.W)) }) val bools = VecInit(io.in.asBools) bools(0) := io.bit io.out := bools.asUInt } How do I create an optional I/O? The following example is a module which includes the optional port out2 only if the given parameter is true. import chisel3._ class ModuleWithOptionalIOs(flag: Boolean) extends Module { val io = IO(new Bundle { val in = Input(UInt(12.W)) val out = Output(UInt(12.W)) val out2 = if (flag) Some(Output(UInt(12.W))) else None }) io.out := io.in if (flag) { io.out2.get := io.in } } The following is an example where an entire IO is optional: import chisel3._ class ModuleWithOptionalIO(flag: Boolean) extends Module { val in = if (flag) Some(IO(Input(Bool()))) else None val out = IO(Output(Bool())) out := in.getOrElse(false.B) } How do I create I/O without a prefix? In most cases, you can simply call IO multiple times: import chisel3._ class MyModule extends Module { val in = IO(Input(UInt(8.W))) val out = IO(Output(UInt(8.W))) out := in +% 1.U } module MyModule( input clock, input reset, input [7:0] in, // @[cookbook.md 640:14] output [7:0] out // @[cookbook.md 641:15] ); assign out = in + 8'h1; // @[cookbook.md 643:13] endmodule If you have a Bundle from which you would like to create ports without the normal val prefix, you can use FlatIO: import chisel3._ import chisel3.experimental.FlatIO class MyBundle extends Bundle { val foo = Input(UInt(8.W)) val bar = Output(UInt(8.W)) } class MyModule extends Module { val io = FlatIO(new MyBundle) io.bar := io.foo +% 1.U } Note that io_ is nowhere to be seen! module MyModule( input clock, input reset, input [7:0] foo, // @[cookbook.md 672:18] output [7:0] bar // @[cookbook.md 672:18] ); assign bar = foo + 8'h1; // @[cookbook.md 674:20] endmodule How do I minimize the number of bits used in an output vector? Use inferred width and a Seq instead of a Vec: Consider: import chisel3._ // Count the number of set bits up to and including each bit position class CountBits(width: Int) extends Module { val bits = IO(Input(UInt(width.W))) val countSequence = Seq.tabulate(width)(i =&gt; IO(Output(UInt()))) val countVector = IO(Output(Vec(width, UInt()))) countSequence.zipWithIndex.foreach { case (port, i) =&gt; port := util.PopCount(bits(i, 0)) } countVector := countSequence } Unlike Vecs which represent a singular Chisel type and must have the same width for every element, Seq is a purely Scala construct, so their elements are independent from the perspective of Chisel and can have different widths. // Generated by CIRCT sifive/1/20/0 module CountBits( // &lt;stdin&gt;:3:10 input clock, reset, input [3:0] bits, output countSequence_0, output [1:0] countSequence_1, countSequence_2, output [2:0] countSequence_3, countVector_0, countVector_1, countVector_2, countVector_3); Predictable Naming How do I get Chisel to name signals properly in blocks like when/withClockAndReset? Use the compiler plugin, and check out the Naming Cookbook if that still does not do what you want. How do I get Chisel to name the results of vector reads properly? Currently, name information is lost when using dynamic indexing. For example: import chisel3._ class Foo extends Module { val io = IO(new Bundle { val in = Input(Vec(4, Bool())) val idx = Input(UInt(2.W)) val en = Input(Bool()) val out = Output(Bool()) }) val x = io.in(io.idx) val y = x &amp;&amp; io.en io.out := y } The above code loses the x name, instead using _GEN_3 (the other _GEN_* signals are expected). module Foo( input clock, input reset, input io_in_0, // @[cookbook.md 723:14] input io_in_1, // @[cookbook.md 723:14] input io_in_2, // @[cookbook.md 723:14] input io_in_3, // @[cookbook.md 723:14] input [1:0] io_idx, // @[cookbook.md 723:14] input io_en, // @[cookbook.md 723:14] output io_out // @[cookbook.md 723:14] ); wire _GEN_1 = 2'h1 == io_idx ? io_in_1 : io_in_0; // @[cookbook.md 731:{13,13}] wire _GEN_2 = 2'h2 == io_idx ? io_in_2 : _GEN_1; // @[cookbook.md 731:{13,13}] wire _GEN_3 = 2'h3 == io_idx ? io_in_3 : _GEN_2; // @[cookbook.md 731:{13,13}] assign io_out = _GEN_3 &amp; io_en; // @[cookbook.md 731:13] endmodule This can be worked around by creating a wire and connecting the dynamic index to the wire: val x = WireInit(io.in(io.idx)) Which produces: module Foo2( input clock, input reset, input io_in_0, // @[cookbook.md 746:14] input io_in_1, // @[cookbook.md 746:14] input io_in_2, // @[cookbook.md 746:14] input io_in_3, // @[cookbook.md 746:14] input [1:0] io_idx, // @[cookbook.md 746:14] input io_en, // @[cookbook.md 746:14] output io_out // @[cookbook.md 746:14] ); wire _GEN_1 = 2'h1 == io_idx ? io_in_1 : io_in_0; // @[cookbook.md 753:{19,19}] wire _GEN_2 = 2'h2 == io_idx ? io_in_2 : _GEN_1; // @[cookbook.md 753:{19,19}] wire x = 2'h3 == io_idx ? io_in_3 : _GEN_2; // @[cookbook.md 753:{19,19}] assign io_out = x &amp; io_en; // @[cookbook.md 754:13] endmodule How can I dynamically set/parametrize the name of a module? You can override the desiredName function. This works with normal Chisel modules and BlackBoxes. Example: import chisel3._ class Coffee extends BlackBox { val io = IO(new Bundle { val I = Input(UInt(32.W)) val O = Output(UInt(32.W)) }) override def desiredName = \"Tea\" } class Salt extends Module { val io = IO(new Bundle {}) val drink = Module(new Coffee) override def desiredName = \"SodiumMonochloride\" drink.io.I := 42.U } Elaborating the Chisel module Salt yields our “desired names” for Salt and Coffee in the output Verilog: module SodiumMonochloride( input clock, input reset ); wire [31:0] drink_I; // @[cookbook.md 785:23] wire [31:0] drink_O; // @[cookbook.md 785:23] Tea drink ( // @[cookbook.md 785:23] .I(drink_I), .O(drink_O) ); assign drink_I = 32'h2a; // @[cookbook.md 788:16] endmodule Directionality How do I strip directions from a bidirectional Bundle (or other Data)? Given a bidirectional port like a Decoupled, you will get an error if you try to connect it directly to a register: import chisel3._ import circt.stage.ChiselStage import chisel3.util.Decoupled class BadRegConnect extends Module { val io = IO(new Bundle { val enq = Decoupled(UInt(8.W)) }) val monitor = Reg(chiselTypeOf(io.enq)) monitor := io.enq } ChiselStage.emitSystemVerilog(new BadRegConnect) // circt.stage.phases.Exceptions$FirtoolNonZeroExitCode: firtool returned a non-zero exit code // ------------------------------------------------------------------------------ // ExitCode: // 1 // STDOUT: // // STDERR: // cookbook.md:818:20: error: 'firrtl.reg' op result #0 must be a passive base type that does not contain analog, but got '!firrtl.bundle&lt;ready flip: uint&lt;1&gt;, valid: uint&lt;1&gt;, bits: uint&lt;8&gt;&gt;' // cookbook.md:818:20: note: see current operation: %5 = \"firrtl.reg\"(%arg0) {annotations = [], name = \"monitor\", nameKind = #firrtl&lt;name_kind interesting_name&gt;} : (!firrtl.clock) -&gt; !firrtl.bundle&lt;ready flip: uint&lt;1&gt;, valid: uint&lt;1&gt;, bits: uint&lt;8&gt;&gt; // // ------------------------------------------------------------------------------ // at circt.stage.phases.CIRCT.transform(CIRCT.scala:255) // at circt.stage.phases.CIRCT.transform(CIRCT.scala:117) // at firrtl.options.DependencyManager.$anonfun$transform$5(DependencyManager.scala:280) // at firrtl.Utils$.time(Utils.scala:181) // at firrtl.options.DependencyManager.$anonfun$transform$3(DependencyManager.scala:280) // at scala.collection.LinearSeqOptimized.foldLeft(LinearSeqOptimized.scala:126) // at scala.collection.LinearSeqOptimized.foldLeft$(LinearSeqOptimized.scala:122) // at scala.collection.immutable.List.foldLeft(List.scala:91) // at firrtl.options.DependencyManager.transform(DependencyManager.scala:269) // at firrtl.options.DependencyManager.transform$(DependencyManager.scala:255) // at firrtl.options.PhaseManager.transform(DependencyManager.scala:443) // at circt.stage.ChiselStage$.emitSystemVerilog(ChiselStage.scala:114) // at repl.MdocSession$MdocApp44$$anonfun$158.apply(cookbook.md:827) // at repl.MdocSession$MdocApp44$$anonfun$158.apply(cookbook.md:827) While there is no construct to “strip direction” in Chisel3, wrapping a type in Output(...) (the default direction in Chisel3) will set all of the individual elements to output direction. This will have the desired result when used to construct a Register: import chisel3._ import circt.stage.ChiselStage import chisel3.util.Decoupled class CoercedRegConnect extends Module { val io = IO(new Bundle { val enq = Flipped(Decoupled(UInt(8.W))) }) // Make a Reg which contains all of the bundle's signals, regardless of their directionality val monitor = Reg(Output(chiselTypeOf(io.enq))) // Even though io.enq is bidirectional, := will drive all fields of monitor with the fields of io.enq monitor := io.enq }"
    } ,    
    {
      "title": "Cookbooks",
      "url": "/chisel3/docs/cookbooks/cookbooks.html",
      "content": "Cookbooks Welcome to the Chisel Cookbooks, where we capture frequently-used design patterns or troubleshooting questions. If you have any requests or examples to share, please file an issue and let us know! General Cookbooks Verilog vs. Chisel Side-by-Side Naming Cookbook Troubleshooting Guide Hierarchy Cookbook DataView Cookbook"
    } ,    
    {
      "title": "Chisel Data Types",
      "url": "/chisel3/docs/explanations/data-types.html",
      "content": "Chisel Data Types Chisel datatypes are used to specify the type of values held in state elements or flowing on wires. While hardware designs ultimately operate on vectors of binary digits, other more abstract representations for values allow clearer specifications and help the tools generate more optimal circuits. In Chisel, a raw collection of bits is represented by the Bits type. Signed and unsigned integers are considered subsets of fixed-point numbers and are represented by types SInt and UInt respectively. Signed fixed-point numbers, including integers, are represented using two’s-complement format. Boolean values are represented as type Bool. Note that these types are distinct from Scala’s builtin types such as Int or Boolean. There is a new experimental type Interval which gives the developer more control of the type by allowing the definition of an IntervalRange. See: Interval Type Additionally, Chisel defines Bundles for making collections of values with named fields (similar to structs in other languages), and Vecs for indexable collections of values. Bundles and Vecs will be covered later. Constant or literal values are expressed using Scala integers or strings passed to constructors for the types: 1.U // decimal 1-bit lit from Scala Int. \"ha\".U // hexadecimal 4-bit lit from string. \"o12\".U // octal 4-bit lit from string. \"b1010\".U // binary 4-bit lit from string. 5.S // signed decimal 4-bit lit from Scala Int. -8.S // negative decimal 4-bit lit from Scala Int. 5.U // unsigned decimal 3-bit lit from Scala Int. 8.U(4.W) // 4-bit unsigned decimal, value 8. -152.S(32.W) // 32-bit signed decimal, value -152. true.B // Bool lits from Scala lits. false.B Underscores can be used as separators in long string literals to aid readability, but are ignored when creating the value, e.g.: \"h_dead_beef\".U // 32-bit lit of type UInt By default, the Chisel compiler will size each constant to the minimum number of bits required to hold the constant, including a sign bit for signed types. Bit widths can also be specified explicitly on literals, as shown below. Note that (.W is used to cast a Scala Int to a Chisel width) \"ha\".asUInt(8.W) // hexadecimal 8-bit lit of type UInt \"o12\".asUInt(6.W) // octal 6-bit lit of type UInt \"b1010\".asUInt(12.W) // binary 12-bit lit of type UInt 5.asSInt(7.W) // signed decimal 7-bit lit of type SInt 5.asUInt(8.W) // unsigned decimal 8-bit lit of type UInt For literals of type UInt, the value is zero-extended to the desired bit width. For literals of type SInt, the value is sign-extended to fill the desired bit width. If the given bit width is too small to hold the argument value, then a Chisel error is generated. We are working on a more concise literal syntax for Chisel using symbolic prefix operators, but are stymied by the limitations of Scala operator overloading and have not yet settled on a syntax that is actually more readable than constructors taking strings. We have also considered allowing Scala literals to be automatically converted to Chisel types, but this can cause type ambiguity and requires an additional import. The SInt and UInt types will also later support an optional exponent field to allow Chisel to automatically produce optimized fixed-point arithmetic circuits. Casting We can also cast types in Chisel: val sint = 3.S(4.W) // 4-bit SInt val uint = sint.asUInt // cast SInt to UInt uint.asSInt // cast UInt to SInt NOTE: asUInt/asSInt with an explicit width can not be used to cast (convert) between Chisel datatypes. No width parameter is accepted, as Chisel will automatically pad or truncate as required when the objects are connected. We can also perform casts on clocks, though you should be careful about this, since clocking (especially in ASIC) requires special attention: val bool: Bool = false.B // always-low wire val clock = bool.asClock // always-low clock clock.asUInt // convert clock to UInt (width 1) clock.asUInt.asBool // convert clock to Bool (Chisel 3.2+) clock.asUInt.toBool // convert clock to Bool (Chisel 3.0 and 3.1 only) Analog/BlackBox type (Experimental, Chisel 3.1+) Chisel supports an Analog type (equivalent to Verilog inout) that can be used to support arbitrary nets in Chisel. This includes analog wires, tri-state/bi-directional wires, and power nets (with appropriate annotations). Analog is an undirectioned type, and so it is possible to connect multiple Analog nets together using the attach operator. It is possible to connect an Analog once using &lt;&gt; but illegal to do it more than once. val a = IO(Analog(1.W)) val b = IO(Analog(1.W)) val c = IO(Analog(1.W)) // Legal attach(a, b) attach(a, c) // Legal a &lt;&gt; b // Illegal - connects 'a' multiple times a &lt;&gt; b a &lt;&gt; c"
    } ,    
    {
      "title": "DataView Cookbook",
      "url": "/chisel3/docs/cookbooks/dataview.html",
      "content": "DataView Cookbook How do I view a Data as a UInt or vice versa? How do I create a DataView for a Bundle has a type parameter? How do I create a DataView for a Bundle with optional fields? How do I connect a subset of Bundle fields? How do I view a Bundle as a parent type (superclass)? How do I view a Bundle as a parent type when the parent type is abstract (like a trait)? How can I use .viewAs instead of .viewAsSupertype(type)? How do I view a Data as a UInt or vice versa? Subword viewing (using concatenations or bit extractions in DataViews) is not yet supported. We intend to implement this in the future, but for the time being, use regular casts (.asUInt and .asTypeOf). How do I create a DataView for a Bundle has a type parameter? Instead of using a val, use a def which can have type parameters: import chisel3._ import chisel3.experimental.dataview._ class Foo[T &lt;: Data](val foo: T) extends Bundle class Bar[T &lt;: Data](val bar: T) extends Bundle object Foo { implicit def view[T &lt;: Data]: DataView[Foo[T], Bar[T]] = { DataView(f =&gt; new Bar(f.foo.cloneType), _.foo -&gt; _.bar) // .cloneType is necessary because the f passed to this function will be bound hardware } } If you think about type parameterized classes as really being a family of different classes (one for each type parameter), you can think about the implicit def as a generator of DataViews for each type parameter. How do I create a DataView for a Bundle with optional fields? Instead of using the default DataView apply method, use DataView.mapping: import chisel3._ import chisel3.experimental.dataview._ class Foo(val w: Option[Int]) extends Bundle { val foo = UInt(8.W) val opt = w.map(x =&gt; UInt(x.W)) } class Bar(val w: Option[Int]) extends Bundle { val bar = UInt(8.W) val opt = w.map(x =&gt; UInt(x.W)) } object Foo { implicit val view: DataView[Foo, Bar] = DataView.mapping( // First argument is always the function to make the view from the target f =&gt; new Bar(f.w), // Now instead of a varargs of tuples of individual mappings, we have a single function that // takes a target and a view and returns an Iterable of tuple (f, b) =&gt; List(f.foo -&gt; b.bar) ++ f.opt.map(_ -&gt; b.opt.get) // ^ Note that we can append options since they are Iterable! ) } How do I connect a subset of Bundle fields? Chisel 3 requires types to match exactly for connections. DataView provides a mechanism for “viewing” one Bundle object as if it were the type of another, which allows them to be connected. How do I view a Bundle as a parent type (superclass)? For viewing Bundles as the type of the parent, it is as simple as using viewAsSupertype and providing a template object of the parent type: import chisel3._ import chisel3.experimental.dataview._ class Foo extends Bundle { val foo = UInt(8.W) } class Bar extends Foo { val bar = UInt(8.W) } class MyModule extends Module { val foo = IO(Input(new Foo)) val bar = IO(Output(new Bar)) bar.viewAsSupertype(new Foo) := foo // bar.foo := foo.foo bar.bar := 123.U // all fields need to be connected } // Generated by CIRCT sifive/1/20/0 module MyModule( // &lt;stdin&gt;:3:10 input clock, reset, input [7:0] foo_foo, output [7:0] bar_foo, bar_bar); assign bar_foo = foo_foo; // &lt;stdin&gt;:3:10 assign bar_bar = 8'h7B; // &lt;stdin&gt;:3:10, dataview.md:121:11 endmodule How do I view a Bundle as a parent type when the parent type is abstract (like a trait)? Given the following Bundles that share a common trait: import chisel3._ import chisel3.experimental.dataview._ trait Super extends Bundle { def bitwidth: Int val a = UInt(bitwidth.W) } class Foo(val bitwidth: Int) extends Super { val foo = UInt(8.W) } class Bar(val bitwidth: Int) extends Super { val bar = UInt(8.W) } Foo and Bar cannot be connected directly, but they could be connected by viewing them both as if they were instances of their common supertype, Super. A straightforward approach might run into an issue like the following: class MyModule extends Module { val foo = IO(Input(new Foo(8))) val bar = IO(Output(new Bar(8))) bar.viewAsSupertype(new Super) := foo.viewAsSupertype(new Super) } // error: trait Super is abstract; cannot be instantiated // bar.viewAsSupertype(new Super) := foo.viewAsSupertype(new Super) // ^^^^^^^^^ // error: trait Super is abstract; cannot be instantiated // bar.viewAsSupertype(new Super) := foo.viewAsSupertype(new Super) // ^^^^^^^^^ The problem is that viewAs requires an object to use as a type template (so that it can be cloned), but traits are abstract and cannot be instantiated. The solution is to create an instance of an anonymous class and use that object as the argument to viewAs. We can do this like so: class MyModule extends Module { val foo = IO(Input(new Foo(8))) val bar = IO(Output(new Bar(8))) val tpe = new Super { // Adding curly braces creates an anonymous class def bitwidth = 8 // We must implement any abstract methods } bar.viewAsSupertype(tpe) := foo.viewAsSupertype(tpe) } By adding curly braces after the name of the trait, we’re telling Scala to create a new concrete subclass of the trait, and create an instance of it. As indicated in the comment, abstract methods must still be implemented. This is the same that happens when one writes new Bundle {}, the curly braces create a new concrete subclass; however, because Bundle has no abstract methods, the contents of the body can be empty. How can I use .viewAs instead of .viewAsSupertype(type)? While viewAsSupertype is helpful for one-off casts, the need to provide a type template object each time can be onerous. Because of the subtyping relationship, you can use PartialDataView.supertype to create a DataView from a Bundle type to a parent type by just providing the function to construct an instance of the parent type from an instance of the child type. The mapping of corresponding fields is automatically determined by Chisel to be the fields defined in the supertype. import chisel3._ import chisel3.experimental.dataview._ class Foo(x: Int) extends Bundle { val foo = UInt(x.W) } class Bar(val x: Int) extends Foo(x) { val bar = UInt(x.W) } // Define a DataView without having to specify the mapping! implicit val view = PartialDataView.supertype[Bar, Foo](b =&gt; new Foo(b.x)) class MyModule extends Module { val foo = IO(Input(new Foo(8))) val bar = IO(Output(new Bar(8))) bar.viewAs[Foo] := foo // bar.foo := foo.foo bar.bar := 123.U // all fields need to be connected } // Generated by CIRCT sifive/1/20/0 module MyModule( // &lt;stdin&gt;:3:10 input clock, reset, input [7:0] foo_foo, output [7:0] bar_foo, bar_bar); assign bar_foo = foo_foo; // &lt;stdin&gt;:3:10 assign bar_bar = 8'h7B; // &lt;stdin&gt;:3:10, dataview.md:207:11 endmodule"
    } ,    
    {
      "title": "DataView",
      "url": "/chisel3/docs/explanations/dataview.html",
      "content": "DataView New in Chisel 3.5 Introduction DataView is a mechanism for “viewing” Scala objects as a subtype of chisel3.Data. Often, this is useful for viewing one subtype of chisel3.Data, as another. One can think about a DataView as a mapping from a Target type T to a View type V. This is similar to a cast (eg. .asTypeOf) with a few differences: Views are connectable—connections to the view will occur on the target Whereas casts are structural (a reinterpretation of the underlying bits), a DataView is a customizable mapping Views can be partial—not every field in the target must be included in the mapping A Motivating Example (AXI4) AXI4 is a common interface in digital design. A typical Verilog peripheral using AXI4 will define a write channel as something like: module my_module( // Write Channel input AXI_AWVALID, output AXI_AWREADY, input [3:0] AXI_AWID, input [19:0] AXI_AWADDR, input [1:0] AXI_AWLEN, input [1:0] AXI_AWSIZE, // ... ); This would correspond to the following Chisel Bundle: class VerilogAXIBundle(val addrWidth: Int) extends Bundle { val AWVALID = Output(Bool()) val AWREADY = Input(Bool()) val AWID = Output(UInt(4.W)) val AWADDR = Output(UInt(addrWidth.W)) val AWLEN = Output(UInt(2.W)) val AWSIZE = Output(UInt(2.W)) // The rest of AW and other AXI channels here } // Instantiated as class my_module extends RawModule { val AXI = IO(new VerilogAXIBundle(20)) } Expressing something that matches a standard Verilog interface is important when instantiating Verilog modules in a Chisel design as BlackBoxes. Generally though, Chisel developers prefer to use composition via utilities like Decoupled rather than a flat handling of ready and valid as in the above. A more “Chisel-y” implementation of this interface might look like: // Note that both the AW and AR channels look similar and could use the same Bundle definition class AXIAddressChannel(val addrWidth: Int) extends Bundle { val id = UInt(4.W) val addr = UInt(addrWidth.W) val len = UInt(2.W) val size = UInt(2.W) // ... } import chisel3.util.Decoupled // We can compose the various AXI channels together class AXIBundle(val addrWidth: Int) extends Bundle { val aw = Decoupled(new AXIAddressChannel(addrWidth)) // val ar = new AXIAddressChannel // ... Other channels here ... } // Instantiated as class MyModule extends RawModule { val axi = IO(new AXIBundle(20)) } Of course, this would result in very different looking Verilog: module MyModule( input axi_aw_ready, // @[dataview.md 53:15] output axi_aw_valid, // @[dataview.md 53:15] output [3:0] axi_aw_bits_id, // @[dataview.md 53:15] output [19:0] axi_aw_bits_addr, // @[dataview.md 53:15] output [1:0] axi_aw_bits_len, // @[dataview.md 53:15] output [1:0] axi_aw_bits_size // @[dataview.md 53:15] ); assign axi_aw_valid = 1'h0; assign axi_aw_bits_id = 4'h0; assign axi_aw_bits_addr = 20'h0; assign axi_aw_bits_len = 2'h0; assign axi_aw_bits_size = 2'h0; endmodule So how can we use our more structured types while maintaining expected Verilog interfaces? Meet DataView: import chisel3.experimental.dataview._ // We recommend putting DataViews in a companion object of one of the involved types object AXIBundle { // Don't be afraid of the use of implicits, we will discuss this pattern in more detail later implicit val axiView = DataView[VerilogAXIBundle, AXIBundle]( // The first argument is a function constructing an object of View type (AXIBundle) // from an object of the Target type (VerilogAXIBundle) vab =&gt; new AXIBundle(vab.addrWidth), // The remaining arguments are a mapping of the corresponding fields of the two types _.AWVALID -&gt; _.aw.valid, _.AWREADY -&gt; _.aw.ready, _.AWID -&gt; _.aw.bits.id, _.AWADDR -&gt; _.aw.bits.addr, _.AWLEN -&gt; _.aw.bits.len, _.AWSIZE -&gt; _.aw.bits.size, // ... ) } This DataView is a mapping between our flat, Verilog-style AXI Bundle to our more compositional, Chisel-style AXI Bundle. It allows us to define our ports to match the expected Verilog interface, while manipulating it as if it were the more structured type: class AXIStub extends RawModule { val AXI = IO(new VerilogAXIBundle(20)) val view = AXI.viewAs[AXIBundle] // We can now manipulate `AXI` via `view` view.aw.bits := 0.U.asTypeOf(new AXIAddressChannel(20)) // zero everything out by default view.aw.valid := true.B when (view.aw.ready) { view.aw.bits.id := 5.U view.aw.bits.addr := 1234.U // We can still manipulate AXI as well AXI.AWLEN := 1.U } } This will generate Verilog that matches the standard naming convention: module AXIStub( output AXI_AWVALID, // @[dataview.md 94:15] input AXI_AWREADY, // @[dataview.md 94:15] output [3:0] AXI_AWID, // @[dataview.md 94:15] output [19:0] AXI_AWADDR, // @[dataview.md 94:15] output [1:0] AXI_AWLEN, // @[dataview.md 94:15] output [1:0] AXI_AWSIZE // @[dataview.md 94:15] ); assign AXI_AWVALID = 1'h1; // @[dataview.md 99:17] assign AXI_AWID = AXI_AWREADY ? 4'h5 : 4'h0; // @[dataview.md 100:24 101:21 98:16] assign AXI_AWADDR = AXI_AWREADY ? 20'h4d2 : 20'h0; // @[dataview.md 100:24 102:23 98:16] assign AXI_AWLEN = AXI_AWREADY ? 2'h1 : 2'h0; // @[dataview.md 100:24 104:15 98:16] assign AXI_AWSIZE = 2'h0; // @[dataview.md 98:{31,31}] endmodule Note that if both the Target and the View types are subtypes of Data (as they are in this example), the DataView is invertible. This means that we can easily create a DataView[AXIBundle, VerilogAXIBundle] from our existing DataView[VerilogAXIBundle, AXIBundle], all we need to do is provide a function to construct a VerilogAXIBundle from an instance of an AXIBundle: // Note that typically you should define these together (eg. inside object AXIBundle) implicit val axiView2 = AXIBundle.axiView.invert(ab =&gt; new VerilogAXIBundle(ab.addrWidth)) The following example shows this and illustrates another use case of DataView—connecting unrelated types: class ConnectionExample extends RawModule { val in = IO(new AXIBundle(20)) val out = IO(Flipped(new VerilogAXIBundle(20))) out.viewAs[AXIBundle] &lt;&gt; in } This results in the corresponding fields being connected in the emitted Verilog: module ConnectionExample( input in_aw_ready, // @[dataview.md 125:14] output in_aw_valid, // @[dataview.md 125:14] output [3:0] in_aw_bits_id, // @[dataview.md 125:14] output [19:0] in_aw_bits_addr, // @[dataview.md 125:14] output [1:0] in_aw_bits_len, // @[dataview.md 125:14] output [1:0] in_aw_bits_size, // @[dataview.md 125:14] input out_AWVALID, // @[dataview.md 126:15] output out_AWREADY, // @[dataview.md 126:15] input [3:0] out_AWID, // @[dataview.md 126:15] input [19:0] out_AWADDR, // @[dataview.md 126:15] input [1:0] out_AWLEN, // @[dataview.md 126:15] input [1:0] out_AWSIZE // @[dataview.md 126:15] ); assign in_aw_valid = out_AWVALID; // @[dataview.md 127:25] assign in_aw_bits_id = out_AWID; // @[dataview.md 127:25] assign in_aw_bits_addr = out_AWADDR; // @[dataview.md 127:25] assign in_aw_bits_len = out_AWLEN; // @[dataview.md 127:25] assign in_aw_bits_size = out_AWSIZE; // @[dataview.md 127:25] assign out_AWREADY = in_aw_ready; // @[dataview.md 127:25] endmodule Other Use Cases While the ability to map between Bundle types as in the AXI4 example is pretty compelling, DataView has many other applications. Importantly, because the Target of the DataView need not be a Data, it provides a way to use non-Data objects with APIs that require Data. Tuples Perhaps the most helpful use of DataView for a non-Data type is viewing Scala tuples as Bundles. For example, in Chisel prior to the introduction of DataView, one might try to Mux tuples and see an error like the following: class TupleExample extends RawModule { val a, b, c, d = IO(Input(UInt(8.W))) val cond = IO(Input(Bool())) val x, y = IO(Output(UInt(8.W))) (x, y) := Mux(cond, (a, b), (c, d)) } // error: value := is not a member of (chisel3.UInt, chisel3.UInt) // Expression does not convert to assignment because receiver is not assignable. // (x, y) := Mux(cond, (a, b), (c, d)) // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ // error: inferred type arguments [(chisel3.UInt, chisel3.UInt)] do not conform to macro method apply's type parameter bounds [T &lt;: chisel3.Data] // (x, y) := Mux(cond, (a, b), (c, d)) // ^^^ // error: type mismatch; // found : (chisel3.UInt, chisel3.UInt) // required: T // (x, y) := Mux(cond, (a, b), (c, d)) // ^^^^^^ // error: type mismatch; // found : (chisel3.UInt, chisel3.UInt) // required: T // (x, y) := Mux(cond, (a, b), (c, d)) // ^^^^^^ The issue, is that Chisel primitives like Mux and := only operate on subtypes of Data and Tuples (as members of the Scala standard library), are not subclasses of Data. DataView provides a mechanism to view a Tuple as if it were a Data: // We need a type to represent the Tuple class HWTuple2[A &lt;: Data, B &lt;: Data](val _1: A, val _2: B) extends Bundle // Provide DataView between Tuple and HWTuple implicit def view[A &lt;: Data, B &lt;: Data]: DataView[(A, B), HWTuple2[A, B]] = DataView(tup =&gt; new HWTuple2(tup._1.cloneType, tup._2.cloneType), _._1 -&gt; _._1, _._2 -&gt; _._2) Now, we can use .viewAs to view Tuples as if they were subtypes of Data: class TupleVerboseExample extends RawModule { val a, b, c, d = IO(Input(UInt(8.W))) val cond = IO(Input(Bool())) val x, y = IO(Output(UInt(8.W))) (x, y).viewAs[HWTuple2[UInt, UInt]] := Mux(cond, (a, b).viewAs[HWTuple2[UInt, UInt]], (c, d).viewAs[HWTuple2[UInt, UInt]]) } This is much more verbose than the original idea of just using the Tuples directly as if they were Data. We can make this better by providing an implicit conversion that views a Tuple as a HWTuple2: implicit def tuple2hwtuple[A &lt;: Data, B &lt;: Data](tup: (A, B)): HWTuple2[A, B] = tup.viewAs[HWTuple2[A, B]] Now, the original code just works! class TupleExample extends RawModule { val a, b, c, d = IO(Input(UInt(8.W))) val cond = IO(Input(Bool())) val x, y = IO(Output(UInt(8.W))) (x, y) := Mux(cond, (a, b), (c, d)) } Note that this example ignored DataProduct which is another required piece (see the documentation about it below). All of this is available to users via a single import: import chisel3.experimental.conversions._ Totality and PartialDataView A DataView is total if all fields of the Target type and all fields of the View type are included in the mapping. Chisel will error if a field is accidentally left out from a DataView. For example: class BundleA extends Bundle { val foo = UInt(8.W) val bar = UInt(8.W) } class BundleB extends Bundle { val fizz = UInt(8.W) } // We forgot BundleA.foo in the mapping! implicit val myView = DataView[BundleA, BundleB](_ =&gt; new BundleB, _.bar -&gt; _.fizz) class BadMapping extends Module { val in = IO(Input(new BundleA)) val out = IO(Output(new BundleB)) out := in.viewAs[BundleB] } // We must run Chisel to see the error getVerilogString(new BadMapping) // chisel3.experimental.dataview.package$InvalidViewException: Viewing BadMapping.in: IO[BundleA] as BundleB is non-Total! // Target field '_.foo' is missing. // DataView used is DataView(defined @[dataview.md 228:49]). // If the view *should* be non-total, try a 'PartialDataView'. // at ... () // at repl.MdocSession$MdocApp6$$anonfun$55$BadMapping$1$$anonfun$60.apply(dataview.md:232) // at repl.MdocSession$MdocApp6$$anonfun$55$BadMapping$1$$anonfun$60.apply(dataview.md:232) // at chisel3.Data.$anonfun$$colon$eq$1(Data.scala:719) // at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23) // at chisel3.internal.prefix$.apply(prefix.scala:31) // at chisel3.Data.$colon$eq(Data.scala:719) // at repl.MdocSession$MdocApp6$$anonfun$55$BadMapping$1.&lt;init&gt;(dataview.md:232) // at repl.MdocSession$MdocApp6$$anonfun$55$$anonfun$apply$67.apply(dataview.md:234) // at repl.MdocSession$MdocApp6$$anonfun$55$$anonfun$apply$67.apply(dataview.md:234) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) As that error suggests, if we want the view to be non-total, we can use a PartialDataView: // A PartialDataView does not have to be total for the Target implicit val myView = PartialDataView[BundleA, BundleB](_ =&gt; new BundleB, _.bar -&gt; _.fizz) // myView: DataView[BundleA, BundleB] = PartialDataView(defined @[dataview.md 243:56]) class PartialDataViewModule extends Module { val in = IO(Input(new BundleA)) val out = IO(Output(new BundleB)) out := in.viewAs[BundleB] } module PartialDataViewModule( input clock, input reset, input [7:0] in_foo, // @[dataview.md 247:15] input [7:0] in_bar, // @[dataview.md 247:15] output [7:0] out_fizz // @[dataview.md 248:16] ); assign out_fizz = in_bar; // @[dataview.md 249:8] endmodule While PartialDataViews need not be total for the Target, both PartialDataViews and DataViews must always be total for the View. This has the consequence that PartialDataViews are not invertible in the same way as DataViews. For example: implicit val myView2 = myView.invert(_ =&gt; new BundleA) class PartialDataViewModule2 extends Module { val in = IO(Input(new BundleA)) val out = IO(Output(new BundleB)) // Using the inverted version of the mapping out.viewAs[BundleA] := in } // We must run Chisel to see the error getVerilogString(new PartialDataViewModule2) // chisel3.experimental.dataview.package$InvalidViewException: Cannot invert 'PartialDataView(defined @[dataview.md 243:56])' as it is non-total. // Try providing a DataView[MdocApp6.this.BundleB, MdocApp6.this.BundleA]. // Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview. // at chisel3.experimental.dataview.DataView$InvertibleDataView.invert(DataView.scala:139) // at repl.MdocSession$MdocApp6$$anonfun$67.apply(dataview.md:263) // at repl.MdocSession$MdocApp6$$anonfun$67.apply(dataview.md:262) As noted, the mapping must always be total for the View. Advanced Details DataView takes advantage of features of Scala that may be new to many users of Chisel—in particular Type Classes. Type Classes Type classes are powerful language feature for writing polymorphic code. They are a common feature in “modern programming languages” like Scala, Swift (see protocols), and Rust (see traits). Type classes may appear similar to inheritance in object-oriented programming but there are some important differences: You can provide a type class for a type you don’t own (eg. one defined in a 3rd party library, the Scala standard library, or Chisel itself) You can write a single type class for many types that do not have a sub-typing relationship You can provide multiple different type classes for the same type For DataView, (1) is crucial because we want to be able to implement DataViews of built-in Scala types like tuples and Seqs. Furthermore, DataView has two type parameters (the Target and the View types) so inheritance does not really make sense—which type would extend DataView? In Scala 2, type classes are not a built-in language feature, but rather are implemented using implicits. There are great resources out there for interested readers: Basic Tutorial Fantastic Explanation on StackOverflow Note that Scala 3 has added built-in syntax for type classes that does not apply to Chisel 3 which currently only supports Scala 2. Implicit Resolution Given that DataView is implemented using implicits, it is important to understand implicit resolution. Whenever the compiler sees an implicit argument is required, it first looks in current scope before looking in the implicit scope. Current scope Values defined in the current scope Explicit imports Wildcard imports Implicit scope Companion object of a type Implicit scope of an argument’s type Implicit scope of type parameters If at either stage, multiple implicits are found, then the static overloading rule is used to resolve it. Put simply, if one implicit applies to a more-specific type than the other, the more-specific one will be selected. If multiple implicits apply within a given stage, then the compiler throws an ambiguous implicit resolution error. This section draws heavily from [1] and [2]. In particular, see [1] for examples. Implicit Resolution Example To help clarify a bit, let us consider how implicit resolution works for DataView. Consider the definition of viewAs: def viewAs[V &lt;: Data](implicit dataView: DataView[T, V]): V Armed with the knowledge from the previous section, we know that whenever we call .viewAs, the Scala compiler will first look for a DataView[T, V] in the current scope (defined in, or imported), then it will look in the companion objects of DataView, T, and V. This enables a fairly powerful pattern, namely that default or typical implementations of a DataView should be defined in the companion object for one of the two types. We can think about DataViews defined in this way as “low priority defaults”. They can then be overruled by a specific import if a given user ever wants different behavior. For example: Given the following types: class Foo extends Bundle { val a = UInt(8.W) val b = UInt(8.W) } class Bar extends Bundle { val c = UInt(8.W) val d = UInt(8.W) } object Foo { implicit val f2b = DataView[Foo, Bar](_ =&gt; new Bar, _.a -&gt; _.c, _.b -&gt; _.d) implicit val b2f = f2b.invert(_ =&gt; new Foo) } This provides an implementation of DataView in the implicit scope as a “default” mapping between Foo and Bar (and it doesn’t even require an import!): class FooToBar extends Module { val foo = IO(Input(new Foo)) val bar = IO(Output(new Bar)) bar := foo.viewAs[Bar] } module FooToBar( input clock, input reset, input [7:0] foo_a, // @[dataview.md 301:15] input [7:0] foo_b, // @[dataview.md 301:15] output [7:0] bar_c, // @[dataview.md 302:15] output [7:0] bar_d // @[dataview.md 302:15] ); assign bar_c = foo_a; // @[dataview.md 303:7] assign bar_d = foo_b; // @[dataview.md 303:7] endmodule However, it’s possible that some user of Foo and Bar wants different behavior, perhaps they would prefer more of “swizzling” behavior rather than a direct mapping: object Swizzle { implicit val swizzle = DataView[Foo, Bar](_ =&gt; new Bar, _.a -&gt; _.d, _.b -&gt; _.c) } // Current scope always wins over implicit scope import Swizzle._ class FooToBarSwizzled extends Module { val foo = IO(Input(new Foo)) val bar = IO(Output(new Bar)) bar := foo.viewAs[Bar] } module FooToBarSwizzled( input clock, input reset, input [7:0] foo_a, // @[dataview.md 325:15] input [7:0] foo_b, // @[dataview.md 325:15] output [7:0] bar_c, // @[dataview.md 326:15] output [7:0] bar_d // @[dataview.md 326:15] ); assign bar_c = foo_b; // @[dataview.md 327:7] assign bar_d = foo_a; // @[dataview.md 327:7] endmodule DataProduct DataProduct is a type class used by DataView to validate the correctness of a user-provided mapping. In order for a type to be “viewable” (ie. the Target type of a DataView), it must have an implementation of DataProduct. For example, say we have some non-Bundle type: // Loosely based on chisel3.util.Counter class MyCounter(val width: Int) { /** Indicates if the Counter is incrementing this cycle */ val active = WireDefault(false.B) val value = RegInit(0.U(width.W)) def inc(): Unit = { active := true.B value := value + 1.U } def reset(): Unit = { value := 0.U } } Say we want to view MyCounter as a Valid[UInt]: import chisel3.util.Valid implicit val counterView = DataView[MyCounter, Valid[UInt]](c =&gt; Valid(UInt(c.width.W)), _.value -&gt; _.bits, _.active -&gt; _.valid) // error: myView is already defined as value myView // implicit val myView = PartialDataView[BundleA, BundleB](_ =&gt; new BundleB, _.bar -&gt; _.fizz) // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ // error: Could not find implicit value for DataView[MdocApp1.this.BundleA, MdocApp1.this.BundleB]. // Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview // out := in.viewAs[BundleB] // ^ // error: Could not find implicit value for DataView[MdocApp1.this.BundleA, MdocApp1.this.BundleB]. // Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview // out := in.viewAs[BundleB] // ^ // error: Could not find implicit value for DataView[MdocApp1.this.BundleB, MdocApp1.this.BundleA]. // Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview // out.viewAs[BundleA] := in // ^^^^^^^^^^^^^^^^^^^ // error: Could not find implicit value for DataProduct[MdocApp1.this.MyCounter]. // Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview#dataproduct // implicit val counterView = DataView[MyCounter, Valid[UInt]](c =&gt; Valid(UInt(c.width.W)), _.value -&gt; _.bits, _.active -&gt; _.valid) // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ As you can see, this fails Scala compliation. We need to provide an implementation of DataProduct[MyCounter] which provides Chisel a way to access the objects of type Data within MyCounter: import chisel3.util.Valid implicit val counterProduct = new DataProduct[MyCounter] { // The String part of the tuple is a String path to the object to help in debugging def dataIterator(a: MyCounter, path: String): Iterator[(Data, String)] = List(a.value -&gt; s\"$path.value\", a.active -&gt; s\"$path.active\").iterator } // Now this works implicit val counterView = DataView[MyCounter, Valid[UInt]](c =&gt; Valid(UInt(c.width.W)), _.value -&gt; _.bits, _.active -&gt; _.valid) Why is this useful? This is how Chisel is able to check for totality as described above. In addition to checking if a user has left a field out of the mapping, it also allows Chisel to check if the user has included a Data in the mapping that isn’t actually a part of the target nor the view."
    } ,    
    {
      "title": "Decoders",
      "url": "/chisel3/docs/explanations/decoder.html",
      "content": "Decoders It is common in a complex design to recognize certain patterns from a big UInt coming from a data bus and dispatch actions to next pipeline stage based on such observation. The circuit doing so can be called as ‘decoders’ such as address decoders in a bus crossbar or instruction decoders in a CPU frontend. Chisel provides some utility class to generate them in util.exprimental.decode package. Basic Decoders The simplest API provided by decoder is essentially just a TruthTable encoding your desired input and output. import chisel3._ import chisel3.util.BitPat import chisel3.util.experimental.decode._ class SimpleDecoder extends Module { val table = TruthTable( Map( BitPat(\"b001\") -&gt; BitPat(\"b?\"), BitPat(\"b010\") -&gt; BitPat(\"b?\"), BitPat(\"b100\") -&gt; BitPat(\"b1\"), BitPat(\"b101\") -&gt; BitPat(\"b1\"), BitPat(\"b111\") -&gt; BitPat(\"b1\") ), BitPat(\"b0\")) val input = IO(Input(UInt(3.W))) val output = IO(Output(UInt(1.W))) output := decoder(input, table) } DecoderTable When the decoded result involves multiple fields, each with its own semantics, the TruthTable can quickly be become hard to maintain. The DecoderTable API is designed to generate decoder table from structured definitions. The bridge from structured information to its encoding is DecodePattern trait. The bitPat member defines the input BitPat in the decode truth table, and other members can be defined to contain structured information. To generate output side of the decode truth table, the trait to use is DecodeField. Given an instance implementing the DecodePattern object, the genTable method should return desired output. import chisel3.util.BitPat import chisel3.util.experimental.decode._ case class Pattern(val name: String, val code: BigInt) extends DecodePattern { def bitPat: BitPat = BitPat(\"b\" + code.toString(2)) } object NameContainsAdd extends BoolDecodeField[Pattern] { def name = \"name contains 'add'\" def genTable(i: Pattern) = if (i.name.contains(\"add\")) y else n } Then all DecodePattern cases can be generated or read from external sources. And with all DecodeField objects, the decoder can be easily generated and output can be read by corresponding DecodeFields. import chisel3._ import chisel3.util.experimental.decode._ class SimpleDecodeTable extends Module { val allPossibleInputs = Seq(Pattern(\"addi\", BigInt(\"0x2\")) /* can be generated */) val decodeTable = new DecodeTable(allPossibleInputs, Seq(NameContainsAdd)) val input = IO(Input(UInt(4.W))) val isAddType = IO(Output(Bool())) val decodeResult = decodeTable.decode(input) isAddType := decodeResult(NameContainsAdd) }"
    } ,    
    {
      "title": "Developers",
      "url": "/chisel3/docs/developers/developers.html",
      "content": "Developer Documentation Tips and tricks for Chisel developers: Embedding Chisel as an sbt subproject Test Coverage Developers Style Guide"
    } ,    
    {
      "title": "Experimental Features",
      "url": "/chisel3/docs/appendix/experimental-features.html",
      "content": "Experimental Features Chisel has a number of new features that are worth checking out. This page is an informal list of these features and projects. FixedPoint Module Variants Bundle Literals Vec Literals Interval Type Loading Memories for simulation or FPGA initialization FixedPoint FixedPoint numbers are basic Data type along side of UInt, SInt, etc. Most common math and logic operations are supported. Chisel allows both the width and binary point to be inferred by the Firrtl compiler which can simplify circuit descriptions. See FixedPointSpec Module Variants The standard Chisel Module requires a val io = IO(...), the experimental package introduces several new ways of defining Modules BaseModule: no contents, instantiable BlackBox extends BaseModule UserDefinedModule extends BaseModule: this module can contain Chisel RTL. No default clock or reset lines. No default IO. - User should be able to specify non-io ports, ideally multiple of them. ImplicitModule extends UserModule: has clock, reset, and io, essentially current Chisel Module. RawModule: will be the user-facing version of UserDefinedModule Module: type-aliases to ImplicitModule, the user-facing version of ImplicitModule. Bundle Literals Bundle literals can be constructed via an experimental import: import chisel3._ import chisel3.experimental.BundleLiterals._ class MyBundle extends Bundle { val a = UInt(8.W) val b = Bool() } class Example extends RawModule { val out = IO(Output(new MyBundle)) out := (new MyBundle).Lit(_.a -&gt; 8.U, _.b -&gt; true.B) } // Generated by CIRCT sifive/1/20/0 module Example( // &lt;stdin&gt;:3:10 output [7:0] out_a, output out_b); assign out_a = 8'h8; // &lt;stdin&gt;:3:10, experimental-features.md:22:7 assign out_b = 1'h1; // &lt;stdin&gt;:3:10, experimental-features.md:22:7 endmodule Partial specification is allowed, which results in “invalidated fields” as described in Unconnected Wires. Note that this can be used with RegInit to construct partially reset registers as described in the Cookbook. class Example2 extends RawModule { val out = IO(Output(new MyBundle)) out := (new MyBundle).Lit(_.b -&gt; true.B) } // Generated by CIRCT sifive/1/20/0 module Example2( // &lt;stdin&gt;:3:10 output [7:0] out_a, output out_b); assign out_a = 8'h0; // &lt;stdin&gt;:3:10, experimental-features.md:37:7 assign out_b = 1'h1; // &lt;stdin&gt;:3:10, experimental-features.md:37:7 endmodule Bundle literals can also be nested arbitrarily. class ChildBundle extends Bundle { val foo = UInt(8.W) } class ParentBundle extends Bundle { val a = UInt(8.W) val b = new ChildBundle } class Example3 extends RawModule { val out = IO(Output(new ParentBundle)) out := (new ParentBundle).Lit(_.a -&gt; 123.U, _.b -&gt; (new ChildBundle).Lit(_.foo -&gt; 42.U)) } // Generated by CIRCT sifive/1/20/0 module Example3( // &lt;stdin&gt;:3:10 output [7:0] out_a, out_b_foo); assign out_a = 8'h7B; // &lt;stdin&gt;:3:10, experimental-features.md:63:7 assign out_b_foo = 8'h2A; // &lt;stdin&gt;:3:10, experimental-features.md:63:7 endmodule Vec Literals Vec literals are very similar to Bundle literals and can be constructed via an experimental import. They can be constructed in two forms, with type and length inferred as in: import chisel3._ import chisel3.experimental.VecLiterals._ class VecExample1 extends Module { val out = IO(Output(Vec(2, UInt(4.W)))) out := Vec.Lit(0xa.U, 0xbb.U) } // Generated by CIRCT sifive/1/20/0 module VecExample1( // &lt;stdin&gt;:3:10 input clock, reset, output [3:0] out_0, out_1); assign out_0 = 4'hA; // &lt;stdin&gt;:3:10, experimental-features.md:84:7 assign out_1 = 4'hB; // &lt;stdin&gt;:3:10, experimental-features.md:84:7 endmodule or explicitly as in: import chisel3._ import chisel3.experimental.VecLiterals._ class VecExample1a extends Module { val out = IO(Output(Vec(2, UInt(4.W)))) out := Vec(2, UInt(4.W)).Lit(0 -&gt; 1.U, 1 -&gt; 2.U) } // Generated by CIRCT sifive/1/20/0 module VecExample1a( // &lt;stdin&gt;:3:10 input clock, reset, output [3:0] out_0, out_1); assign out_0 = 4'h1; // &lt;stdin&gt;:3:10, experimental-features.md:105:7 assign out_1 = 4'h2; // &lt;stdin&gt;:3:10, experimental-features.md:105:7 endmodule The following examples all use the explicit form. With the explicit form partial specification is allowed, which results in “invalidated fields” as described in Unconnected Wires. Note that this can be used with RegInit to construct partially reset registers as described in the Cookbook. class VecExample2 extends RawModule { val out = IO(Output(Vec(4, UInt(4.W)))) out := Vec(4, UInt(4.W)).Lit(0 -&gt; 1.U, 3 -&gt; 7.U) } // Generated by CIRCT sifive/1/20/0 module VecExample2( // &lt;stdin&gt;:3:10 output [3:0] out_0, out_1, out_2, out_3); assign out_0 = 4'h1; // &lt;stdin&gt;:3:10, experimental-features.md:120:7 assign out_1 = 4'h0; // &lt;stdin&gt;:3:10, experimental-features.md:120:7 assign out_2 = 4'h0; // &lt;stdin&gt;:3:10, experimental-features.md:120:7 assign out_3 = 4'h7; // &lt;stdin&gt;:3:10, experimental-features.md:120:7 endmodule Registers can be initialized from Vec literals class VecExample3 extends Module { val out = IO(Output(Vec(4, UInt(8.W)))) val y = RegInit( Vec(4, UInt(8.W)).Lit(0 -&gt; 0xAB.U(8.W), 1 -&gt; 0xCD.U(8.W), 2 -&gt; 0xEF.U(8.W), 3 -&gt; 0xFF.U(8.W)) ) out := y } // Generated by CIRCT sifive/1/20/0 module VecExample3( // &lt;stdin&gt;:3:10 input clock, reset, output [7:0] out_0, out_1, out_2, out_3); assign out_0 = 8'hAB; // &lt;stdin&gt;:3:10, experimental-features.md:135:18 assign out_1 = 8'hCD; // &lt;stdin&gt;:3:10, experimental-features.md:135:18 assign out_2 = 8'hEF; // &lt;stdin&gt;:3:10, experimental-features.md:135:18 assign out_3 = 8'hFF; // &lt;stdin&gt;:3:10, experimental-features.md:135:18 endmodule Vec literals can also be nested arbitrarily. class VecExample5 extends RawModule { val out = IO(Output(Vec(2, new ChildBundle))) out := Vec(2, new ChildBundle).Lit( 0 -&gt; (new ChildBundle).Lit(_.foo -&gt; 42.U), 1 -&gt; (new ChildBundle).Lit(_.foo -&gt; 7.U) ) } // Generated by CIRCT sifive/1/20/0 module VecExample5( // &lt;stdin&gt;:3:10 output [7:0] out_0_foo, out_1_foo); assign out_0_foo = 8'h2A; // &lt;stdin&gt;:3:10, experimental-features.md:153:7 assign out_1_foo = 8'h7; // &lt;stdin&gt;:3:10, experimental-features.md:153:7 endmodule Interval Type Intervals are a new experimental numeric type that comprises UInt, SInt and FixedPoint numbers. It augments these types with range information, i.e. upper and lower numeric bounds. This information can be used to exercise tighter programmatic control over the ultimate widths of signals in the final circuit. The Firrtl compiler can infer this range information based on operations and earlier values in the circuit. Intervals support all the ordinary bit and arithmetic operations associated with UInt, SInt, and FixedPoint and adds the following methods for manipulating the range of a source Interval with the IntervalRange of target Interval Clip – Fit the value source into the IntervalRange of target, saturate if out of bounds The clip method applied to an interval creates a new interval based on the argument to clip, and constructs the necessary hardware so that the source Interval’s value will be mapped into the new Interval. Values that are outside the result range will be pegged to either maximum or minimum of result range as appropriate. Generates necessary hardware to clip values, values greater than range are set to range.high, values lower than range are set to range min. Wrap – Fit the value source into the IntervalRange of target, wrapping around if out of bounds The wrap method applied to an interval creates a new interval based on the argument to wrap, and constructs the necessary hardware so that the source Interval’s value will be mapped into the new Interval. Values that are outside the result range will be wrapped until they fall within the result range. Generates necessary hardware to wrap values, values greater than range are set to range.high, values lower than range are set to range min. Does not handle out of range values that are less than half the minimum or greater than twice maximum Squeeze – Fit the value source into the smallest IntervalRange based on source and target. The squeeze method applied to an interval creates a new interval based on the argument to clip, the two ranges must overlap behavior of squeeze with inputs outside of the produced range is undefined. Generates no hardware, strictly a sizing operation Range combinations Condition A.clip(B) A.wrap(B) A.squeeze(B) A === B max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) A contains B max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) B contains A max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) A min &lt; B min, A max in B max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) A min in B, A max &gt; B max max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) A strictly less than B error error error A strictly greater than B error error error Applying binary point operators to an Interval Consider a Interval with a binary point of 3: aaa.bbb operation after operation binary point lower upper meaning setBinaryPoint(2) aaa.bb 2 X X set the precision shiftLeftBinaryPoint(2) a.aabbb 5 X X increase the precision shiftRighBinaryPoint(2) aaaa.b 1 X X reduce the precision Loading Memories for simulation or FPGA initialization Chisel supports multiple experimental methods for annotating memories to be loaded from a text file containing hex or binary data. When using verilog simulation it uses the $readmemh or $readmemb verilog extension. The treadle simulator can also load memories using the same annotation. Inline initialization with external file Memories can be initialized by generating inline readmemh or readmemb statements in the output Verilog. The function loadMemoryFromFileInline from chisel3.util.experimental allows the memory to be initialized by the synthesis software from the specified file. Chisel does not validate the file contents nor its location. Both the memory initialization file and the Verilog source should be accessible for the toolchain. import chisel3._ import chisel3.util.experimental.loadMemoryFromFileInline class InitMemInline(memoryFile: String = \"\") extends Module { val width: Int = 32 val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val addr = Input(UInt(10.W)) val dataIn = Input(UInt(width.W)) val dataOut = Output(UInt(width.W)) }) val mem = SyncReadMem(1024, UInt(width.W)) // Initialize memory if (memoryFile.trim().nonEmpty) { loadMemoryFromFileInline(mem, memoryFile) } io.dataOut := DontCare when(io.enable) { val rdwrPort = mem(io.addr) when (io.write) { rdwrPort := io.dataIn } .otherwise { io.dataOut := rdwrPort } } } The default is to use $readmemh (which assumes all numbers in the file are in ascii hex), but to use ascii binary there is an optional hexOrBinary argument which can be set to MemoryLoadFileType.Hex or MemoryLoadFileType.Binary. You will need to add an additional import. By default, the inline initialization will generate the memory readmem statements inside an ifndef SYNTHESIS block, which suits ASIC workflow. Some synthesis tools (like Synplify and Yosys) define SYNTHESIS so the readmem statement is not read when inside this block. To control this, one can use the MemoryNoSynthInit and MemorySynthInit annotations from firrtl.annotations. The former which is the default setting when no annotation is present generates readmem inside the block. Using the latter, the statement are generated outside the ifndef block so it can be used by FPGA synthesis tools. Below an example for initialization suited for FPGA workflows: import chisel3._ import chisel3.util.experimental.loadMemoryFromFileInline import chisel3.experimental.{annotate, ChiselAnnotation} import firrtl.annotations.MemorySynthInit class InitMemInlineFPGA(memoryFile: String = \"\") extends Module { val width: Int = 32 val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val addr = Input(UInt(10.W)) val dataIn = Input(UInt(width.W)) val dataOut = Output(UInt(width.W)) }) // Notice the annotation below annotate(new ChiselAnnotation { override def toFirrtl = MemorySynthInit }) val mem = SyncReadMem(1024, UInt(width.W)) if (memoryFile.trim().nonEmpty) { loadMemoryFromFileInline(mem, memoryFile) } io.dataOut := DontCare when(io.enable) { val rdwrPort = mem(io.addr) when (io.write) { rdwrPort := io.dataIn } .otherwise { io.dataOut := rdwrPort } } } SystemVerilog Bind Initialization Chisel can also initialize memories by generating a SV bind module with readmemh or readmemb statements by using the function loadMemoryFromFile from chisel3.util.experimental. import chisel3._ import chisel3.util.experimental.loadMemoryFromFile class InitMemBind(val bits: Int, val size: Int, filename: String) extends Module { val io = IO(new Bundle { val nia = Input(UInt(bits.W)) val insn = Output(UInt(32.W)) }) val memory = Mem(size, UInt(32.W)) io.insn := memory(io.nia &gt;&gt; 2); loadMemoryFromFile(memory, filename) } Which generates the bind module: module BindsTo_0_Foo( input clock, input reset, input [31:0] io_nia, output [31:0] io_insn ); initial begin $readmemh(\"test.hex\", Foo.memory); end endmodule bind Foo BindsTo_0_Foo BindsTo_0_Foo_Inst(.*); Notes on files There is no simple answer to where to put the hex or bin file with the initial contents. It’s probably best to create a resource directory somewhere and reference that through a full path or place the file beside the generated Verilog. Another option is adding the path to the memory file in the synthesis tool path. Because these files may be large, Chisel does not copy them. Don’t forget there is no decimal option, so a 10 in an input file will be 16 decimal See: ComplexMemoryLoadingSpec.scala and LoadMemoryFromFileSpec.scala for working examples. Aggregate memories Aggregate memories are supported but in bit of a clunky way. Since they will be split up into a memory per field, the following convention was adopted. When specifying the file for such a memory the file name should be regarded as a template. If the memory is a Bundle e.g. class MemDataType extends Bundle { val a = UInt(16.W) val b = UInt(32.W) val c = Bool() } The memory will be split into memory_a, memory_b, and memory_c. Similarly if a load file is specified as \"memory-load.txt\" the simulation will expect that there will be three files, \"memory-load_a.txt\", \"memory-load_b.txt\", \"memory-load_c.txt\" Note: The use of _ and that the memory field name is added before any file suffix. The suffix is optional but if present is considered to be the text after the last . in the file name."
    } ,    
    {
      "title": "Explanations",
      "url": "/chisel3/docs/explanations/explanations.html",
      "content": "Explanations Explanation documentation gives background and context. They can also explain why things are so - design decisions, historical reasons, technical constraints. If you are just getting started with Chisel, we suggest you read these documents in the following order: Motivation Supported Hardware Data Types DataView Bundles and Vecs Combinational Circuits Operators Width Inference Functional Abstraction Ports Modules Sequential Circuits Memories Interfaces and Connections Black Boxes Enumerations Functional Module Creation Muxes and Input Selection Multiple Clock Domains Reset Polymorphism and Paramterization Printing in Chisel Naming Unconnected Wires Annotations Deep Dive into Connection Operators Chisel Type vs Scala Type Connectable Operators"
    } ,    
    {
      "title": "Frequently Asked Questions",
      "url": "/chisel3/docs/resources/faqs.html",
      "content": "Frequently Asked Questions Where should I start if I want to learn Chisel? How do I … in Chisel? What versions of the various projects work together? How can I contribute to Chisel? Why DecoupledIO instead of ReadyValidIO? Why do I have to wrap module instantiations in Module(...)? Why Chisel? Does Chisel support X and Z logic values? I just want some Verilog; what do I do? I just want some FIRRTL; what do I do? Why doesn’t Chisel tell me which wires aren’t connected? What does Reference ... is not fully initialized. mean? Can I specify behavior before and after generated initial blocks? Where should I start if I want to learn Chisel? We recommend the Chisel Bootcamp for getting started with Chisel. How do I do … (e.g. like that in Verilog) in Chisel? See the cookbooks. What versions of the various projects work together? See Chisel Project Versioning. How can I contribute to Chisel? Check out the Contributor Documentation in the chisel3 repository. Why DecoupledIO instead of ReadyValidIO? There are multiple kinds of Ready/Valid interfaces that impose varying restrictions on the producers and consumers. Chisel currently provides the following: DecoupledIO - No guarantees IrrevocableIO - Producer promises to not change the value of ‘bits’ after a cycle where ‘valid’ is high and ‘ready’ is low. Additionally, once ‘valid’ is raised it will never be lowered until after ‘ready’ has also been raised. Why do I have to wrap module instantiations in Module(...)? In short: Limitations of Scala Chisel Modules are written by defining a Scala class and implementing its constructor. As elaboration runs, Chisel constructs a hardware AST from these Modules. The compiler needs hooks to run before and after the actual construction of the Module object. In Scala, superclasses are fully initialized before subclasses, so by extending Module, Chisel has the ability to run some initialization code before the user’s Module is constructed. However, there is no such hook to run after the Module object is initialized. By wrapping Module instantiations in the Module object’s apply method (ie. Module(...)), Chisel is able to perform post-initialization actions. There is a proposed solution, so eventually this requirement will be lifted, but for now, wrap those Modules! Why Chisel? Please see Chisel Motivation Does Chisel support X and Z logic values Chisel does not directly support Verilog logic values x unknown and z high-impedance. There are a number of reasons to want to avoid these values. See:The Dangers of Living With An X and Malicious LUT: A stealthy FPGA Trojan injected and triggered by the design flow. Chisel has its own eco-system of unit and functional testers that limit the need for x and z and their omission simplify language implementation, design, and testing. The circuits created by chisel do not preclude developers from using x and z in downstream toolchains as they see fit. Get me Verilog I wrote a module and I want to see the Verilog; what do I do? Here’s a simple hello world module in a file HelloWorld.scala. package intro import chisel3._ class HelloWorld extends Module { val io = IO(new Bundle{}) printf(\"hello world\\n\") } Add the following import circt.stage.ChiselStage object VerilogMain extends App { ChiselStage.emitSystemVerilog(new HelloWorld) } Now you can get some Verilog. Start sbt: bash&gt; sbt &gt; run-main intro.VerilogMain [info] Running intro.VerilogMain [info] [0.004] Elaborating design... [info] [0.100] Done elaborating. [success] Total time: 1 s, completed Jan 12, 2017 6:24:03 PM or as a one-liner: bash&gt; sbt 'runMain intro.VerilogMain' After either of the above there will be a HelloWorld.v file in the current directory: // Generated by CIRCT sifive/1/20/0 // Standard header to adapt well known macros to our needs. // Users can define 'PRINTF_COND' to add an extra gate to prints. `ifdef PRINTF_COND `define PRINTF_COND_ (`PRINTF_COND) `else // PRINTF_COND `define PRINTF_COND_ 1 `endif // PRINTF_COND module HelloWorld( // &lt;stdin&gt;:3:10 input clock, reset); `ifndef SYNTHESIS // faqs.md:13:9 always @(posedge clock) begin // faqs.md:13:9 if ((`PRINTF_COND_) &amp; ~reset) // faqs.md:13:9 $fwrite(32'h80000002, \"hello world\\n\"); // faqs.md:13:9 end // always @(posedge) `endif // not def SYNTHESIS endmodule You can see additional options with bash&gt; sbt 'runMain intro.HelloWorld --help' This will return a comprehensive usage line with available options. For example to place the output in a directory name buildstuff use bash&gt; sbt 'runMain intro.HelloWorld --target-dir buildstuff --top-name HelloWorld' Alternatively, you can also use the sbt console to invoke the Verilog driver: $ sbt &gt; console [info] Starting scala interpreter... Welcome to Scala 2.12.13 (OpenJDK 64-Bit Server VM, Java 1.8.0_275). Type in expressions for evaluation. Or try :help. scala&gt; (new circt.stage.ChiselStage).emitSystemVerilog(new HelloWorld()) chisel3.Driver.execute(Array[String](), () =&gt; new HelloWorld) Elaborating design... Done elaborating. res1: String = \"module HelloWorld( input clock, input reset ); ... As before, there should be a HelloWorld.v file in the current directory. Note: Using the following, without the new, will ONLY return the string representation, and will not emit a .v file: ChiselStage.emitSystemVerilog(new HelloWorld()) Get me FIRRTL If for some reason you don’t want the Verilog (e.g. maybe you want to run some custom transformations before exporting to Verilog), then use something along these lines: package intro import chisel3._ import circt.stage.ChiselStage class MyFirrtlModule extends Module { val io = IO(new Bundle{}) } object FirrtlMain extends App { ChiselStage.emitCHIRRTL(new MyFirrtlModule) } Run it with: sbt 'runMain intro.FirrtlMain' FIRRTL version 1.1.0 circuit MyFirrtlModule : module MyFirrtlModule : input clock : Clock input reset : UInt&lt;1&gt; output io : { } @[faqs.md 65:14] skip Alternatively, you can also use the sbt console to invoke the FIRRTL driver directly (replace MyFirrtlModule with your module name): $ sbt &gt; console [info] Starting scala interpreter... Welcome to Scala 2.12.13 (OpenJDK 64-Bit Server VM, Java 1.8.0_275). Type in expressions for evaluation. Or try :help. scala&gt; circt.stage.ChiselStage.emitCHIRRTL(new MyFirrtlModule) Elaborating design... Done elaborating. res3: String = ... Why doesn’t Chisel tell me which wires aren’t connected? As long as your code uses import chisel3._ (and not import Chisel._), it does! See Unconnected Wires for details. What does Reference ... is not fully initialized. mean? It means that you have unconnected wires in your design which could be an indication of a design bug. In Chisel2 compatibility mode (NotStrict compile options), chisel generates firrtl code that disables firrtl’s initialized wire checks. In pure chisel3 (Strict compile options), the generated firrtl code does not contain these disablers (is invalid). Output wires that are not driven (not connected) are reported by firrtl as not fully initialized. Read more at Unconnected Wires for details on solving the problem. Can I specify behavior before and after generated initial blocks? Users may define the following macros if they wish to specify behavior before or after emitted initial blocks. BEFORE_INITIAL, which is called before the emitted (non-empty) initial block if it is defined AFTER_INITIAL, which is called after the emitted (non-empty) initial block if it is defined These macros may be useful for turning coverage on and off."
    } ,    
    {
      "title": "Functional Abstraction",
      "url": "/chisel3/docs/explanations/functional-abstraction.html",
      "content": "Functional Abstraction We can define functions to factor out a repeated piece of logic that we later reuse multiple times in a design. For example, we can wrap up our earlier example of a simple combinational logic block as follows: def clb(a: UInt, b: UInt, c: UInt, d: UInt): UInt = (a &amp; b) | (~c &amp; d) where clb is the function which takes a, b, c, d as arguments and returns a wire to the output of a boolean circuit. The def keyword is part of Scala and introduces a function definition, with each argument followed by a colon then its type, and the function return type given after the colon following the argument list. The equals (=) sign separates the function argument list from the function definition. We can then use the block in another circuit as follows: scala mdoc:silent val out = clb(a,b,c,d)"
    } ,    
    {
      "title": "Functional Module Creation",
      "url": "/chisel3/docs/explanations/functional-module-creation.html",
      "content": "Functional Module Creation Objects in Scala have a pre-existing creation function (method) called apply. When an object is used as value in an expression (which basically means that the constructor was called), this method determines the returned value. When dealing with hardware modules, one would expect the module output to be representative of the hardware module’s functionality. Therefore, we would sometimes like the module output to be the value returned when using the object as a value in an expression. Since hardware modules are represented as Scala objects, this can be done by defining the object’s apply method to return the module’s output. This can be referred to as creating a functional interface for module construction. If we apply this on the standard mux2 example, we would to return the mux2 output ports when we used mux2 in an expression. Implementing this requires building a constructor that takes multiplexer inputs as parameters and returns the multiplexer output: import chisel3._ class Mux2 extends Module { val io = IO(new Bundle { val sel = Input(Bool()) val in0 = Input(UInt()) val in1 = Input(UInt()) val out = Output(UInt()) }) io.out := Mux(io.sel, io.in0, io.in1) } object Mux2 { def apply(sel: UInt, in0: UInt, in1: UInt) = { val m = Module(new Mux2) m.io.in0 := in0 m.io.in1 := in1 m.io.sel := sel m.io.out } } As we can see in the code example, we defined the apply method to take the Mux2 inputs as the method parameters, and return the Mux2 output as the function’s return value. By defining modules in this way, it is easier to later implement larger and more complex version of this regular module. For example, we previously implemented Mux4 like this: class Mux4 extends Module { val io = IO(new Bundle { val in0 = Input(UInt(1.W)) val in1 = Input(UInt(1.W)) val in2 = Input(UInt(1.W)) val in3 = Input(UInt(1.W)) val sel = Input(UInt(2.W)) val out = Output(UInt(1.W)) }) val m0 = Module(new Mux2) m0.io.sel := io.sel(0) m0.io.in0 := io.in0 m0.io.in1 := io.in1 val m1 = Module(new Mux2) m1.io.sel := io.sel(0) m1.io.in0 := io.in2 m1.io.in1 := io.in3 val m3 = Module(new Mux2) m3.io.sel := io.sel(1) m3.io.in0 := m0.io.out m3.io.in1 := m1.io.out io.out := m3.io.out } However, by using the creation function we redefined for Mux2, we can now use the Mux2 outputs as values of the modules themselves when writing the Mux4 output expression: class Mux4 extends Module { val io = IO(new Bundle { val in0 = Input(UInt(1.W)) val in1 = Input(UInt(1.W)) val in2 = Input(UInt(1.W)) val in3 = Input(UInt(1.W)) val sel = Input(UInt(2.W)) val out = Output(UInt(1.W)) }) io.out := Mux2(io.sel(1), Mux2(io.sel(0), io.in0, io.in1), Mux2(io.sel(0), io.in2, io.in3)) } This allows us to write more intuitively readable hardware connection descriptions, which are similar to software expression evaluation."
    } ,    
    {
      "title": "Hierarchy Cookbook",
      "url": "/chisel3/docs/cookbooks/hierarchy.html",
      "content": "Hierarchy Cookbook How do I instantiate multiple instances with the same module parameterization, but avoid re-elaboration? How do I access internal fields of an instance? How do I make my parameters accessable from an instance? How do I reuse a previously elaborated module, if my new module has the same parameterization? How do I parameterize a module by its children instances? How do I use the new hierarchy-specific Select functions? How do I instantiate multiple instances with the same module parameterization? Prior to this package, Chisel users relied on deduplication in a FIRRTL compiler to combine structurally equivalent modules into one module (aka “deduplication”). This package introduces the following new APIs to enable multiply-instantiated modules directly in Chisel. Definition(...) enables elaborating a module, but does not actually instantiate that module. Instead, it returns a Definition class which represents that module’s definition. Instance(...) takes a Definition and instantiates it, returning an Instance object. Instantiate(...) provides an API similar to Module(...), except it uses Definition and Instance to only elaborate modules once for a given set of parameters. It returns an Instance object. Modules (classes or traits) which will be used with the Definition/Instance api should be marked with the @instantiable annotation at the class/trait definition. To make a Module’s members variables accessible from an Instance object, they must be annotated with the @public annotation. Note that this is only accessible from a Scala sense—this is not in and of itself a mechanism for cross-module references. Using Definition and Instance In the following example, use Definition, Instance, @instantiable and @public to create multiple instances of one specific parameterization of a module, AddOne. import chisel3._ import chisel3.experimental.hierarchy.{Definition, Instance, instantiable, public} @instantiable class AddOne(width: Int) extends Module { @public val in = IO(Input(UInt(width.W))) @public val out = IO(Output(UInt(width.W))) out := in + 1.U } class AddTwo(width: Int) extends Module { val in = IO(Input(UInt(width.W))) val out = IO(Output(UInt(width.W))) val addOneDef = Definition(new AddOne(width)) val i0 = Instance(addOneDef) val i1 = Instance(addOneDef) i0.in := in i1.in := i0.out out := i1.out } // Generated by CIRCT sifive/1/20/0 module AddOne( // &lt;stdin&gt;:3:10 input [9:0] in, output [9:0] out); assign out = in + 10'h1; // &lt;stdin&gt;:3:10, hierarchy.md:18:13 endmodule module AddTwo( // &lt;stdin&gt;:13:10 input clock, reset, input [9:0] in, output [9:0] out); wire [9:0] _i0_out; // hierarchy.md:26:20 AddOne i0 ( // hierarchy.md:26:20 .in (in), .out (_i0_out) ); AddOne i1 ( // hierarchy.md:27:20 .in (_i0_out), // hierarchy.md:26:20 .out (out) ); endmodule Using Instantiate Similar to the above, the following example uses Instantiate to create multiple instances of AddOne. import chisel3.experimental.hierarchy.Instantiate class AddTwoInstantiate(width: Int) extends Module { val in = IO(Input(UInt(width.W))) val out = IO(Output(UInt(width.W))) val i0 = Instantiate(new AddOne(width)) val i1 = Instantiate(new AddOne(width)) i0.in := in i1.in := i0.out out := i1.out } module AddOne( input [15:0] in, // @[hierarchy.md 16:23] output [15:0] out // @[hierarchy.md 17:23] ); assign out = in + 16'h1; // @[hierarchy.md 18:13] endmodule module AddTwoInstantiate( input clock, input reset, input [15:0] in, // @[hierarchy.md 47:15] output [15:0] out // @[hierarchy.md 48:15] ); wire [15:0] i0_in; // @[hierarchy.md 49:23] wire [15:0] i0_out; // @[hierarchy.md 49:23] wire [15:0] i1_in; // @[hierarchy.md 50:23] wire [15:0] i1_out; // @[hierarchy.md 50:23] AddOne i0 ( // @[hierarchy.md 49:23] .in(i0_in), .out(i0_out) ); AddOne i1 ( // @[hierarchy.md 50:23] .in(i1_in), .out(i1_out) ); assign out = i1_out; // @[hierarchy.md 53:9] assign i0_in = in; // @[hierarchy.md 51:9] assign i1_in = i0_out; // @[hierarchy.md 52:9] endmodule How do I access internal fields of an instance? You can mark internal members of a class or trait marked with @instantiable with the @public annotation. The requirements are that the field is publicly accessible, is a val or lazy val, and is a valid type. The list of valid types are: IsInstantiable IsLookupable Data BaseModule Iterable/Option containing a type that meets these requirements Basic type like String, Int, BigInt etc. To mark a superclass’s member as @public, use the following pattern (shown with val clock). import chisel3._ import chisel3.experimental.hierarchy.{instantiable, public} @instantiable class MyModule extends Module { @public val clock = clock } You’ll get the following error message for improperly marking something as @public: import chisel3._ import chisel3.experimental.hierarchy.{instantiable, public} object NotValidType @instantiable class MyModule extends Module { @public val x = NotValidType } // error: @public is only legal within a class or trait marked @instantiable, and only on vals of type Data, BaseModule, MemBase, IsInstantiable, IsLookupable, or Instance[_], or in an Iterable, Option, Either, or Tuple2 // val x = circt.stage.ChiselStage.emitCHIRRTL(new Top) // ^ How do I make my parameters accessible from an instance? If an instance’s parameters are simple (e.g. Int, String etc.) they can be marked directly with @public. Often, parameters are more complicated and are contained in case classes. In such cases, mark the case class with the IsLookupable trait. This indicates to Chisel that instances of the IsLookupable class may be accessed from within instances. However, ensure that these parameters are true for all instances of a definition. For example, if our parameters contained an id field which was instance-specific but defaulted to zero, then the definition’s id would be returned for all instances. This change in behavior could lead to bugs if other code presumed the id field was correct. Thus, it is important that when converting normal modules to use this package, you are careful about what you mark as IsLookupable. In the following example, we added the trait IsLookupable to allow the member to be marked @public. import chisel3._ import chisel3.experimental.hierarchy.{Definition, Instance, instantiable, IsLookupable, public} case class MyCaseClass(width: Int) extends IsLookupable @instantiable class MyModule extends Module { @public val x = MyCaseClass(10) } class Top extends Module { val inst = Instance(Definition(new MyModule)) println(s\"Width is ${inst.x.width}\") } Width is 10 Circuit(Top,ArrayBuffer(DefModule(repl.MdocSession$MdocApp5$MyModule@54354da0,MyModule,ArrayBuffer(Port(MyModule.clock: IO[Clock],Input,UnlocatableSourceInfo), Port(MyModule.reset: IO[Reset],Input,UnlocatableSourceInfo)),Vector()), DefModule(repl.MdocSession$MdocApp5$Top@60a1b230,Top,ArrayBuffer(Port(Top.clock: IO[Clock],Input,UnlocatableSourceInfo), Port(Top.reset: IO[Bool],Input,UnlocatableSourceInfo)),Vector(DefInstance(SourceLine(hierarchy.md,112,22),ModuleClone(repl.MdocSession$MdocApp5$MyModule@54354da0),ArrayBuffer(Port(MyModule.clock: IO[Clock],Input,UnlocatableSourceInfo), Port(MyModule.reset: IO[Reset],Input,UnlocatableSourceInfo))), Connect(SourceLine(hierarchy.md,112,22),Node(MyModule.inst.clock: IO[Clock]),Node(Top.clock: IO[Clock])), Connect(SourceLine(hierarchy.md,112,22),Node(MyModule.inst.reset: IO[Reset]),Node(Top.reset: IO[Bool]))))),ArrayBuffer(),firrtl.renamemap.package$MutableRenameMap@5548bb9d,ArrayBuffer()) How do I look up parameters from a Definition, if I don’t want to instantiate it? Just like Instances, Definition’s also contain accessors for @public members. As such, you can directly access them: import chisel3._ import chisel3.experimental.hierarchy.{Definition, instantiable, public} @instantiable class AddOne(val width: Int) extends RawModule { @public val width = width @public val in = IO(Input(UInt(width.W))) @public val out = IO(Output(UInt(width.W))) out := in + 1.U } class Top extends Module { val definition = Definition(new AddOne(10)) println(s\"Width is: ${definition.width}\") } // Generated by CIRCT sifive/1/20/0 module Top( // &lt;stdin&gt;:11:10 input clock, reset); endmodule How do I parameterize a module by its children instances? Prior to the introduction of this package, a parent module would have to pass all necessary parameters when instantiating a child module. This had the unfortunate consequence of requiring a parent’s parameters to always contain the child’s parameters, which was an unnecessary coupling which lead to some anti-patterns. Now, a parent can take a child Definition as an argument, and instantiate it directly. In addition, it can analyze the parameters used in the definition to parameterize itself. In a sense, now the child can actually parameterize the parent. In the following example, we create a definition of AddOne, and pass the definition to AddTwo. The width of the AddTwo ports are now derived from the parameterization of the AddOne instance. import chisel3._ import chisel3.experimental.hierarchy.{Definition, Instance, instantiable, public} @instantiable class AddOne(val width: Int) extends Module { @public val width = width @public val in = IO(Input(UInt(width.W))) @public val out = IO(Output(UInt(width.W))) out := in + 1.U } class AddTwo(addOneDef: Definition[AddOne]) extends Module { val i0 = Instance(addOneDef) val i1 = Instance(addOneDef) val in = IO(Input(UInt(addOneDef.width.W))) val out = IO(Output(UInt(addOneDef.width.W))) i0.in := in i1.in := i0.out out := i1.out } // Generated by CIRCT sifive/1/20/0 module AddOne( // &lt;stdin&gt;:3:10 input [9:0] in, output [9:0] out); assign out = in + 10'h1; // &lt;stdin&gt;:3:10, hierarchy.md:186:13 endmodule module AddTwo( // &lt;stdin&gt;:13:10 input clock, reset, input [9:0] in, output [9:0] out); wire [9:0] _i0_out; // hierarchy.md:191:20 AddOne i0 ( // hierarchy.md:191:20 .in (in), .out (_i0_out) ); AddOne i1 ( // hierarchy.md:192:20 .in (_i0_out), // hierarchy.md:191:20 .out (out) ); endmodule How do I use the new hierarchy-specific Select functions? Select functions can be applied after a module has been elaborated, either in a Chisel Aspect or in a parent module applied to a child module. There are seven hierarchy-specific functions, which (with the exception of ios) either return Instance’s or Definition’s: instancesIn(parent): Return all instances directly instantiated locally within parent instancesOf[type](parent): Return all instances of provided type directly instantiated locally within parent allInstancesOf[type](root): Return all instances of provided type directly and indirectly instantiated, locally and deeply, starting from root definitionsIn: Return definitions of all instances directly instantiated locally within parent definitionsOf[type]: Return definitions of all instances of provided type directly instantiated locally within parent allDefinitionsOf[type]: Return all definitions of instances of provided type directly and indirectly instantiated, locally and deeply, starting from root ios: Returns all the I/Os of the provided definition or instance. To demonstrate this, consider the following. We mock up an example where we are using the Select.allInstancesOf and Select.allDefinitionsOf to annotate instances and the definition of EmptyModule. When converting the ChiselAnnotation to firrtl’s Annotation, we print out the resulting Target. As shown, despite EmptyModule actually only being elaborated once, we still provide different targets depending on how the instance or definition is selected. import chisel3._ import chisel3.experimental.hierarchy.{Definition, Instance, Hierarchy, instantiable, public} import firrtl.annotations.{IsModule, NoTargetAnnotation} case object EmptyAnnotation extends NoTargetAnnotation case class MyChiselAnnotation(m: Hierarchy[RawModule], tag: String) extends experimental.ChiselAnnotation { def toFirrtl = { println(tag + \": \" + m.toTarget) EmptyAnnotation } } @instantiable class EmptyModule extends Module { println(\"Elaborating EmptyModule!\") } @instantiable class TwoEmptyModules extends Module { val definition = Definition(new EmptyModule) val i0 = Instance(definition) val i1 = Instance(definition) } class Top extends Module { val definition = Definition(new TwoEmptyModules) val instance = Instance(definition) aop.Select.allInstancesOf[EmptyModule](instance).foreach { i =&gt; experimental.annotate(MyChiselAnnotation(i, \"instance\")) } aop.Select.allDefinitionsOf[EmptyModule](instance).foreach { d =&gt; experimental.annotate(MyChiselAnnotation(d, \"definition\")) } } Elaborating EmptyModule! instance: ~Top|Top/instance:TwoEmptyModules/i0:EmptyModule instance: ~Top|Top/instance:TwoEmptyModules/i1:EmptyModule definition: ~Top|EmptyModule You can also use Select.ios on either a Definition or an Instance to annotate the I/Os appropriately: case class MyIOAnnotation(m: Data, tag: String) extends experimental.ChiselAnnotation { def toFirrtl = { println(tag + \": \" + m.toTarget) EmptyAnnotation } } @instantiable class InOutModule extends Module { @public val in = IO(Input(Bool())) @public val out = IO(Output(Bool())) out := in } @instantiable class TwoInOutModules extends Module { val in = IO(Input(Bool())) val out = IO(Output(Bool())) val definition = Definition(new InOutModule) val i0 = Instance(definition) val i1 = Instance(definition) i0.in := in i1.in := i0.out out := i1.out } class InOutTop extends Module { val definition = Definition(new TwoInOutModules) val instance = Instance(definition) aop.Select.allInstancesOf[InOutModule](instance).foreach { i =&gt; aop.Select.ios(i).foreach { io =&gt; experimental.annotate(MyIOAnnotation(io, \"instance io\")) }} aop.Select.allDefinitionsOf[InOutModule](instance).foreach { d =&gt; aop.Select.ios(d).foreach {io =&gt; experimental.annotate(MyIOAnnotation(io, \"definition io\")) }} } instance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i0:InOutModule&gt;clock instance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i0:InOutModule&gt;reset instance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i0:InOutModule&gt;in instance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i0:InOutModule&gt;out instance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i1:InOutModule&gt;clock instance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i1:InOutModule&gt;reset instance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i1:InOutModule&gt;in instance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i1:InOutModule&gt;out definition io: ~InOutTop|InOutModule&gt;clock definition io: ~InOutTop|InOutModule&gt;reset definition io: ~InOutTop|InOutModule&gt;in definition io: ~InOutTop|InOutModule&gt;out"
    } ,        
    {
      "title": "Chisel API Documentation",
      "url": "/api/",
      "content": "Chisel API Documentation We host only the latest minor version for each major version to keep the size down for website hosting. Please see the page about Versioning for more information about major and minor versioning and binary compatibility. 3.5 3.4 3.3 3.2"
    } ,      
    {
      "title": "Chisel3",
      "url": "/chisel3/",
      "content": ""
    } ,    
    {
      "title": "Home",
      "url": "/",
      "content": "CCC 2022 CCC(Chisel Community Conference) is an annual gathering of Chisel community enthusiasts and technical exchange workshop. With the support of the Chisel development community and RISC-V International, this conference will bring together designers and developers with hands-on experience in Chisel from home and abroad to share cutting-edge results and experiences from both the open source community as well as industry. The recording of CCC 2022 has been uploaded: Constellation, a Open-source Chisel NoC Generator for SoCs - Jerry Zhao@UCB BAR The formal verification capabilities of chiseltest - Kevin Laeufer@UCB BAR Chisel Breakdown 03 - Jack Koenig@SiFive The Next Generation FIRRTL Compiler is Here! - Prithayan Barua&amp;Hideto Ueno@SiFive Implementing RISC-V Scalar Cryptography/Bitmanip extensions in Chisel - Hongren Zheng@Tsinghua University+PLCT SCIRT: Bridging the Type System Gap for Circuit Generators - Ruikang Wang@Tsinghua University+PLCT ChiselDB: Mapping Hardware Data Structures to Database Tables for Efficient Data Analysis Jiawei Lin@ICT From Chisel to Chips in Fully Open-Source - Martin Schoeberl@DTU See you next year :) The Constructing Hardware in a Scala Embedded Language (Chisel) is an open-source hardware description language (HDL) used to describe digital electronics and circuits at the register-transfer level that facilitates advanced circuit generation and design reuse for both ASIC and FPGA digital logic designs. Chisel adds hardware construction primitives to the Scala programming language, providing designers with the power of a modern programming language to write complex, parameterizable circuit generators that produce synthesizable Verilog. This generator methodology enables the creation of re-usable components and libraries, such as the FIFO queue and arbiters in the Chisel Standard Library, raising the level of abstraction in design while retaining fine-grained control. For more information on the benefits of Chisel see: “What benefits does Chisel offer over classic Hardware Description Languages?” Chisel is powered by FIRRTL (Flexible Intermediate Representation for RTL), a hardware compiler framework that performs optimizations of Chisel-generated circuits and supports custom user-defined circuit transformations. What does Chisel code look like? LED blink FIR Filter Getting Started Bootcamp Interactive Tutorial A Textbook on Chisel Build Your Own Chisel Projects Guide For New Contributors Design Verification Documentation Useful Resources Chisel Dev Meeting Data Types Overview Contributor Documentation Useful Resources for Contributors Compiling and Testing Chisel Running Projects Against Local Chisel Building Chisel with FIRRTL in the same SBT Project Chisel3 Architecture Overview Chisel Sub-Projects Which version should I use? Chisel Roadmap What does Chisel code look like? LED blink import chisel3._ import chisel3.util._ class Blinky(freq: Int, startOn: Boolean = false) extends Module { val io = IO(new Bundle { val led0 = Output(Bool()) }) // Blink LED every second using Chisel built-in util.Counter val led = RegInit(startOn.B) val (_, counterWrap) = Counter(true.B, freq / 2) when(counterWrap) { led := ~led } io.led0 := led } object Main extends App { // These lines generate the Verilog output println( new (chisel3.stage.ChiselStage).emitVerilog( new Blinky(1000), Array( \"--emission-options=disableMemRandomization,disableRegisterRandomization\" ) ) ) } Should output the following Verilog: Click to expand! module Blinky( input clock, input reset, output io_led0 ); reg led; // @[main.scala 11:20] reg [8:0] counterWrap_value; // @[Counter.scala 62:40] wire counterWrap_wrap_wrap = counterWrap_value == 9'h1f3; // @[Counter.scala 74:24] wire [8:0] _counterWrap_wrap_value_T_1 = counterWrap_value + 9'h1; // @[Counter.scala 78:24] assign io_led0 = led; // @[main.scala 16:11] always @(posedge clock) begin if (reset) begin // @[main.scala 11:20] led &lt;= 1'h0; // @[main.scala 11:20] end else if (counterWrap_wrap_wrap) begin // @[main.scala 13:21] led &lt;= ~led; // @[main.scala 14:9] end if (reset) begin // @[Counter.scala 62:40] counterWrap_value &lt;= 9'h0; // @[Counter.scala 62:40] end else if (counterWrap_wrap_wrap) begin // @[Counter.scala 88:20] counterWrap_value &lt;= 9'h0; // @[Counter.scala 88:28] end else begin counterWrap_value &lt;= _counterWrap_wrap_value_T_1; // @[Counter.scala 78:15] end end endmodule FIR Filter Consider an FIR filter that implements a convolution operation, as depicted in this block diagram: While Chisel provides similar base primitives as synthesizable Verilog, and could be used as such: // 3-point moving sum implemented in the style of a FIR filter class MovingSum3(bitWidth: Int) extends Module { val io = IO(new Bundle { val in = Input(UInt(bitWidth.W)) val out = Output(UInt(bitWidth.W)) }) val z1 = RegNext(io.in) val z2 = RegNext(z1) io.out := (io.in * 1.U) + (z1 * 1.U) + (z2 * 1.U) } the power of Chisel comes from the ability to create generators, such as an FIR filter that is defined by the list of coefficients: // Generalized FIR filter parameterized by the convolution coefficients class FirFilter(bitWidth: Int, coeffs: Seq[UInt]) extends Module { val io = IO(new Bundle { val in = Input(UInt(bitWidth.W)) val out = Output(UInt(bitWidth.W)) }) // Create the serial-in, parallel-out shift register val zs = Reg(Vec(coeffs.length, UInt(bitWidth.W))) zs(0) := io.in for (i &lt;- 1 until coeffs.length) { zs(i) := zs(i-1) } // Do the multiplies val products = VecInit.tabulate(coeffs.length)(i =&gt; zs(i) * coeffs(i)) // Sum up the products io.out := products.reduce(_ + _) } and use and re-use them across designs: val movingSum3Filter = Module(new FirFilter(8, Seq(1.U, 1.U, 1.U))) // same 3-point moving sum filter as before val delayFilter = Module(new FirFilter(8, Seq(0.U, 1.U))) // 1-cycle delay as a FIR filter val triangleFilter = Module(new FirFilter(8, Seq(1.U, 2.U, 3.U, 2.U, 1.U))) // 5-point FIR filter with a triangle impulse response The above can be converted to Verilog using ChiselStage: import chisel3.stage.{ChiselStage, ChiselGeneratorAnnotation} (new chisel3.stage.ChiselStage).execute( Array(\"-X\", \"verilog\"), Seq(ChiselGeneratorAnnotation(() =&gt; new FirFilter(8, Seq(1.U, 1.U, 1.U))))) Alternatively, you may generate some Verilog directly for inspection: val verilogString = chisel3.emitVerilog(new FirFilter(8, Seq(0.U, 1.U))) println(verilogString) Getting Started Bootcamp Interactive Tutorial The online Chisel Bootcamp is the recommended way to get started with and learn Chisel. No setup is required (it runs in the browser), nor does it assume any prior knowledge of Scala. The classic Chisel tutorial contains small exercises and runs on your computer. A Textbook on Chisel If you like a textbook to learn Chisel and also a bit of digital design in general, you may be interested in reading Digital Design with Chisel. It is available in English, Chinese, Japanese, and Vietnamese. Build Your Own Chisel Projects See the setup instructions for how to set up your environment to build Chisel locally. When you’re ready to build your own circuits in Chisel, we recommend starting from the Chisel Template repository, which provides a pre-configured project, example design, and testbench. Follow the chisel-template README to get started. If you insist on setting up your own project from scratch, your project needs to depend on both the chisel3-plugin (Scalac plugin) and the chisel3 library. For example, in SBT this could be expressed as: // build.sbt scalaVersion := \"2.13.8\" addCompilerPlugin(\"edu.berkeley.cs\" % \"chisel3-plugin\" % \"3.5.4\" cross CrossVersion.full) libraryDependencies += \"edu.berkeley.cs\" %% \"chisel3\" % \"3.5.4\" // We also recommend using chiseltest for writing unit tests libraryDependencies += \"edu.berkeley.cs\" %% \"chiseltest\" % \"0.5.4\" % \"test\" Guide For New Contributors If you are trying to make a contribution to this project, please read CONTRIBUTING.md Design Verification These simulation-based verification tools are available for Chisel: chiseltest is the batteries-included testing and formal verification library for Chisel-based RTL designs and a replacement for the former PeekPokeTester, providing the same base constructs but with a streamlined interface and concurrency support with fork and join with internal and Verilator integration for simulations. Documentation Useful Resources Cheat Sheet, a 2-page reference of the base Chisel syntax and libraries ScalaDoc, a listing, description, and examples of the functionality exposed by Chisel Gitter, where you can ask questions or discuss anything Chisel Website (source) Scastie (3.5.3) asic-world If you aren’t familiar with verilog, this is a good tutorial. If you are migrating from Chisel2, see the migration guide. Chisel Dev Meeting Chisel/FIRRTL development meetings happen every Monday from 1100–1200 PT. Call-in info and meeting notes are available here. Data Types Overview These are the base data types for defining circuit components: Contributor Documentation This section describes how to get started contributing to Chisel itself, including how to test your version locally against other projects that pull in Chisel using sbt’s managed dependencies. Useful Resources for Contributors The Useful Resources for users are also helpful for contributors. Chisel Breakdown Slides, an introductory talk about Chisel’s internals Compiling and Testing Chisel You must first install required dependencies to build Chisel locally, please see the setup instructions. Clone and build the Chisel library: git clone https://github.com/chipsalliance/chisel3.git cd chisel3 sbt compile In order to run the following unit tests, you will need several tools on your PATH, namely verilator, yosys, espresso, and z3. Check that each is installed on your PATH by running which verilator and so on. If the compilation succeeded and the dependencies noted above are installed, you can then run the included unit tests by invoking: sbt test Running Projects Against Local Chisel To use the development version of Chisel (master branch), you will need to build from source and publishLocal. The repository version can be found in the build.sbt file. As of the time of writing it was: version := \"3.6-SNAPSHOT\" To publish your version of Chisel to the local Ivy (sbt’s dependency manager) repository, run: sbt publishLocal The compiled version gets placed in ~/.ivy2/local/edu.berkeley.cs/. If you need to un-publish your local copy of Chisel, remove the directory generated in ~/.ivy2/local/edu.berkeley.cs/. In order to have your projects use this version of Chisel, you should update the libraryDependencies setting in your project’s build.sbt file to: libraryDependencies += \"edu.berkeley.cs\" %% \"chisel3\" % \"3.6-SNAPSHOT\" Building Chisel with FIRRTL in the same SBT Project While we recommend using the library dependency approach as described above, it is possible to build Chisel and FIRRTL in a single SBT project. Caveats: This only works for the “main” configuration; you cannot build the Chisel tests this way because treadle is only supported as a library dependency. Do not publishLocal when building this way. The published artifact will be missing the FIRRTL dependency. This works by using sbt-sriracha, an SBT plugin for toggling between source and library dependencies. It provides two JVM system properties that, when set, will tell SBT to include FIRRTL as a source project: sbt.sourcemode - when set to true, SBT will look for FIRRTL in the workspace sbt.workspace - sets the root directory of the workspace Example use: # From root of this repo git clone git@github.com:chipsalliance/firrtl.git sbt -Dsbt.sourcemode=true -Dsbt.workspace=$PWD This is primarily useful for building projects that themselves want to include Chisel as a source dependency. As an example, see Rocket Chip Chisel3 Architecture Overview The Chisel3 compiler consists of these main parts: The frontend, chisel3.*, which is the publicly visible “API” of Chisel and what is used in Chisel RTL. These just add data to the… The Builder, chisel3.internal.Builder, which maintains global state (like the currently open Module) and contains commands, generating… The intermediate data structures, chisel3.firrtl.*, which are syntactically very similar to Firrtl. Once the entire circuit has been elaborated, the top-level object (a Circuit) is then passed to… The Firrtl emitter, chisel3.firrtl.Emitter, which turns the intermediate data structures into a string that can be written out into a Firrtl file for further processing. Also included is: The standard library of circuit generators, chisel3.util.*. These contain commonly used interfaces and constructors (like Decoupled, which wraps a signal with a ready-valid pair) as well as fully parameterizable circuit generators (like arbiters and multiplexors). Chisel Stage, chisel3.stage.*, which contains compilation and test functions that are invoked in the standard Verilog generation and simulation testing infrastructure. These can also be used as part of custom flows. Chisel Sub-Projects Chisel consists of 4 Scala projects; each is its own separate compilation unit: core is the bulk of the source code of Chisel, depends on macros src/main is the “main” that brings it all together and includes a util library, which depends on core plugin is the compiler plugin, no internal dependencies macros is most of the macros used in Chisel, no internal dependencies Code that touches lots of APIs that are private to the chisel3 package should belong in core, while code that is pure Chisel should belong in src/main. Which version should I use? We encourage Chisel users (as opposed to Chisel developers), to use the latest release version of Chisel. This chisel-template repository is kept up-to-date, depending on the most recent version of Chisel. The recommended version is also captured near the top of this README, and in the Github releases section of this repo. If you encounter an issue with a released version of Chisel, please file an issue on GitHub mentioning the Chisel version and provide a simple test case (if possible). Try to reproduce the issue with the associated latest minor release (to verify that the issue hasn’t been addressed). For more information on our versioning policy and what versions of the various Chisel ecosystem projects work together, see Chisel Project Versioning. If you’re developing a Chisel library (or chisel3 itself), you’ll probably want to work closer to the tip of the development trunk. By default, the master branches of the chisel repositories are configured to build and publish their version of the code as Z.Y-SNAPSHOT. Updated SNAPSHOTs are publised on every push to master. You are encouraged to do your development against the latest SNAPSHOT, but note that neither API nor ABI compatibility is guaranteed so your code may break at any time. Roadmap See [ROADMAP.md]."
    } ,    
    {
      "title": "Interfaces and Connections",
      "url": "/chisel3/docs/explanations/interfaces-and-connections.html",
      "content": "Interfaces &amp; Connections For more sophisticated modules it is often useful to define and instantiate interface classes while defining the IO for a module. First and foremost, interface classes promote reuse allowing users to capture once and for all common interfaces in a useful form. Secondly, interfaces allow users to dramatically reduce wiring by supporting bulk connections between producer and consumer modules. Finally, users can make changes in large interfaces in one place reducing the number of updates required when adding or removing pieces of the interface. Note that Chisel has some built-in standard interface which should be used whenever possible for interoperability (e.g. Decoupled). Ports: Subclasses &amp; Nesting As we saw earlier, users can define their own interfaces by defining a class that subclasses Bundle. For example, a user could define a simple link for hand-shaking data as follows: class SimpleLink extends Bundle { val data = Output(UInt(16.W)) val valid = Output(Bool()) } We can then extend SimpleLink by adding parity bits using bundle inheritance: class PLink extends SimpleLink { val parity = Output(UInt(5.W)) } In general, users can organize their interfaces into hierarchies using inheritance. From there we can define a filter interface by nesting two PLinks into a new FilterIO bundle: class FilterIO extends Bundle { val x = Flipped(new PLink) val y = new PLink } where flip recursively changes the direction of a bundle, changing input to output and output to input. We can now define a filter by defining a filter class extending module: class Filter extends Module { val io = IO(new FilterIO) // ... } where the io field contains FilterIO. Bundle Vectors Beyond single elements, vectors of elements form richer hierarchical interfaces. For example, in order to create a crossbar with a vector of inputs, producing a vector of outputs, and selected by a UInt input, we utilize the Vec constructor: import chisel3.util.log2Ceil class CrossbarIo(n: Int) extends Bundle { val in = Vec(n, Flipped(new PLink)) val sel = Input(UInt(log2Ceil(n).W)) val out = Vec(n, new PLink) } where Vec takes a size as the first argument and a block returning a port as the second argument. Bulk Connections Once we have a defined Interface, we can connect to it via a MonoConnect operator (:=) or BiConnect operator (&lt;&gt;). MonoConnect Algorithm MonoConnect.connect, or :=, executes a mono-directional connection element-wise. Note that this isn’t commutative. There is an explicit source and sink already determined before this function is called. The connect operation will recurse down the left Data (with the right Data). An exception will be thrown if a movement through the left cannot be matched in the right. The right side is allowed to have extra fields. Vecs must still be exactly the same size. Note that the LHS element must be writable so, one of these must hold: Is an internal writable node (Reg or Wire) Is an output of the current module Is an input of a submodule of the current module Note that the RHS element must be readable so, one of these must hold: Is an internal readable node (Reg, Wire, Op) Is a literal Is a port of the current module or submodule of the current module BiConnect Algorithm BiConnect.connect, or &lt;&gt;, executes a bidirectional connection element-wise. Note that the arguments are left and right (not source and sink) so the intent is for the operation to be commutative. The connect operation will recurse down the left Data (with the right Data). An exception will be thrown if a movement through the left cannot be matched in the right, or if the right side has extra fields. Using the biconnect &lt;&gt; operator, we can now compose two filters into a filter block as follows: class Block extends Module { val io = IO(new FilterIO) val f1 = Module(new Filter) val f2 = Module(new Filter) f1.io.x &lt;&gt; io.x f1.io.y &lt;&gt; f2.io.x f2.io.y &lt;&gt; io.y } The bidirectional bulk connection operator &lt;&gt; connects leaf ports of the same name to each other. The Scala types of the Bundles are not required to match. If one named signal is missing from either side, Chisel will give an error such as in the following example: class NotReallyAFilterIO extends Bundle { val x = Flipped(new PLink) val y = new PLink val z = Output(new Bool()) } class Block2 extends Module { val io1 = IO(new FilterIO) val io2 = IO(Flipped(new NotReallyAFilterIO)) io1 &lt;&gt; io2 } Below we can see the resulting error for this example: ChiselStage.emitSystemVerilog(new Block2) // chisel3.internal.ChiselException: Connection between left (Block2.io1: IO[FilterIO]) and source (Block2.io2: IO[NotReallyAFilterIO]) failed @.z: Left Record missing field (z). // at ... () // at repl.MdocSession$MdocApp$Block2.&lt;init&gt;(interfaces-and-connections.md:89) // at repl.MdocSession$MdocApp$$anonfun$22$$anonfun$apply$20.apply(interfaces-and-connections.md:97) // at repl.MdocSession$MdocApp$$anonfun$22$$anonfun$apply$20.apply(interfaces-and-connections.md:97) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) Bidirectional connections should only be used with directioned elements (like IOs), e.g. connecting two wires isn’t supported since Chisel can’t necessarily figure out the directions automatically. For example, putting two temporary wires and connecting them here will not work, even though the directions could be known from the endpoints: class BlockWithTemporaryWires extends Module { val io = IO(new FilterIO) val f1 = Module(new Filter) val f2 = Module(new Filter) f1.io.x &lt;&gt; io.x val tmp1 = Wire(new FilterIO) val tmp2 = Wire(new FilterIO) f1.io.y &lt;&gt; tmp1 tmp1 &lt;&gt; tmp2 tmp2 &lt;&gt; f2.io.x f2.io.y &lt;&gt; io.y } Below we can see the resulting error for this example: ChiselStage.emitSystemVerilog(new BlockWithTemporaryWires) // chisel3.internal.ChiselException: Connection between left (Filter.io.y: IO[PLink]) and source (BlockWithTemporaryWires.tmp1: Wire[FilterIO]) failed @.y: Left Record missing field (y). // at ... () // at repl.MdocSession$MdocApp$BlockWithTemporaryWires.&lt;init&gt;(interfaces-and-connections.md:113) // at repl.MdocSession$MdocApp$$anonfun$33$$anonfun$apply$29.apply(interfaces-and-connections.md:124) // at repl.MdocSession$MdocApp$$anonfun$33$$anonfun$apply$29.apply(interfaces-and-connections.md:124) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) For more details and information, see Deep Dive into Connection Operators NOTE: When using Chisel._ (compatibility mode) instead of chisel3._, the := operator works in a bidirectional fashion similar to &lt;&gt;, but not exactly the same. The standard ready-valid interface (ReadyValidIO / Decoupled) Chisel provides a standard interface for ready-valid interfaces. A ready-valid interface consists of a ready signal, a valid signal, and some data stored in bits. The ready bit indicates that a consumer is ready to consume data. The valid bit indicates that a producer has valid data on bits. When both ready and valid are asserted, a data transfer from the producer to the consumer takes place. A convenience method fire is provided that is asserted if both ready and valid are asserted. Usually, we use the utility function Decoupled() to turn any type into a ready-valid interface rather than directly using ReadyValidIO. Decoupled(...) creates a producer / output ready-valid interface (i.e. bits is an output). Flipped(Decoupled(...)) creates a consumer / input ready-valid interface (i.e. bits is an input). Take a look at the following example Chisel code to better understand exactly what is generated: import chisel3._ import chisel3.util.Decoupled /** * Using Decoupled(...) creates a producer interface. * i.e. it has bits as an output. * This produces the following ports: * input io_readyValid_ready, * output io_readyValid_valid, * output [31:0] io_readyValid_bits */ class ProducingData extends Module { val io = IO(new Bundle { val readyValid = Decoupled(UInt(32.W)) }) // do something with io.readyValid.ready io.readyValid.valid := true.B io.readyValid.bits := 5.U } /** * Using Flipped(Decoupled(...)) creates a consumer interface. * i.e. it has bits as an input. * This produces the following ports: * output io_readyValid_ready, * input io_readyValid_valid, * input [31:0] io_readyValid_bits */ class ConsumingData extends Module { val io = IO(new Bundle { val readyValid = Flipped(Decoupled(UInt(32.W))) }) io.readyValid.ready := false.B // do something with io.readyValid.valid // do something with io.readyValid.bits } DecoupledIO is a ready-valid interface with the convention that there are no guarantees placed on deasserting ready or valid or on the stability of bits. That means ready and valid can also be deasserted without a data transfer. IrrevocableIO is a ready-valid interface with the convention that the value of bits will not change while valid is asserted and ready is deasserted. Also, the consumer shall keep ready asserted after a cycle where ready was high and valid was low. Note that the irrevocable constraint is only a convention and cannot be enforced by the interface. Chisel does not automatically generate checkers or assertions to enforce the irrevocable convention."
    } ,    
    {
      "title": "Introduction",
      "url": "/chisel3/docs/introduction.html",
      "content": "An Introduction to Chisel Chisel (Constructing Hardware In a Scala Embedded Language) is a hardware construction language embedded in the high-level programming language Scala. Chisel is a library of special class definitions, predefined objects, and usage conventions within Scala, so when you write Chisel you are actually writing a Scala program that constructs a hardware graph. As you gain experience and want to make your code simpler or more reusable, you will find it important to leverage the underlying power of the Scala language. We recommend you consult one of the excellent Scala books to become more expert in Scala programming. For a tutorial covering both Chisel and Scala, see the online Chisel Bootcamp. For quick reference “How-To” guides see the Cookbooks. For a deeper introduction to key concepts in Chisel see the Explanations. The API Documentation gives the detailed reference for the Chisel source code. Note that previous versions can be found via the sidebar menu at [https://www.chisel-lang.org/chisel3]. The Resources provides links to other useful resources for learning and working with Chisel. The Appendix covers some more advanced topics. The Developers section provides information for those working on the Chisel library itself. Throughout these pages, we format commentary on our design choices as in this paragraph. You should be able to skip the commentary sections and still fully understand how to use Chisel, but we hope you’ll find them interesting."
    } ,    
    {
      "title": "Memories",
      "url": "/chisel3/docs/explanations/memories.html",
      "content": "Memories Chisel provides facilities for creating both read only and read/write memories. ROM Users can define read-only memories by constructing a Vec with VecInit. VecInit can accept either a variable-argument number of Data literals or a Seq[Data] literals that initialize the ROM. For example, users can create a small ROM initialized to 1, 2, 4, 8 and loop through all values using a counter as an address generator as follows: import chisel3._ import chisel3.util.Counter val m = VecInit(1.U, 2.U, 4.U, 8.U) val c = Counter(m.length) c.inc() val r = m(c.value) We can create an n value sine lookup table generator using a ROM initialized as follows: import chisel3._ val Pi = math.Pi def sinTable(amp: Double, n: Int) = { val times = (0 until n).map(i =&gt; (i*2*Pi)/(n.toDouble-1) - Pi) val inits = times.map(t =&gt; Math.round(amp * math.sin(t)).asSInt(32.W)) VecInit(inits) } where amp is used to scale the fixpoint values stored in the ROM. Read-Write Memories Memories are given special treatment in Chisel since hardware implementations of memory vary greatly. For example, FPGA memories are instantiated quite differently from ASIC memories. Chisel defines a memory abstraction that can map to either simple Verilog behavioural descriptions or to instances of memory modules that are available from external memory generators provided by foundry or IP vendors. SyncReadMem: sequential/synchronous-read, sequential/synchronous-write Chisel has a construct called SyncReadMem for sequential/synchronous-read, sequential/synchronous-write memories. These SyncReadMems will likely be synthesized to technology SRAMs (as opposed to register banks). If the same memory address is both written and sequentially read on the same clock edge, or if a sequential read enable is cleared, then the read data is undefined. Values on the read data port are not guaranteed to be held until the next read cycle. If that is the desired behavior, external logic to hold the last read value must be added. Read port/write port Ports into SyncReadMems are created by applying a UInt index. A 1024-entry SRAM with one write port and one read port might be expressed as follows: import chisel3._ class ReadWriteSmem extends Module { val width: Int = 32 val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val addr = Input(UInt(10.W)) val dataIn = Input(UInt(width.W)) val dataOut = Output(UInt(width.W)) }) val mem = SyncReadMem(1024, UInt(width.W)) // Create one write port and one read port mem.write(io.addr, io.dataIn) io.dataOut := mem.read(io.addr, io.enable) } Below is an example waveform of the one write port/one read port SyncReadMem with masks. Note that the signal names will differ from the exact wire names generated for the SyncReadMem. With masking, it is also possible that multiple RTL arrays will be generated with the behavior below. Single-ported Single-ported SRAMs can be inferred when the read and write conditions are mutually exclusive in the same when chain: import chisel3._ class RWSmem extends Module { val width: Int = 32 val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val addr = Input(UInt(10.W)) val dataIn = Input(UInt(width.W)) val dataOut = Output(UInt(width.W)) }) val mem = SyncReadMem(1024, UInt(width.W)) io.dataOut := DontCare when(io.enable) { val rdwrPort = mem(io.addr) when (io.write) { rdwrPort := io.dataIn } .otherwise { io.dataOut := rdwrPort } } } (The DontCare is there to make Chisel’s unconnected wire detection aware that reading while writing is undefined.) Here is an example single read/write port waveform, with masks (again, generated signal names and number of arrays may differ): Mem: combinational/asynchronous-read, sequential/synchronous-write Chisel supports random-access memories via the Mem construct. Writes to Mems are combinational/asynchronous-read, sequential/synchronous-write. These Mems will likely be synthesized to register banks, since most SRAMs in modern technologies (FPGA, ASIC) tend to no longer support combinational (asynchronous) reads. Creating asynchronous-read versions of the examples above simply involves replacing SyncReadMem with Mem. Masks Chisel memories also support write masks for subword writes. Chisel will infer masks if the data type of the memory is a vector. To infer a mask, specify the mask argument of the write function which creates write ports. A given masked length is written if the corresponding mask bit is set. For example, in the example below, if the 0th bit of mask is true, it will write the lower byte of the data at corresponding address. import chisel3._ class MaskedReadWriteSmem extends Module { val width: Int = 8 val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val addr = Input(UInt(10.W)) val mask = Input(Vec(4, Bool())) val dataIn = Input(Vec(4, UInt(width.W))) val dataOut = Output(Vec(4, UInt(width.W))) }) // Create a 32-bit wide memory that is byte-masked val mem = SyncReadMem(1024, Vec(4, UInt(width.W))) // Write with mask mem.write(io.addr, io.dataIn, io.mask) io.dataOut := mem.read(io.addr, io.enable) } Here is an example of masks with readwrite ports: import chisel3._ class MaskedRWSmem extends Module { val width: Int = 32 val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val mask = Input(Vec(2, Bool())) val addr = Input(UInt(10.W)) val dataIn = Input(Vec(2, UInt(width.W))) val dataOut = Output(Vec(2, UInt(width.W))) }) val mem = SyncReadMem(1024, Vec(2, UInt(width.W))) io.dataOut := DontCare when(io.enable) { val rdwrPort = mem(io.addr) when (io.write) { when(io.mask(0)) { rdwrPort(0) := io.dataIn(0) } when(io.mask(1)) { rdwrPort(1) := io.dataIn(1) } }.otherwise { io.dataOut := rdwrPort } } } Memory Initialization Chisel memories can be initialized from an external binary or hex file emitting proper Verilog for synthesis or simulation. There are multiple modes of initialization. For more information, check the experimental docs on Loading Memories feature."
    } ,    
    {
      "title": "Modules",
      "url": "/chisel3/docs/explanations/modules.html",
      "content": "Modules Chisel modules are very similar to Verilog modules in defining a hierarchical structure in the generated circuit. The hierarchical module namespace is accessible in downstream tools to aid in debugging and physical layout. A user-defined module is defined as a class which: inherits from Module, contains at least one interface wrapped in a Module’s IO() method (traditionally stored in a port field named io), and wires together subcircuits in its constructor. As an example, consider defining your own two-input multiplexer as a module: import chisel3._ class Mux2IO extends Bundle { val sel = Input(UInt(1.W)) val in0 = Input(UInt(1.W)) val in1 = Input(UInt(1.W)) val out = Output(UInt(1.W)) } class Mux2 extends Module { val io = IO(new Mux2IO) io.out := (io.sel &amp; io.in1) | (~io.sel &amp; io.in0) } The wiring interface to a module is a collection of ports in the form of a Bundle. The interface to the module is defined through a field named io. For Mux2, io is defined as a bundle with four fields, one for each multiplexer port. The := assignment operator, used here in the body of the definition, is a special operator in Chisel that wires the input of left-hand side to the output of the right-hand side. Module Hierarchy We can now construct circuit hierarchies, where we build larger modules out of smaller sub-modules. For example, we can build a 4-input multiplexer module in terms of the Mux2 module by wiring together three 2-input multiplexers: class Mux4IO extends Bundle { val in0 = Input(UInt(1.W)) val in1 = Input(UInt(1.W)) val in2 = Input(UInt(1.W)) val in3 = Input(UInt(1.W)) val sel = Input(UInt(2.W)) val out = Output(UInt(1.W)) } class Mux4 extends Module { val io = IO(new Mux4IO) val m0 = Module(new Mux2) m0.io.sel := io.sel(0) m0.io.in0 := io.in0 m0.io.in1 := io.in1 val m1 = Module(new Mux2) m1.io.sel := io.sel(0) m1.io.in0 := io.in2 m1.io.in1 := io.in3 val m3 = Module(new Mux2) m3.io.sel := io.sel(1) m3.io.in0 := m0.io.out m3.io.in1 := m1.io.out io.out := m3.io.out } We again define the module interface as io and wire up the inputs and outputs. In this case, we create three Mux2 children modules, using the Module constructor function and the Scala new keyword to create a new object. We then wire them up to one another and to the ports of the Mux4 interface. Note: Chisel Modules have an implicit clock (called clock) and an implicit reset (called reset). To create modules without implicit clock and reset, Chisel provides RawModule. RawModule A RawModule is a module that does not provide an implicit clock and reset. This can be useful when interfacing a Chisel module with a design that expects a specific naming convention for clock or reset. Then we can use it in place of Module usage : import chisel3.{RawModule, withClockAndReset} class Foo extends Module { val io = IO(new Bundle{ val a = Input(Bool()) val b = Output(Bool()) }) io.b := !io.a } class FooWrapper extends RawModule { val a_i = IO(Input(Bool())) val b_o = IO(Output(Bool())) val clk = IO(Input(Clock())) val rstn = IO(Input(Bool())) val foo = withClockAndReset(clk, !rstn){ Module(new Foo) } foo.io.a := a_i b_o := foo.io.b } In the example above, the RawModule is used to change the reset polarity of module SlaveSpi. Indeed, the reset is active high by default in Chisel modules, then using withClockAndReset(clock, !rstn) we can use an active low reset in the entire design. The clock is just wired as is, but if needed, RawModule can be used in conjunction with BlackBox to connect a differential clock input for example."
    } ,    
    {
      "title": "Motivation",
      "url": "/chisel3/docs/explanations/motivation.html",
      "content": "Motivation – “Why Chisel?” We were motivated to develop a new hardware language by years of struggle with existing hardware description languages in our research projects and hardware design courses. Verilog and VHDL were developed as hardware simulation languages, and only later did they become a basis for hardware synthesis. Much of the semantics of these languages are not appropriate for hardware synthesis and, in fact, many constructs are simply not synthesizable. Other constructs are non-intuitive in how they map to hardware implementations, or their use can accidentally lead to highly inefficient hardware structures. While it is possible to use a subset of these languages and still get acceptable results, they nonetheless present a cluttered and confusing specification model, particularly in an instructional setting. However, our strongest motivation for developing a new hardware language is our desire to change the way that electronic system design takes place. We believe that it is important to not only teach students how to design circuits, but also to teach them how to design circuit generators —programs that automatically generate designs from a high-level set of design parameters and constraints. Through circuit generators, we hope to leverage the hard work of design experts and raise the level of design abstraction for everyone. To express flexible and scalable circuit construction, circuit generators must employ sophisticated programming techniques to make decisions concerning how to best customize their output circuits according to high-level parameter values and constraints. While Verilog and VHDL include some primitive constructs for programmatic circuit generation, they lack the powerful facilities present in modern programming languages, such as object-oriented programming, type inference, support for functional programming, and reflection. Instead of building a new hardware design language from scratch, we chose to embed hardware construction primitives within an existing language. We picked Scala not only because it includes the programming features we feel are important for building circuit generators, but because it was specifically developed as a base for domain-specific languages."
    } ,    
    {
      "title": "Multiple Clock Domains",
      "url": "/chisel3/docs/explanations/multi-clock.html",
      "content": "Multiple Clock Domains Chisel 3 supports multiple clock domains as follows. Note that in order to cross clock domains safely, you will need appropriate synchronization logic (such as an asynchronous FIFO). You can use the AsyncQueue library to do this easily. import chisel3._ class MultiClockModule extends Module { val io = IO(new Bundle { val clockB = Input(Clock()) val resetB = Input(Bool()) val stuff = Input(Bool()) }) // This register is clocked against the module clock. val regClock = RegNext(io.stuff) withClockAndReset (io.clockB, io.resetB) { // In this withClock scope, all synchronous elements are clocked against io.clockB. // Reset for flops in this domain is using the explicitly provided reset io.resetB. // This register is clocked against io.clockB. val regClockB = RegNext(io.stuff) } // This register is also clocked against the module clock. val regClock2 = RegNext(io.stuff) } You can also instantiate modules in another clock domain: import chisel3._ class ChildModule extends Module { val io = IO(new Bundle{ val in = Input(Bool()) }) } class MultiClockModule extends Module { val io = IO(new Bundle { val clockB = Input(Clock()) val resetB = Input(Bool()) val stuff = Input(Bool()) }) val clockB_child = withClockAndReset(io.clockB, io.resetB) { Module(new ChildModule) } clockB_child.io.in := io.stuff } If you only want to connect your clock to a new clock domain and use the regular implicit reset signal, you can use withClock(clock) instead of withClockAndReset. import chisel3._ class MultiClockModule extends Module { val io = IO(new Bundle { val clockB = Input(Clock()) val stuff = Input(Bool()) }) // This register is clocked against the module clock. val regClock = RegNext(io.stuff) withClock (io.clockB) { // In this withClock scope, all synchronous elements are clocked against io.clockB. // This register is clocked against io.clockB, but uses implict reset from the parent context. val regClockB = RegNext(io.stuff) } // This register is also clocked against the module clock. val regClock2 = RegNext(io.stuff) } // Instantiate module in another clock domain with implicit reset. class MultiClockModule2 extends Module { val io = IO(new Bundle { val clockB = Input(Clock()) val stuff = Input(Bool()) }) val clockB_child = withClock(io.clockB) { Module(new ChildModule) } clockB_child.io.in := io.stuff } class ChildModule extends Module { val io = IO(new Bundle{ val in = Input(Bool()) }) }"
    } ,    
    {
      "title": "Muxes and Input Selection",
      "url": "/chisel3/docs/explanations/muxes-and-input-selection.html",
      "content": "Muxes and Input Selection Selecting inputs is very useful in hardware description, and therefore Chisel provides several built-in generic input-selection implementations. Mux The first one is Mux. This is a 2-input selector. Unlike the Mux2 example which was presented previously, the built-in Mux allows the inputs (in0 and in1) to be any datatype as long as they are the same subclass of Data. By using the functional module creation feature presented in the previous section, we can create multi-input selector in a simple way: Mux(c1, a, Mux(c2, b, Mux(..., default))) MuxCase The nested Mux is not necessary since Chisel also provides the built-in MuxCase, which implements that exact feature. MuxCase is an n-way Mux, which can be used as follows: MuxCase(default, Array(c1 -&gt; a, c2 -&gt; b, ...)) Where each selection dependency is represented as a tuple in a Scala array [ condition -&gt; selected_input_port ]. MuxLookup Chisel also provides MuxLookup which is an n-way indexed multiplexer: MuxLookup(idx, default, Array(0.U -&gt; a, 1.U -&gt; b, ...)) This is the same as a MuxCase, where the conditions are all index based selection: MuxCase(default, Array((idx === 0.U) -&gt; a, (idx === 1.U) -&gt; b, ...)) Note that the conditions/cases/selectors (eg. c1, c2) must be in parentheses. Mux1H Another Mux utility is the one-hot mux, Mux1H. It takes a sequence of selectors and values and returns the value associated with the one selector that is set. If zero or multiple selectors are set the behavior is undefined. For example: val hotValue = chisel3.util.Mux1H(Seq( io.selector(0) -&gt; 2.U, io.selector(1) -&gt; 4.U, io.selector(2) -&gt; 8.U, io.selector(4) -&gt; 11.U, )) Mux1H whenever possible generates Firrtl that is readily optimizable as low depth and/or tree. This optimization is not possible when the values are of type FixedPoint or an aggregate type that contains FixedPoints and results instead as a simple Mux tree. This behavior could be sub-optimal. As FixedPoint is still experimental this behavior may change in the future."
    } ,    
    {
      "title": "Naming",
      "url": "/chisel3/docs/explanations/naming.html",
      "content": "Naming Historically, Chisel has had trouble reliably capturing the names of signals. The reasons for this are due to (1) primarily relying on reflection to find names, (2) using @chiselName macro which had unreliable behavior. Chisel 3.4 introduced a custom Scala compiler plugin which enables reliabe and automatic capturing of signal names, when they are declared. In addition, this release includes prolific use of a new prefixing API which enables more stable naming of signals programmatically generated from function calls. This document explains how naming now works in Chisel for signal and module names. For cookbook examples on how to fix systemic name-stability issues, please refer to the naming cookbook. Compiler Plugin // Imports used by the following examples import chisel3._ import chisel3.experimental.{prefix, noPrefix} import circt.stage.ChiselStage With the release of Chisel 3.5, users are required to add the following line to their build.sbt settings: // chiselVersion is the String version (eg. \"3.5.3\") addCompilerPlugin(\"edu.berkeley.cs\" % \"chisel3-plugin\" % chiselVersion cross CrossVersion.full) This plugin will run after the ‘typer’ phase of the Scala compiler. It looks for any user code which is of the form val x = y, where x is of type chisel3.Data, chisel3.MemBase, or chisel3.experimental.BaseModule. For each line which fits this criteria, it rewrites that line. In the following examples, the commented line is the what the line above is rewritten to. If the line is within a bundle declaration or is a module instantiation, it is rewritten to replace the right hand side with a call to autoNameRecursively, which names the signal/module. class MyBundle extends Bundle { val foo = Input(UInt(3.W)) // val foo = autoNameRecursively(\"foo\")(Input(UInt(3.W))) } class Example1 extends Module { val io = IO(new MyBundle()) // val io = autoNameRecursively(\"io\")(IO(new MyBundle())) } // Generated by CIRCT sifive/1/20/0 module Example1( // &lt;stdin&gt;:3:10 input clock, reset, input [2:0] io_foo); endmodule Otherwise, it is rewritten to also include the name as a prefix to any signals generated while executing the right-hand- side of the val declaration: class Example2 extends Module { val in = IO(Input(UInt(2.W))) // val in = autoNameRecursively(\"in\")(prefix(\"in\")(IO(Input(UInt(2.W))))) val out = IO(Output(UInt(2.W))) // val out = autoNameRecursively(\"out\")(prefix(\"out\")(IO(Output(UInt(2.W))))) def inXin() = in * in val add = 3.U + inXin() // val add = autoNameRecursively(\"add\")(prefix(\"add\")(3.U + inXin())) // Note that the intermediate result of the multiplication is prefixed with `add` out := add + 1.U } // Generated by CIRCT sifive/1/20/0 module Example2( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in, output [1:0] out); assign out = in * in; // &lt;stdin&gt;:3:10, naming.md:48:20 endmodule Prefixing can also be derived from the name of signals on the left-hand side of a connection. While this is not implemented via the compiler plugin, the behavior should feel similar: class ConnectPrefixing extends Module { val in = IO(Input(UInt(2.W))) // val in = autoNameRecursively(\"in\")(prefix(\"in\")(IO(Input(UInt(2.W))))) val out = IO(Output(UInt(2.W))) // val out = autoNameRecursively(\"out\")(prefix(\"out\")(IO(Output(UInt(2.W))))) out := { // technically this is not wrapped in autoNameRecursively nor prefix // But the Chisel runtime will still use the name of `out` as a prefix val double = in * in // val double = autoNameRecursively(\"double\")(prefix(\"double\")(in * in)) double + 1.U } } // Generated by CIRCT sifive/1/20/0 module ConnectPrefixing( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in, output [1:0] out); assign out = in * in + 2'h1; // &lt;stdin&gt;:3:10, naming.md:76:21, :78:12 endmodule Note that the naming also works if the hardware type is nested in an Option or a subtype of Iterable: class Example3 extends Module { val in = IO(Input(UInt(2.W))) // val in = autoNameRecursively(\"in\")(prefix(\"in\")(IO(Input(UInt(2.W))))) val out = IO(Output(UInt())) // val out = autoNameRecursively(\"out\")(prefix(\"out\")(IO(Output(UInt(2.W))))) def inXin() = in * in val opt = Some(3.U + inXin()) // Note that the intermediate result of the inXin() is prefixed with `opt`: // val opt = autoNameRecursively(\"opt\")(prefix(\"opt\")(Some(3.U + inXin()))) out := opt.get + 1.U } // Generated by CIRCT sifive/1/20/0 module Example3( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in, output [3:0] out); wire [3:0] _GEN = {2'h0, in}; // naming.md:99:20 assign out = _GEN * _GEN + 4'h4; // &lt;stdin&gt;:3:10, naming.md:99:20, :105:18 endmodule There is also a slight variant (autoNameRecursivelyProduct) for naming hardware with names provided by an unapply: class UnapplyExample extends Module { def mkIO() = (IO(Input(UInt(2.W))), IO(Output(UInt()))) val (in, out) = mkIO() // val (in, out) = autoNameRecursivelyProduct(List(Some(\"in\"), Some(\"out\")))(mkIO()) out := in } // Generated by CIRCT sifive/1/20/0 module UnapplyExample( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in, output [1:0] out); assign out = in; // &lt;stdin&gt;:3:10 endmodule Note that the compiler plugin will not insert a prefix in these cases because it is ambiguous what the prefix should be. Users who desire a prefix are encouraged to provide one as described below. Prefixing As shown above, the compiler plugin automatically attempts to prefix some of your signals for you. However, you as a user can also add your own prefixes. This is especially useful for ECO-type fixes where you need to add some logic to a module but don’t want to influence other names in the module. In the following example, we prefix additional logic with “ECO”, where Example4 is pre-ECO and Example5 is post-ECO: class Example4 extends Module { val in = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val add = in + in + in out := add + 1.U } class Example5 extends Module { val in = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val add = in + in + in out := prefix(\"ECO\") { add + 1.U + in } } // Generated by CIRCT sifive/1/20/0 module Example4( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in, output [1:0] out); assign out = {in[0], 1'h0} + in + 2'h1; // &lt;stdin&gt;:3:10, naming.md:140:{16,21}, :142:14 endmodule // Generated by CIRCT sifive/1/20/0 module Example5( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in, output [1:0] out); assign out = {in[0], 1'h0} + in + in + 2'h1; // &lt;stdin&gt;:3:10, naming.md:150:{16,21}, :152:{30,36} endmodule Also note that the prefixes append to each other (including the prefix generated by the compiler plugin): class Example6 extends Module { val in = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val add = prefix(\"foo\") { in + in + in } out := add } // Generated by CIRCT sifive/1/20/0 module Example6( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in, output [1:0] out); assign out = {in[0], 1'h0} + in; // &lt;stdin&gt;:3:10, naming.md:172:{32,37} endmodule Sometimes you may want to disable the prefixing. This might occur if you are writing a library function and don’t want the prefixing behavior. In this case, you can use the noPrefix object: class Example7 extends Module { val in = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val add = noPrefix { in + in + in } out := add } // Generated by CIRCT sifive/1/20/0 module Example7( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in, output [1:0] out); assign out = {in[0], 1'h0} + in; // &lt;stdin&gt;:3:10, naming.md:191:{27,32} endmodule Suggest a Signal’s Name (or the instance name of a Module) If you want to specify the name of a signal, you can always use the .suggestName API. Please note that the suggested name will still be prefixed (including by the plugin). You can always use the noPrefix object to strip this. class Example8 extends Module { val in = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val add = (in + (in + in).suggestName(\"foo\")) out := add } // Generated by CIRCT sifive/1/20/0 module Example8( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in, output [1:0] out); assign out = in + {in[0], 1'h0}; // &lt;stdin&gt;:3:10, naming.md:210:{17,23} endmodule Note that using .suggestName does not affect prefixes derived from val names; however, it can affect prefixes derived from connections (eg. :=): class ConnectionPrefixExample extends Module { val in0 = IO(Input(UInt(2.W))) val in1 = IO(Input(UInt(2.W))) val out0 = { val port = IO(Output(UInt())) // Even though this suggestName is before mul, the prefix used in this scope // is derived from `val out0`, so this does not affect the name of mul port.suggestName(\"foo\") // out0_mul val mul = in0 * in1 port := mul + 1.U port } val out1 = IO(Output(UInt())) val out2 = IO(Output(UInt())) out1 := { // out1_sum val sum = in0 + in1 sum + 1.U } // Comes after so does *not* affect prefix above out1.suggestName(\"bar\") // Comes before so *does* affect prefix below out2.suggestName(\"fizz\") out2 := { // fizz_diff val diff = in0 - in1 diff + 1.U } } // Generated by CIRCT sifive/1/20/0 module ConnectionPrefixExample( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in0, in1, output [3:0] foo, output [1:0] bar, fizz); assign foo = {2'h0, in0} * {2'h0, in1} + 4'h1; // &lt;stdin&gt;:3:10, naming.md:235:19, :236:17 assign bar = in0 + in1 + 2'h1; // &lt;stdin&gt;:3:10, naming.md:246:9 assign fizz = in0 - in1 + 2'h1; // &lt;stdin&gt;:3:10, naming.md:246:9, :255:20, :256:10 endmodule As this example illustrates, this behavior is slightly inconsistent so is subject to change in a future version of Chisel. Behavior for “Unnamed signals” (aka “Temporaries”) If you want to signify that the name of a signal does not matter, you can prefix the name of your val with _. Chisel will preserve the convention of leading _ signifying an unnamed signal across prefixes. For example: class TemporaryExample extends Module { val in0 = IO(Input(UInt(2.W))) val in1 = IO(Input(UInt(2.W))) val out = { val port = IO(Output(UInt())) val _sum = in0 + in1 port := _sum + 1.U port } } // Generated by CIRCT sifive/1/20/0 module TemporaryExample( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in0, in1, output [1:0] out); assign out = in0 + in1 + 2'h1; // &lt;stdin&gt;:3:10, naming.md:277:18 endmodule If an unnamed signal is itself used to generate a prefix, the leading _ will be ignored to avoid double __ in the names of further nested signals. class TemporaryPrefixExample extends Module { val in0 = IO(Input(UInt(2.W))) val in1 = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val _sum = { val x = in0 + in1 x + 1.U } out := _sum &amp; 0x2.U } // Generated by CIRCT sifive/1/20/0 module TemporaryPrefixExample( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in0, in1, output [1:0] out); assign out = in0 + in1 + 2'h1 &amp; 2'h2; // &lt;stdin&gt;:3:10, naming.md:299:7, :301:15 endmodule Set a Module Name If you want to specify the module’s name (not the instance name of a module), you can always override the desiredName value. Note that you can parameterize the name by the module’s parameters. This is an excellent way to make your module names more stable and is highly recommended to do. class Example9(width: Int) extends Module { override val desiredName = s\"EXAMPLE9WITHWIDTH$width\" val in = IO(Input(UInt(width.W))) val out = IO(Output(UInt())) val add = (in + (in + in).suggestName(\"foo\")) out := add } // Generated by CIRCT sifive/1/20/0 module EXAMPLE9WITHWIDTH8( // &lt;stdin&gt;:3:10 input clock, reset, input [7:0] in, output [7:0] out); assign out = in + {in[6:0], 1'h0}; // &lt;stdin&gt;:3:10, naming.md:319:{17,23} endmodule // Generated by CIRCT sifive/1/20/0 module EXAMPLE9WITHWIDTH1( // &lt;stdin&gt;:3:10 input clock, reset, in, output out); assign out = in; // &lt;stdin&gt;:3:10 endmodule Reflection Naming Regardless of whether the compiler plugin is enabled or not, after Chisel constructs a module, it attempts to name all members of the Module. This will name all vals which are fields of the module class, but it will not name any vals in nested functions or scopes. If the plugin successfully names a signal, the reflection naming will do nothing. We plan to deprecate all reflection naming in a future Chisel release, but are leaving it to allow the plugin naming to be optional (but recommended). For example, the signals in the following module are in a nested scope; the plugin successfully names them, but reflection naming cannot: class Example10 extends Module { { val in = IO(Input(UInt(3.W))) val out = IO(Output(UInt())) val add = in + in out := add } } @chiselName This macro is no longer recommended as its functionality is entirely replaced by the compiler plugin. Feel free to delete from your Chisel designs!"
    } ,    
    {
      "title": "Naming Cookbook",
      "url": "/chisel3/docs/cookbooks/naming.html",
      "content": "Naming Cookbook I still have _T signals, can this be fixed? See the next answer! I have so many wires with the same name, like x, x_1 and x_2. How can I make them easier to understand? Signals with _T names or names that Chisel has to uniquify often are intermediate values generated within loops, function calls, or when predicates. They can also be consumed by verification statements like assert or prints. In these cases, the compiler plugin often can’t find a good prefix for the generated intermediate signals and can’t name them at all or has to make up a unique name for them. We recommend you manually insert calls to prefix to clarify these cases: import chisel3.experimental.prefix class ExamplePrefix extends Module { Seq.tabulate{2} {i =&gt; Seq.tabulate{2}{ j =&gt; prefix(s\"loop_${i}_${j}\"){ val x = WireInit((i*0x10+j).U(8.W)) dontTouch(x) } } } } // Generated by CIRCT sifive/1/20/0 module ExamplePrefix( // &lt;stdin&gt;:3:10 input clock, reset); wire [7:0] loop_0_0_x = 8'h0; // naming.md:25:25 wire [7:0] loop_0_1_x = 8'h1; // naming.md:25:25 wire [7:0] loop_1_0_x = 8'h10; // naming.md:25:25 wire [7:0] loop_1_1_x = 8'h11; // naming.md:25:25 endmodule How can I get better names for code generated by when clauses? The prefix API can help with code inside when clauses: class ExampleWhenPrefix extends Module { val in = IO(Input(UInt(4.W))) val out = IO(Output(UInt(4.W))) out := DontCare Seq.tabulate{2}{ i =&gt; val j = i + 1 when (in === j.U) { prefix(s\"clause_${j}\"){ val foo = Wire(UInt(4.W)) foo := in +&amp; j.U(4.W) out := foo }} } } // Generated by CIRCT sifive/1/20/0 module ExampleWhenPrefix( // &lt;stdin&gt;:3:10 input clock, reset, input [3:0] in, output [3:0] out); assign out = in == 4'h2 ? in + 4'h2 : in + 4'h1; // &lt;stdin&gt;:3:10, naming.md:51:{14,23}, :53:17, :54:11 endmodule I still see _GEN signals, can this be fixed? _GEN signals are usually generated from the FIRRTL compiler, rather than the Chisel library. We are working on renaming these signals with more context-dependent names, but it is a work in progress. Thanks for caring! My module names are super unstable - I change one thing and Queue_1 becomes Queue_42. Help! This is the infamous Queue instability problem. In general, these cases are best solved at the source - the module itself! If you overwrite desiredName to include parameter information (see the explanation for more info), then this can avoid this problem permanantly. We’ve done this with some Chisel utilities with great results! I want to add some hardware or assertions, but each time I do all the signal names get bumped! This is the classic “ECO” problem, and we provide descriptions in explanation. In short, we recommend wrapping all additional logic in a prefix scope, which enables a unique namespace. This should prevent name collisions, which are what triggers all those annoying signal name bumps! I want to force a signal (or instance) name to something, how do I do that? Use the .suggestName method, which is on all classes which subtype Data. How can I omit the prefix in certain parts of the code? You can use the noPrefix { ... } to strip the prefix from all signals generated in that scope. import chisel3.experimental.noPrefix class ExampleNoPrefix extends Module { val in = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val add = noPrefix { in + in + in } out := add } // Generated by CIRCT sifive/1/20/0 module ExampleNoPrefix( // &lt;stdin&gt;:3:10 input clock, reset, input [1:0] in, output [1:0] out); assign out = {in[0], 1'h0} + in; // &lt;stdin&gt;:3:10, naming.md:76:{27,32} endmodule I am still not getting the name I want. For example, inlining an instance changes my name! In cases where a FIRRTL transform renames a signal/instance, you can use the forcename API: import chisel3.util.experimental.{forceName, InlineInstance} class WrapperExample extends Module { val in = IO(Input(UInt(3.W))) val out = IO(Output(UInt(3.W))) val inst = Module(new Wrapper) inst.in := in out := inst.out } class Wrapper extends Module with InlineInstance { val in = IO(Input(UInt(3.W))) val out = IO(Output(UInt(3.W))) val inst = Module(new MyLeaf) forceName(inst, \"inst\") inst.in := in out := inst.out } class MyLeaf extends Module { val in = IO(Input(UInt(3.W))) val out = IO(Output(UInt(3.W))) out := in } // Generated by CIRCT sifive/1/20/0 module MyLeaf( // &lt;stdin&gt;:3:10 input [2:0] in, output [2:0] out); assign out = in; // &lt;stdin&gt;:3:10 endmodule module WrapperExample( // &lt;stdin&gt;:23:10 input clock, reset, input [2:0] in, output [2:0] out); MyLeaf inst ( // naming.md:106:20 .in (in), .out (out) ); endmodule This can be used to rename instances and non-aggregate typed signals."
    } ,    
    {
      "title": "Operators",
      "url": "/chisel3/docs/explanations/operators.html",
      "content": "Chisel Operators Chisel defines a set of hardware operators: Operation Explanation Bitwise operators Valid on: SInt, UInt, Bool val invertedX = ~x Bitwise NOT val hiBits = x &amp; \"h_ffff_0000\".U Bitwise AND val flagsOut = flagsIn \\| overflow Bitwise OR val flagsOut = flagsIn ^ toggle Bitwise XOR Bitwise reductions. Valid on: SInt and UInt. Returns Bool. val allSet = x.andR AND reduction val anySet = x.orR OR reduction val parity = x.xorR XOR reduction Equality comparison. Valid on: SInt, UInt, and Bool. Returns Bool. val equ = x === y Equality val neq = x =/= y Inequality Shifts Valid on: SInt and UInt val twoToTheX = 1.S &lt;&lt; x Logical shift left val hiBits = x &gt;&gt; 16.U Right shift (logical on UInt and arithmetic on SInt). Bitfield manipulation Valid on: SInt, UInt, and Bool. val xLSB = x(0) Extract single bit, LSB has index 0. val xTopNibble = x(15, 12) Extract bit field from end to start bit position. val usDebt = Fill(3, \"hA\".U) Replicate a bit string multiple times. val float = Cat(sign, exponent, mantissa) Concatenates bit fields, with first argument on left. Logical Operations Valid on: Bool val sleep = !busy Logical NOT val hit = tagMatch &amp;&amp; valid Logical AND val stall = src1busy || src2busy Logical OR val out = Mux(sel, inTrue, inFalse) Two-input mux where sel is a Bool Arithmetic operations Valid on Nums: SInt and UInt. val sum = a + b or val sum = a +% b Addition (without width expansion) val sum = a +&amp; b Addition (with width expansion) val diff = a - b or val diff = a -% b Subtraction (without width expansion) val diff = a -&amp; b Subtraction (with width expansion) val prod = a * b Multiplication val div = a / b Division val mod = a % b Modulus Arithmetic comparisons Valid on Nums: SInt and UInt. Returns Bool. val gt = a &gt; b Greater than val gte = a &gt;= b Greater than or equal val lt = a &lt; b Less than val lte = a &lt;= b Less than or equal Our choice of operator names was constrained by the Scala language. We have to use triple equals=== for equality and =/= for inequality to allow the native Scala equals operator to remain usable. The Chisel operator precedence is not directly defined as part of the Chisel language. Practically, it is determined by the evaluation order of the circuit, which natuarally follows the Scala operator precedence. If in doubt of operator precedence, use parentheses. The Chisel/Scala operator precedence is similar but not identical to precedence in Java or C. Verilog has the same operator precedence as C, but VHDL does not. Verilog has precedence ordering for logic operations, but in VHDL those operators have the same precedence and are evaluated from left to right."
    } ,      
    {
      "title": "Polymorphism and Parameterization",
      "url": "/chisel3/docs/explanations/polymorphism-and-parameterization.html",
      "content": "Polymorphism and Parameterization This section is advanced and can be skipped at first reading. Scala is a strongly typed language and uses parameterized types to specify generic functions and classes. In this section, we show how Chisel users can define their own reusable functions and classes using parameterized classes. Parameterized Functions Earlier we defined Mux2 on Bool, but now we show how we can define a generic multiplexer function. We define this function as taking a boolean condition and con and alt arguments (corresponding to then and else expressions) of type T: def Mux[T &lt;: Bits](c: Bool, con: T, alt: T): T = { ... } where T is required to be a subclass of Bits. Scala ensures that in each usage of Mux, it can find a common superclass of the actual con and alt argument types, otherwise it causes a Scala compilation type error. For example, Mux(c, UInt(10), UInt(11)) yields a UInt wire because the con and alt arguments are each of type UInt. Parameterized Classes Like parameterized functions, we can also parameterize classes to make them more reusable. For instance, we can generalize the Filter class to use any kind of link. We do so by parameterizing the FilterIO class and defining the constructor to take a single argument gen of type T as below. class FilterIO[T &lt;: Data](gen: T) extends Bundle { val x = Input(gen) val y = Output(gen) } We can now define Filter by defining a module class that also takes a link type constructor argument and passes it through to the FilterIO interface constructor: class Filter[T &lt;: Data](gen: T) extends Module { val io = IO(new FilterIO(gen)) // ... } We can now define a PLink-based Filter as follows: val f = Module(new Filter(new PLink)) A generic FIFO could be defined as follows: import chisel3.util.log2Up class DataBundle extends Bundle { val a = UInt(32.W) val b = UInt(32.W) } class Fifo[T &lt;: Data](gen: T, n: Int) extends Module { val io = IO(new Bundle { val enqVal = Input(Bool()) val enqRdy = Output(Bool()) val deqVal = Output(Bool()) val deqRdy = Input(Bool()) val enqDat = Input(gen) val deqDat = Output(gen) }) val enqPtr = RegInit(0.U((log2Up(n)).W)) val deqPtr = RegInit(0.U((log2Up(n)).W)) val isFull = RegInit(false.B) val doEnq = io.enqRdy &amp;&amp; io.enqVal val doDeq = io.deqRdy &amp;&amp; io.deqVal val isEmpty = !isFull &amp;&amp; (enqPtr === deqPtr) val deqPtrInc = deqPtr + 1.U val enqPtrInc = enqPtr + 1.U val isFullNext = Mux(doEnq &amp;&amp; ~doDeq &amp;&amp; (enqPtrInc === deqPtr), true.B, Mux(doDeq &amp;&amp; isFull, false.B, isFull)) enqPtr := Mux(doEnq, enqPtrInc, enqPtr) deqPtr := Mux(doDeq, deqPtrInc, deqPtr) isFull := isFullNext val ram = Mem(n, gen) when (doEnq) { ram(enqPtr) := io.enqDat } io.enqRdy := !isFull io.deqVal := !isEmpty ram(deqPtr) &lt;&gt; io.deqDat } An Fifo with 8 elements of type DataBundle could then be instantiated as: val fifo = Module(new Fifo(new DataBundle, 8)) It is also possible to define a generic decoupled (ready/valid) interface: class DecoupledIO[T &lt;: Data](data: T) extends Bundle { val ready = Input(Bool()) val valid = Output(Bool()) val bits = Output(data) } This template can then be used to add a handshaking protocol to any set of signals: class DecoupledDemo extends DecoupledIO(new DataBundle) The FIFO interface can be now be simplified as follows: class Fifo[T &lt;: Data](data: T, n: Int) extends Module { val io = IO(new Bundle { val enq = Flipped(new DecoupledIO(data)) val deq = new DecoupledIO(data) }) // ... } Parametrization based on Modules You can also parametrize modules based on other modules rather than just types. The following is an example of a module parametrized by other modules as opposed to e.g. types. import chisel3.RawModule import chisel3.experimental.BaseModule import circt.stage.ChiselStage // Provides a more specific interface since generic Module // provides no compile-time information on generic module's IOs. trait MyAdder { def in1: UInt def in2: UInt def out: UInt } class Mod1 extends RawModule with MyAdder { val in1 = IO(Input(UInt(8.W))) val in2 = IO(Input(UInt(8.W))) val out = IO(Output(UInt(8.W))) out := in1 + in2 } class Mod2 extends RawModule with MyAdder { val in1 = IO(Input(UInt(8.W))) val in2 = IO(Input(UInt(8.W))) val out = IO(Output(UInt(8.W))) out := in1 - in2 } class X[T &lt;: BaseModule with MyAdder](genT: =&gt; T) extends Module { val io = IO(new Bundle { val in1 = Input(UInt(8.W)) val in2 = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val subMod = Module(genT) io.out := subMod.out subMod.in1 := io.in1 subMod.in2 := io.in2 } println(ChiselStage.emitSystemVerilog(new X(new Mod1))) println(ChiselStage.emitSystemVerilog(new X(new Mod2))) Output: // Generated by CIRCT sifive/1/20/0 module Mod1( // &lt;stdin&gt;:3:10 input [7:0] in1, in2, output [7:0] out); assign out = in1 + in2; // &lt;stdin&gt;:3:10, polymorphism-and-parameterization.md:174:16 endmodule module X( // &lt;stdin&gt;:12:10 input clock, reset, input [7:0] io_in1, io_in2, output [7:0] io_out); Mod1 subMod ( // polymorphism-and-parameterization.md:192:24 .in1 (io_in1), .in2 (io_in2), .out (io_out) ); endmodule // Generated by CIRCT sifive/1/20/0 module Mod2( // &lt;stdin&gt;:3:10 input [7:0] in1, in2, output [7:0] out); assign out = in1 - in2; // &lt;stdin&gt;:3:10, polymorphism-and-parameterization.md:182:16 endmodule module X( // &lt;stdin&gt;:12:10 input clock, reset, input [7:0] io_in1, io_in2, output [7:0] io_out); Mod2 subMod ( // polymorphism-and-parameterization.md:192:24 .in1 (io_in1), .in2 (io_in2), .out (io_out) ); endmodule"
    } ,    
    {
      "title": "Ports",
      "url": "/chisel3/docs/explanations/ports.html",
      "content": "Ports Ports are used as interfaces to hardware components. A port is simply any Data object that has directions assigned to its members. Chisel provides port constructors to allow a direction to be added (input or output) to an object at construction time. Primitive port constructors wrap the type of the port in Input or Output. An example port declaration is as follows: class Decoupled extends Bundle { val ready = Output(Bool()) val data = Input(UInt(32.W)) val valid = Input(Bool()) } After defining Decoupled, it becomes a new type that can be used as needed for module interfaces or for named collections of wires. By folding directions into the object declarations, Chisel is able to provide powerful wiring constructs described later. Inspecting Module ports (Chisel 3.2+) Chisel 3.2 introduced DataMirror.modulePorts which can be used to inspect the IOs of any Chisel module (this includes modules in both import chisel3._ and import Chisel._, as well as BlackBoxes from each package). Here is an example of how to use this API: import chisel3.reflect.DataMirror import chisel3.stage.ChiselGeneratorAnnotation import circt.stage.ChiselStage class Adder extends Module { val a = IO(Input(UInt(8.W))) val b = IO(Input(UInt(8.W))) val c = IO(Output(UInt(8.W))) c := a +&amp; b } class Test extends Module { val adder = Module(new Adder) // for debug only adder.a := DontCare adder.b := DontCare // Inspect ports of adder // See the result below. DataMirror.modulePorts(adder).foreach { case (name, port) =&gt; { println(s\"Found port $name: $port\") }} } ChiselStage.emitSystemVerilog(new Test) // Found port clock: Adder.clock: IO[Clock] // Found port reset: Adder.reset: IO[Reset] // Found port a: Adder.a: IO[UInt&lt;8&gt;] // Found port b: Adder.b: IO[UInt&lt;8&gt;] // Found port c: Adder.c: IO[UInt&lt;8&gt;] // Running CIRCT: 'firtool -format=fir -warn-on-unprocessed-annotations -verify-each=false -dedup -output-annotation-file circt.anno.json -disable-infer-rw -annotation-file Test.anno.json &lt; $input' // res0: String = \"\"\"// Generated by CIRCT sifive/1/20/0 // module Test( // &lt;stdin&gt;:13:10 // input clock, // reset); // // endmodule // // \"\"\""
    } ,    
    {
      "title": "Printing",
      "url": "/chisel3/docs/explanations/printing.html",
      "content": "Printing in Chisel Chisel provides the printf function for debugging purposes. It comes in two flavors: Scala-style C-style Scala-style Chisel also supports printf in a style similar to Scala’s String Interpolation. Chisel provides a custom string interpolator cf which follows C-style format specifiers (see section C-style below). Note that the Scala s-interpolator is not supported in Chisel constructs and will throw an error: class MyModule extends Module { val in = IO(Input(UInt(8.W))) printf(s\"in = $in\\n\") } // error: The s-interpolator prints the Scala .toString of Data objects rather than the value of the hardware wire during simulation. Use the cf-interpolator instead. If you want an elaboration time print, use println. // printf(s\"in = $in\\n\") // ^^^^^^^^^^^^^^^^^^^^^ Instead, use Chisel’s cf interpolator as in the following examples: val myUInt = 33.U printf(cf\"myUInt = $myUInt\") // myUInt = 33 Note that when concatenating cf\"...\" strings, you need to start with a cf\"...\" string: // Does not interpolate the second string val myUInt = 33.U printf(\"my normal string\" + cf\"myUInt = $myUInt\") Simple formatting Other formats are available as follows: val myUInt = 33.U // Hexadecimal printf(cf\"myUInt = 0x$myUInt%x\") // myUInt = 0x21 // myUInt = 0x21 // Binary printf(cf\"myUInt = $myUInt%b\") // myUInt = 100001 // myUInt = 100001 // Character printf(cf\"myUInt = $myUInt%c\") // myUInt = ! Aggregate data-types Chisel provides default custom “pretty-printing” for Vecs and Bundles. The default printing of a Vec is similar to printing a Seq or List in Scala while printing a Bundle is similar to printing a Scala Map. val myVec = VecInit(5.U, 10.U, 13.U) printf(cf\"myVec = $myVec\") // myVec = Vec(5, 10, 13) // myVec = Vec(5, 10, 13) val myBundle = Wire(new Bundle { val foo = UInt() val bar = UInt() }) myBundle.foo := 3.U myBundle.bar := 11.U printf(cf\"myBundle = $myBundle\") // myBundle = Bundle(a -&gt; 3, b -&gt; 11) Custom Printing Chisel also provides the ability to specify custom printing for user-defined Bundles. class Message extends Bundle { val valid = Bool() val addr = UInt(32.W) val length = UInt(4.W) val data = UInt(64.W) override def toPrintable: Printable = { val char = Mux(valid, 'v'.U, '-'.U) cf\"Message:\\n\" + cf\" valid : $char%c\\n\" + cf\" addr : $addr%x\\n\" + cf\" length : $length\\n\" + cf\" data : $data%x\\n\" } } val myMessage = Wire(new Message) myMessage.valid := true.B myMessage.addr := \"h1234\".U myMessage.length := 10.U myMessage.data := \"hdeadbeef\".U printf(cf\"$myMessage\") Which prints the following: Message: valid : v addr : 0x00001234 length : 10 data : 0x00000000deadbeef Notice the use of + between cf interpolated “strings”. The results of cf interpolation can be concatenated by using the + operator. C-Style Chisel provides printf in a similar style to its C namesake. It accepts a double-quoted format string and a variable number of arguments which will then be printed on rising clock edges. Chisel supports the following format specifiers: Format Specifier Meaning %d decimal number %x hexadecimal number %b binary number %c 8-bit ASCII character %% literal percent It also supports a small set of escape characters: Escape Character Meaning \\n newline \\t tab \\\" literal double quote \\' literal single quote \\\\ literal backslash Note that single quotes do not require escaping, but are legal to escape. Thus printf can be used in a way very similar to how it is used in C: val myUInt = 32.U printf(\"myUInt = %d\", myUInt) // myUInt = 32"
    } ,    
    {
      "title": "Reset",
      "url": "/chisel3/docs/explanations/reset.html",
      "content": "Reset As of Chisel 3.2.0, Chisel 3 supports both synchronous and asynchronous reset, meaning that it can natively emit both synchronous and asynchronously reset registers. The type of register that is emitted is based on the type of the reset signal associated with the register. There are three types of reset that implement a common trait Reset: Bool - constructed with Bool(). Also known as “synchronous reset”. AsyncReset - constructed with AsyncReset(). Also known as “asynchronous reset”. Reset - constructed with Reset(). Also known as “abstract reset”. For implementation reasons, the concrete Scala type is ResetType. Stylistically we avoid ResetType, instead using the common trait Reset. Registers with reset signals of type Bool are emitted as synchronous reset flops. Registers with reset signals of type AsyncReset are emitted as asynchronouly reset flops. Registers with reset signals of type Reset will have their reset type inferred during FIRRTL compilation. Reset Inference FIRRTL will infer a concrete type for any signals of type abstract Reset. The rules are as follows: An abstract Reset with only signals of type AsyncReset, abstract Reset, and DontCare in both its fan-in and fan-out will infer to be of type AsyncReset An abstract Reset with signals of both types Bool and AsyncReset in its fan-in and fan-out is an error. Otherwise, an abstract Reset will infer to type Bool. You can think about (3) as the mirror of (1) replacing AsyncReset with Bool with the additional rule that abstract Resets with neither AsyncReset nor Bool in their fan-in and fan-out will default to type Bool. This “default” case is uncommon and implies that reset signal is ultimately driven by a DontCare. Implicit Reset A Module’s reset is of type abstract Reset. Prior to Chisel 3.2.0, the type of this field was Bool. For backwards compatability, if the top-level module has an implicit reset, its type will default to Bool. Setting Implicit Reset Type New in Chisel 3.3.0 If you would like to set the reset type from within a Module (including the top-level Module), rather than relying on Reset Inference, you can mixin one of the following traits: RequireSyncReset - sets the type of reset to Bool RequireAsyncReset - sets the type of reset to AsyncReset For example: class MyAlwaysSyncResetModule extends Module with RequireSyncReset { val mySyncResetReg = RegInit(false.B) // reset is of type Bool } class MyAlwaysAsyncResetModule extends Module with RequireAsyncReset { val myAsyncResetReg = RegInit(false.B) // reset is of type AsyncReset } Note: This sets the concrete type, but the Scala type will remain Reset, so casting may still be necessary. This comes up most often when using a reset of type Bool in logic. Reset-Agnostic Code The purpose of abstract Reset is to make it possible to design hardware that is agnostic to the reset discipline used. This enables code reuse for utilities and designs where the reset discipline does not matter to the functionality of the block. Consider the two example modules below which are agnostic to the type of reset used within them: class ResetAgnosticModule extends Module { val io = IO(new Bundle { val out = UInt(4.W) }) val resetAgnosticReg = RegInit(0.U(4.W)) resetAgnosticReg := resetAgnosticReg + 1.U io.out := resetAgnosticReg } class ResetAgnosticRawModule extends RawModule { val clk = IO(Input(Clock())) val rst = IO(Input(Reset())) val out = IO(Output(UInt(8.W))) val resetAgnosticReg = withClockAndReset(clk, rst)(RegInit(0.U(8.W))) resetAgnosticReg := resetAgnosticReg + 1.U out := resetAgnosticReg } These modules can be used in both synchronous and asynchronous reset domains. Their reset types will be inferred based on the context within which they are used. Forcing Reset Type You can set the type of a Module’s implicit reset as described above. You can also cast to force the concrete type of reset. .asBool will reinterpret a Reset as Bool .asAsyncReset will reinterpret a Reset as AsyncReset. You can then use withReset to use a cast reset as the implicit reset. See “Multiple Clock Domains” for more information about withReset. The following will make myReg as well as both resetAgnosticRegs synchronously reset: class ForcedSyncReset extends Module { // withReset's argument becomes the implicit reset in its scope withReset (reset.asBool) { val myReg = RegInit(0.U) val myModule = Module(new ResetAgnosticModule) // RawModules do not have implicit resets so withReset has no effect val myRawModule = Module(new ResetAgnosticRawModule) // We must drive the reset port manually myRawModule.rst := Module.reset // Module.reset grabs the current implicit reset } } The following will make myReg as well as both resetAgnosticRegs asynchronously reset: class ForcedAysncReset extends Module { // withReset's argument becomes the implicit reset in its scope withReset (reset.asAsyncReset){ val myReg = RegInit(0.U) val myModule = Module(new ResetAgnosticModule) // myModule.reset is connected implicitly // RawModules do not have implicit resets so withReset has no effect val myRawModule = Module(new ResetAgnosticRawModule) // We must drive the reset port manually myRawModule.rst := Module.reset // Module.reset grabs the current implicit reset } } Note: such casts (asBool and asAsyncReset) are not checked by FIRRTL. In doing such a cast, you as the designer are effectively telling the compiler that you know what you are doing and to force the type as cast. Last-Connect Semantics It is not legal to override the reset type using last-connect semantics unless you are overriding a DontCare: class MyModule extends Module { val resetBool = Wire(Reset()) resetBool := DontCare resetBool := false.B // this is fine withReset(resetBool) { val mySubmodule = Module(new Submodule()) } resetBool := true.B // this is fine resetBool := false.B.asAsyncReset // this will error in FIRRTL }"
    } ,    
    {
      "title": "Resources and References",
      "url": "/chisel3/docs/resources/resources.html",
      "content": "Chisel Resources The best resource to learn about Chisel is the online Chisel Bootcamp. This runs in your browser and assumes no prior Scala knowledge. (You may also run this locally via the backing chisel-bootcamp GitHub repository.) When you’re ready to build your own circuits in Chisel, we recommend starting from the Chisel Template repository, which provides a pre-configured project, example design, and testbench. Follow the chisel-template readme to get started. The following additional resources and references may be useful: Chisel Cheatsheet Digital Design With Chisel Frequently Asked Questions"
    } ,    
    {
      "title": "Developers",
      "url": "/chisel3/docs/developers/sbt-subproject.html",
      "content": "Chisel as an sbt subproject In order to use the constructs defined in the Chisel3 library, those definitions must be made available to the Scala compiler at the time a project dependent on them is compiled. For sbt-based builds there are fundamentally two ways to do this: provide a library dependency on the published Chisel3 jars via sbt’s libraryDependencies setting, clone the Chisel3 git repository and include the source code as a subproject of a dependent project. The former of these two approaches is used by the chisel-tutorial project. It is the simplest approach and assumes you do not require tight control over Chisel3 source code and are content with the published release versions of Chisel3. The latter approach should be used by Chisel3 projects that require finer control over Chisel3 source code. It’s hard to predict in advance the future requirements of a project, and it would be advantageous to be able to switch between the two approaches relatively easily. In order to accomplish this, we provide the sbt-chisel-dep plugin that allows the developer to concisely specify Chisel3 subproject dependencies and switch between subproject and library dependency support based on the presence of a directory (or symbolic link) in the root of the dependent project. The chisel-template project uses this plugin to support switching between either dependency (subproject or library). By default, the chisel-template project does not contain a chisel3 subproject directory, and hence, uses a library dependency on chisel3 (and related Chisel3 projects). However, if you clone the chisel3 GitHub project from the root directory of the chisel-template project, creating a chisel3 subdirectory, the sbt-chisel-dep plugin will take note of the chisel3 project subdirectory, and provide an sbt subproject dependency in place of the library dependency. Checkout the README for the sbt-chisel-dep project for instructions on its usage. Example versions of the build.sbt and specification of the sbt-chisel-dep plugin are available from the skeleton branch of the chisel-template repository."
    } ,    
    {
      "title": "Scaladoc",
      "url": "/chisel3/docs/developers/scaladoc.html",
      "content": "Scaladoc We write inline documentation of code and public APIs using ScalaDoc. When creating a new feature, you can view the documentation you’ve written by building the ScalaDoc locally with sbt: sbt:chisel3&gt; doc This will build the documentation in target/scala-2.12/unidoc or target/scala-2.13/unidoc, and you can view it by opening unidoc/index.html in your browser."
    } ,      
    {
      "title": "Sequential Circuits",
      "url": "/chisel3/docs/explanations/sequential-circuits.html",
      "content": "Sequential Circuits The simplest form of state element supported by Chisel is a positive edge-triggered register, which can be instantiated as: val reg = RegNext(in) This circuit has an output that is a copy of the input signal in delayed by one clock cycle. Note that we do not have to specify the type of Reg as it will be automatically inferred from its input when instantiated in this way. In the current version of Chisel, clock and reset are global signals that are implicitly included where needed. Note that registers which do not specify an initial value will not change value upon toggling the reset signal. Using registers, we can quickly define a number of useful circuit constructs. For example, a rising-edge detector that takes a boolean signal in and outputs true when the current value is true and the previous value is false is given by: def risingedge(x: Bool) = x &amp;&amp; !RegNext(x) Counters are an important sequential circuit. To construct an up-counter that counts up to a maximum value, max, then wraps around back to zero (i.e., modulo max+1), we write: def counter(max: UInt) = { val x = RegInit(0.asUInt(max.getWidth.W)) x := Mux(x === max, 0.U, x + 1.U) x } The counter register is created in the counter function with a reset value of 0 (with width large enough to hold max), to which the register will be initialized when the global reset for the circuit is asserted. The := assignment to x in counter wires an update combinational circuit which increments the counter value unless it hits the max at which point it wraps back to zero. Note that when x appears on the right-hand side of an assignment, its output is referenced, whereas when on the left-hand side, its input is referenced. Counters can be used to build a number of useful sequential circuits. For example, we can build a pulse generator by outputting true when a counter reaches zero: // Produce pulse every n cycles. def pulse(n: UInt) = counter(n - 1.U) === 0.U A square-wave generator can then be toggled by the pulse train, toggling between true and false on each pulse: // Flip internal state when input true. def toggle(p: Bool) = { val x = RegInit(false.B) x := Mux(p, !x, x) x } // Square wave of a given period. def squareWave(period: UInt) = toggle(pulse(period &gt;&gt; 1))"
    } ,    
    {
      "title": "Serialization Cookbook",
      "url": "/chisel3/docs/cookbooks/serialization.html",
      "content": "Serialization Cookbook Why do I need to serialize Modules How do I serialize Modules with SerializableModuleGenerator Why do I need to serialize Modules Chisel provides a very flexible hardware design experience. However, it sometimes becomes too flexible to design a relative big designs, since parameters of module might come from: 1. Global variables; 2. Outer class; 3. Entropies(time, random). It becomes really hard or impossible to describe “how to reproduce this single module?”. This forbids doing unit-test for a module generator, and introduces issues in post-synthesis when doing ECO: a change to Module A might lead to change in Module B. Thus SerializableModuleGenerator, SerializableModule[T &lt;: SerializableModuleParameter] and SerializableModuleParameter are provided to solve these issues. For any SerializableModuleGenerator, Chisel can automatically serialize and de-serialize it by adding these constraints: the SerializableModule should not be inner class, since the outer class is a parameter to it; the SerializableModule has and only has one parameter with SerializableModuleParameter as its type. the Module neither depends on global variables nor uses non-reproducible functions(random, time, etc), and this should be guaranteed by user, since Scala cannot detect it. It can provide these benefits: user can use SerializableModuleGenerator(module: class[SerializableModule], parameter: SerializableModuleParameter) to auto serialize a Module and its parameter. user can nest SerializableModuleGenerator in other serializable parameters to represent a relative large parameter. user can elaborate any SerializableModuleGenerator into a single module for testing. How do I serialize Modules with SerializableModuleGenerator It is pretty simple and illustrated by example below, the GCD Module with width as its parameter. import chisel3._ import chisel3.experimental.{SerializableModule, SerializableModuleGenerator, SerializableModuleParameter} import upickle.default._ // provide serialization functions to GCDSerializableModuleParameter object GCDSerializableModuleParameter { implicit def rwP: ReadWriter[GCDSerializableModuleParameter] = macroRW } // Parameter case class GCDSerializableModuleParameter(width: Int) extends SerializableModuleParameter // Module class GCDSerializableModule(val parameter: GCDSerializableModuleParameter) extends Module with SerializableModule[GCDSerializableModuleParameter] { val io = IO(new Bundle { val a = Input(UInt(parameter.width.W)) val b = Input(UInt(parameter.width.W)) val e = Input(Bool()) val z = Output(UInt(parameter.width.W)) }) val x = Reg(UInt(parameter.width.W)) val y = Reg(UInt(parameter.width.W)) val z = Reg(UInt(parameter.width.W)) val e = Reg(Bool()) when(e) { x := io.a y := io.b z := 0.U } when(x =/= y) { when(x &gt; y) { x := x - y }.otherwise { y := y - x } }.otherwise { z := x } io.z := z } using write function in upickle, it should return a json string: val j = upickle.default.write( SerializableModuleGenerator( classOf[GCDSerializableModule], GCDSerializableModuleParameter(32) ) ) // j: String = \"{\\\"parameter\\\":{\\\"width\\\":32},\\\"generator\\\":\\\"repl.MdocSession$MdocApp$GCDSerializableModule\\\"}\" You can then read from json string and elaborate the Module: ```scala circt.stage.ChiselStage.emitSystemVerilog( upickle.default.readSerializableModuleGenerator[GCDSerializableModule, GCDSerializableModuleParameter].module() )"
    } ,    
    {
      "title": "Source Locators",
      "url": "/chisel3/docs/explanations/source-locators.html",
      "content": "Source Locators When elaborating a Chisel design and emitting a FIRRTL file or Verilog file, Chisel will automatically add source locators which refer back to the Scala file containing the corresponding Chisel code. In a FIRRTL file, it looks like this: wire w : UInt&lt;3&gt; @[src/main/scala/MyProject/MyFile.scala 1210:21] In a Verilog file, it looks like this: wire [2:0] w; // @[src/main/scala/MyProject/MyFile.scala 1210:21] By default, the file’s relative path to where the JVM is invoked is included. To change where the relative path is computed, set the Java system property -Dchisel.project.root=/absolute/path/to/root. This option can be directly passed to sbt (sbt -Dchisel.project.root=/absolute/path/to/root). Setting the value in the build.sbt file won’t work because it needs to be passed to the JVM that invokes sbt (not the other way around). We expect this only relevant for publishing versions which may want more customization."
    } ,    
    {
      "title": "Style Guide",
      "url": "/chisel3/docs/developers/style.html",
      "content": "Chisel Developers Style Guide This document describes the syle used within the chisel3 and related projects (firrtl, treadle, etc). It does not capture requirements for code which is written using these libraries, although projects may choose to adopt these guidelines. The Chisel style guide reflects the Google Java style guide and the General Public Scala style guide. The specific rules below are to clarify the style used for the chisel3 repo and repos related to Chisel (Firrtl). Goal: Readability and consistency are the main purposes of the style guide. Writing your code so someone else (or yourself) can grok it later is important to code health and quality. Filenames The source file name consists of the case-sensitive name of the top-level class it contains, plus “.scala”. Packages Package definitions must contain the full path to the package from scala. If you create a subpackage, it should go in a subdirectory. package directory.name.to.get.you.to.your.source As in Scala, packages follow the Java package naming convention. Note that these guidelines call for all lowercase, no underscores. // Do this package hardware.chips.topsecret.masterplan // Not this package hardware.chips.veryObvious.bad_style We also suggest you do not use chisel3 as a package, and especially do not use it as the final (innermost) package. // Don't do this package hardware.chips.newchip.superfastcomponent.chisel3 // This will lead to instantiating package members like so: val module = Module(new chisel3.FastModule) // Which collides with the chisel namespace import chisel3._ Imports Avoid wildcard ( ._ ) imports, with the exception of chisel3._ All other imports must call out used methods. import chisel3._ must be first, and separated from remaining imports with an extra blank line. Reason: This makes it clear where methods are defined. Any remaining imports must be listed alphabetically. import chisel3._ import the.other.thing.that.i.reference.inline import the.other.things.that.i.reference.{ClassOne, ClassTwo} val myInline = inline.MakeAnInline() val myClassOne = new ClassOne Tests Test classes are named starting with the name of the class they are testing, and ending with “Test”. Test files must start with the name of the class you are testing and end with “Test.scala”. Test files should reside in a subdirectory called “tests”. The tests package should be composed of the package class you are testing. package class.under.test.class package tests Comments We use scaladoc to automatically generate documentation from the source code. /** Multiple lines of ScalaDoc text are written here, * wrapped normally... */ public int method(String p1) { ... } … or in this single-line example: /** An especially short bit of Javadoc. */ Write documentation as if the person reading it knows more about Scala and Chisel than you. If you find comments in the code consider breaking them up into seperate methods. Module Classes and Instances Modules can take different forms in Chisel. The first form is similar to Verilog, where you instance the module and then hook it up. In this case Module(new MyMod()) is returning a reference to the module. val myMod = Module(new MyMod()) myMod.io &lt;&gt; hookUp The second form is a more programmatic inline style with factory methods. In this case, Queue is actually returning the part of the IO bundle representing the queue’s output. The factory method takes the input IO to the queue and an optional parameter for depth. val queueOut = Queue(queueIn, depth=10) The latter can be used for composing multiple functions into a single line. val queueOut = Queue( Arbitrate.byRoundRobin( Queue(a), // depth assumed to be 1 Queue(b, depth=3), Queue(c, depth=4) ), depth=10 ) Naming Conventions Chisel follows the Scala Naming Conventions. In general, Chisel code should use lowerCamelCase for variable naming (ie. the first letter of each word is capitalized except for the first word) and UpperCamelCase for class names. Using these guidelines can result in verilog which is noncompliant with common verilog coding standards, e.g. the lowRISC verilog coding style. Authors of Chisel code that translates to hardware constructs might therefore prefer to use snake_case. However, generated code can always be transformed to meet various emitted code requirements, so the official Chisel style guide follows the Scala convention. Why CamelCase instead of Snake_Case? The compiler inserts underscores when splitting Chisel/FIRRTL aggregate types into Verilog types. The compiler uses underscores to preserve the original structure of the data in the resulting Verilog. Because of the special meaning of underscores in Chisel-generated Verilog, their use in naming is strongly discouraged. Consider the following Chisel code: val msg = Wire(new Bundle { val valid = Bool() val addr = UInt(32) val data = UInt(64) }) val msg_rec = Wire(Bool()) Which compiles to the Verilog: wire msg_valid; wire [31:0] msg_addr; wire [63:0] msg_data; wire msg_rec; The Verilog maintains the structure of the original aggregate wire msg. However, because we named another variable msg_rec, it appears in the Verilog as if msg had 4 fields instead of its actual 3! If we instead follow the lowerCamelCase for values naming convention, the resulting Verilog makes more sense: val msg = Wire(new Bundle { val valid = Bool() val addr = UInt(32) val data = UInt(64) }) val msgRec = Wire(Bool()) And its resulting Verilog: wire msg_valid; wire [31:0] msg_addr; wire [63:0] msg_data; wire msgRec; Much better. Modules and Bundles (Classes, Traits, and Objects) Modules are Scala classes and thus use UpperCamelCase. class ModuleNamingExample extends Module { ... } Similarly, other classes (Chisel &amp; Scala) should be UpperCamelCase as well. trait UsefulScalaUtilities { def isEven(n: Int): Boolean = (n % 2) == 0 def isOdd(n: Int): Boolean = !isEven(n) } class MyCustomBundle extends Bundle { ... } // Companion object to MyCustomBundle object MyCustomBundle { ... } Values and Methods Values and methods should use lowerCamelCase. (Unless the value is a constant.) val mySuperReg = Reg(init = 0.asUInt(32)) def myImportantMethod(a: UInt): Bool = a &lt; 23.asUInt Constants Unlike the Google Java style, constants use UpperCamelCase, which is in line with the official Scala Naming Conventions. Constants are final fields (val or object) whose contents are deeply immutable and belong to a package object or an object. Examples: // Constants object Constants { val Number = 5 val Names = \"Ed\" :: \"Ann\" :: Nil val Ages = Map(\"Ed\" -&gt; 35, \"Ann\" -&gt; 32) } // Not constants class NonConstantsInClass { val inClass: String = \"in-class\" } object nonConstantsInObject { var varString = \"var-string\" val mutableCollection: scala.collection.mutable.Set[String] val mutableElements = Set(mutable) } UpperCamelCase vs. lowerCamelCase There is more than one reasonable way to covert English prose into camel case. We follow the convention defined in the Google Java style guide. The potentially non-obvious rule being to treat acronymns as words for the purpose of camel case. Note that the casing of the original words is almost entirely disregarded. Example: Prose form UpperCamelCase lowerCamelCase Incorrect find GCD FindGcd findGcd findGCD state for FSM StateForFsm stateForFsm stateForFSM mock dut MockDut mockDut MockDUT FIFO Generator FifoGenerator fifoGenerator FIFOGenerator"
    } ,    
    {
      "title": "Supported Hardware",
      "url": "/chisel3/docs/explanations/supported-hardware.html",
      "content": "Supported Hardware While Chisel focuses on binary logic, Chisel can support analog and tri-state wires with the Analog type - see Datatypes in Chisel. We focus on binary logic designs as they constitute the vast majority of designs in practice. Tri-state logic are poorly supported standard industry flows and require special/controlled hard macros in order to be done."
    } ,    
    {
      "title": "Test Coverage",
      "url": "/chisel3/docs/developers/test-coverage.html",
      "content": "Test Coverage Test Coverage Setup Chisel’s sbt build instructions contain the requisite plug-in (sbt-scoverage) for generating test coverage information. Please see the sbt-scoverage web page for details on the plug-in. The tests themselves are found in src/test/scala. Generating A Test Coverage Report Use the following sequence of sbt commands to generate a test coverage report: sbt clean coverage test sbt coverageReport The coverage reports should be found in target/scala-x.yy/scoverage-report/{scoverage.xml,index.html} where x.yy corresponds to the version of Scala used to compile Firrtl and the tests. scoverage.xml is useful if you want to analyze the results programmatically. index.html is designed for navigation with a web browser, allowing one to drill down to invidual statements covered (or not) by the tests."
    } ,    
    {
      "title": "Troubleshooting",
      "url": "/chisel3/docs/cookbooks/troubleshooting.html",
      "content": "Troubleshooting This page is a starting point for recording common and not so common problems in developing with Chisel3. In particular, those situations where there is a work around that will keep you going. type mismatch specifying width/value of a UInt/SInt I have some old code that used to work correctly in chisel2 (and still does if I use the import Chisel._ compatibility layer) but causes a type mismatch error in straight chisel3: class TestBlock extends Module { val io = IO(new Bundle { val output = Output(UInt(width=3)) }) } produces type mismatch; [error] found : Int(3) [error] required: chisel3.internal.firrtl.Width [error] val output = Output(UInt(width=3)) The single argument, multi-function object/constructors from chisel2 have been removed from chisel3. It was felt these were too prone to error and made it difficult to diagnose error conditions in chisel3 code. In chisel3, the single argument to the UInt/SInt object/constructor specifies the width and must be a Width type. Although there are no automatic conversions from Int to Width, an Int may be converted to a Width by applying the W method to an Int. In chisel3, the above code becomes: import chisel3._ class TestBlock extends Module { val io = IO(new Bundle { val output = Output(UInt(3.W)) }) } UInt/SInt literals may be created from an Int with the application of either the U or S method. UInt(42) // error: overloaded method value apply with alternatives: // (range: chisel3.internal.firrtl.IntervalRange)chisel3.UInt &lt;and&gt; // (width: chisel3.internal.firrtl.Width)chisel3.UInt // cannot be applied to (Int) // UInt(42) // ^^^^ in chisel2, becomes 42.U in chisel3 A literal with a specific width is created by calling the U or S method with a W argument. Use: 1.S(8.W) to create an 8-bit wide (signed) literal with value 1."
    } ,    
    {
      "title": "Unconnected Wires",
      "url": "/chisel3/docs/explanations/unconnected-wires.html",
      "content": "Unconnected Wires The Invalidate API (#645) adds support to Chisel for reporting unconnected wires as errors. Prior to this pull request, Chisel automatically generated a firrtl is invalid for Module IO(), and each Wire() definition. This made it difficult to detect cases where output signals were never driven. Chisel now supports a DontCare element, which may be connected to an output signal, indicating that that signal is intentionally not driven. Unless a signal is driven by hardware or connected to a DontCare, Firrtl will complain with a “not fully initialized” error. API Output signals may be connected to DontCare, generating a is invalid when the corresponding firrtl is emitted. class Out extends Bundle { val debug = Bool() val debugOption = Bool() } val io = new Bundle { val out = new Out } io.out.debug := true.B io.out.debugOption := DontCare This indicates that the signal io.out.debugOption is intentionally not driven and firrtl should not issue a “not fully initialized” error for this signal. This can be applied to aggregates as well as individual signals: import chisel3._ class ModWithVec extends Module { // ... val nElements = 5 val io = IO(new Bundle { val outs = Output(Vec(nElements, Bool())) }) io.outs &lt;&gt; DontCare // ... } class TrivialInterface extends Bundle { val in = Input(Bool()) val out = Output(Bool()) } class ModWithTrivalInterface extends Module { // ... val io = IO(new TrivialInterface) io &lt;&gt; DontCare // ... } This feature is controlled by CompileOptions.explicitInvalidate and is set to false in NotStrict (Chisel2 compatibility mode), and true in Strict mode. You can selectively enable this for Chisel2 compatibility mode by providing your own explicit compileOptions, either for a group of Modules (via inheritance): abstract class ExplicitInvalidateModule extends Module()(chisel3.ExplicitCompileOptions.NotStrict.copy(explicitInvalidate = true)) or on a per-Module basis: class MyModule extends Module { override val compileOptions = chisel3.ExplicitCompileOptions.NotStrict.copy(explicitInvalidate = true) val io = IO(new Bundle { /* ... */ } ) // ... } Or conversely, disable this stricter checking (which is now the default in pure chisel3): abstract class ImplicitInvalidateModule extends Module()(chisel3.ExplicitCompileOptions.Strict.copy(explicitInvalidate = false)) or on a per-Module basis: class MyModule extends Module { override val compileOptions = chisel3.ExplicitCompileOptions.Strict.copy(explicitInvalidate = false) val io = IO(new Bundle { /* ... */ } ) // ... } Please see the corresponding API tests for examples. Determining the unconnected element I have an interface with 42 wires. Which one of them is unconnected? The firrtl error message should contain something like: firrtl.passes.CheckInitialization$RefNotInitializedException: @[:@6.4] : [module Router] Reference io is not fully initialized. @[Decoupled.scala 38:19:@48.12] : node _GEN_23 = mux(and(UInt&lt;1&gt;(\"h1\"), eq(UInt&lt;2&gt;(\"h3\"), _T_84)), _GEN_2, VOID) @[Decoupled.scala 38:19:@48.12] @[Router.scala 78:30:@44.10] : node _GEN_36 = mux(_GEN_0.ready, _GEN_23, VOID) @[Router.scala 78:30:@44.10] @[Router.scala 75:26:@39.8] : node _GEN_54 = mux(io.in.valid, _GEN_36, VOID) @[Router.scala 75:26:@39.8] @[Router.scala 70:50:@27.6] : node _GEN_76 = mux(io.load_routing_table_request.valid, VOID, _GEN_54) @[Router.scala 70:50:@27.6] @[Router.scala 65:85:@19.4] : node _GEN_102 = mux(_T_62, VOID, _GEN_76) @[Router.scala 65:85:@19.4] : io.outs[3].bits.body &lt;= _GEN_102 The first line is the initial error report. Successive lines, indented and beginning with source line information indicate connections involving the problematic signal. Unfortunately, if these are when conditions involving muxes, they may be difficult to decipher. The last line of the group, indented and beginning with a : should indicate the uninitialized signal component. This example (from the Router tutorial) was produced when the output queue bits were not initialized. The old code was: io.outs.foreach { out =&gt; out.noenq() } which initialized the queue’s valid bit, but did not initialize the actual output values. The fix was: io.outs.foreach { out =&gt; out.bits := 0.U.asTypeOf(out.bits) out.noenq() }"
    } ,    
    {
      "title": "Upgrading From Chisel 3.4 to 3.5",
      "url": "/chisel3/docs/appendix/upgrading-from-chisel-3-4.html",
      "content": "Upgrading From Chisel 3.4 to 3.5 Chisel 3.5 was a major step forward. It added support for Scala 2.13 as well as dropped many long deprecated APIs. Some users may run into issues while upgrading so this page serves as a central location to describe solutions to common issues. General Strategy for Upgrade Users are encouraged to first upgrade to the latest version of Chisel 3.4 (3.4.4 at the time of writing) and resolve all deprecation warnings. Doing so should enable a smoother transition to Chisel 3.5. Common Issues Value io is not a member of chisel3.Module This issue most often arises when there are two implementations of a given Module that may be chosen between by a generator parameter. For example: class Foo extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) io.out := io.in } class Bar extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) io.out := io.in + 1.U } class Example(useBar: Boolean) extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val inst = if (useBar) { Module(new Bar) } else { Module(new Foo) } inst.io.in := io.in io.out := inst.io.out } // error: value io is not a member of chisel3.Module // inst.io.in := io.in // ^^^^^^^ // error: value io is not a member of chisel3.Module // io.out := inst.io.out // ^^^^^^^ Foo and Bar clearly have the same interface, yet we get a type error in Chisel 3.5. Notably, while this does work in Chisel 3.4, it does throw a deprecation warning. In short, this code is relying on old behavior of the Scala type inferencer. In Scala 2.11 and before, the type inferred for val inst is: Module { def io : { def in : UInt; def out : UInt } }. And in fact, if we manually ascribe this type to val inst, our same code from above works in Chisel 3.5: class Example(useBar: Boolean) extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val inst: Module { def io : { def in : UInt; def out : UInt } } = if (useBar) { Module(new Bar) } else { Module(new Foo) } inst.io.in := io.in io.out := inst.io.out } So what is going on and why is this type so ugly? This is called a structural (or duck) type. Basically, code does not provide any unifying type for Foo and Bar so the compiler does its best to make one up. One negative consequence of the old Scala behavior is that structural type inference makes it very easy to accidentally change the public API of your code without meaning to. Thus, in the bump from Scala 2.11 to 2.12, the behavior of the Scala compiler changed to not do structural type inference by default. The solution, is to explicitly provide a type to the Scala compiler: trait HasCommonInterface extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) } class Foo extends Module with HasCommonInterface { io.out := io.in } class Bar extends Module with HasCommonInterface { io.out := io.in + 1.U } Now our original code works: class Example(useBar: Boolean) extends Module { val io = IO(new Bundle { val in = IO(Input(UInt(8.W))) val out = IO(Output(UInt(8.W))) }) // Now, inst is inferred to be of type \"HasCommonInterface\" val inst = if (useBar) { Module(new Bar) } else { Module(new Foo) } inst.io.in := io.in io.out := inst.io.out } Historical Note This may sound similar because a very similar error is included in Common Issues in the Appendix for upgrading from Scala 2.11 to 2.12. The workaround employed in Chisel for Scala 2.12 did not work in Scala 2.13, so we came up with the more robust solution described above."
    } ,    
    {
      "title": "Upgrading From Scala 2.11",
      "url": "/chisel3/docs/appendix/upgrading-from-scala-2-11.html",
      "content": "Upgrading From Scala 2.11 to 2.12 As of Chisel 3.5, support for Scala 2.11 has been dropped. This page is only relevant to Chisel versions 3.4 and earlier As the latest (and probably last) release of Scala 2.11 (2.11.12) was released on 2 November 2017, the time has come to deprecate support for Scala 2.11. Chisel 3.4 is the last version of Chisel that will support Scala 2.11, so users should upgrade to Scala 2.12 This document is intended to help guide Chisel users through this process; both the “Why?” and the “How?”. Scala Versioning Scala versions have the following structure: 2.X.Y where X is the major version and Y is the minor version. Note that while we keep the leading 2 constant, there is a project, Dotty, that is slated to become Scala 3. Scala maintains both source and binary compatiblity between minor versions, but not between major versions. Binary compatibility is defined at the level of the Java Byte Code (the .class or .jar files compiled from .scala). This means that Scala projects that support multiple major versions of Scala must be compiled and published for each supported version. When publishing artifacts to Maven repositories, this manifests as an appendix on the Artifact ID. Taking Chisel v3.3.2 as an example, the “Artifact ID” is “chisel3_2.12” for Scala 2.12, and “chisel3_2.11” for Scala 2.11. For more information, see the documentation on the Scala website: Binary Compatibility of Scala Releases Binary Compatibility for Library Authoers How to Upgrade For most users, this is as simple as changing the scalaVersion field in your build.sbt: scalaVersion := \"2.11.12\" Becomes scalaVersion := \"2.12.12\" Now, the next time you run SBT, it will be using the Scala 2.12 version of Chisel 3 (as well as any other dependencies you have). Common Issues As mentioned in the previous section, Scala does not maintain source compatibilty between major versions. Put another way, sometimes they break things in backwards incompatible ways. This section includes some common issues that Chisel users run into and how to fix them. For complete information about changes, please see the release notes for Scala 2.12.0. Value is not a member of chisel3.Bundle The most common problem for Chisel users upgrading from Scala 2.11 to 2.12 is a change in Scala type inference. This usually occurs in the context of io Bundles in Modules, given: class Foo extends Module { val io = IO(new Bundle { val in = Input(Bool()) val out = Output(Bool()) }) io.out := ~io.in } You may see an error that says somethign like “value out is not a member of chisel3.Bundle”: [error] /workspace/src/main/scala/gcd/Foo.scala:9:6: value out is not a member of chisel3.Bundle [error] io.out := ~io.in [error] ^ [error] /workspace/src/main/scala/gcd/Foo.scala:9:17: value in is not a member of chisel3.Bundle [error] io.out := ~io.in [error] ^ [error] two errors found This can be worked around by adding -Xsource:2.11 to your scalacOptions. This is most commonly set in your build.sbt. For an example, see the chisel-template’s build.sbt."
    } ,    
    {
      "title": "Verilog-vs-Chisel",
      "url": "/chisel3/docs/cookbooks/verilog-vs-chisel.html",
      "content": "&lt;!Doctype html&gt; # Verilog vs Chisel Side-By-Side This page serves as a quick introduction to Chisel for those familiar with Verilog. It is by no means a comprehensive guide of everything Chisel can do. Feel free to file an issue with suggestions of things you'd like to see added to this page. Creating a Module Verilog Chisel ```verilog module Foo ( input a, output b ); assign b = a; endmodule ``` ```scala class Foo extends Module { val a = IO(Input(Bool())) val b = IO(Output(Bool())) b := a } ``` Parameterizing a Module Verilog Chisel ```verilog module PassthroughGenerator( input [width-1:0] in, output [width-1:0] out ); parameter width = 8; assign out = in; endmodule ``` ```scala class PassthroughGenerator(width: Int = 8) extends Module { val in = IO(Input(UInt(width.W))) val out = IO(Output(UInt(width.W))) out := in } ``` ```verilog module ParameterizedWidthAdder( input [in0Width-1:0] in0, input [in1Width-1:0] in1, output [sumWidth-1:0] sum ); parameter in0Width = 8; parameter in1Width = 1; parameter sumWidth = 9; assign sum = in0 + in1; endmodule ``` ```scala class ParameterizedWidthAdder( in0Width: Int, in1Width: Int, sumWidth: Int) extends Module { val in0 = IO(Input(UInt(in0Width.W))) val in1 = IO(Input(UInt(in1Width.W))) val sum = IO(Output(UInt(sumWidth.W))) // a +&amp; b includes the carry, a + b does not sum := in0 +&amp; in1 } ``` # Wire Assignment and Literal Values Verilog Chisel ```verilog module MyWireAssignmentModule (); wire [31:0] aa = 'd42; // Logical reg for use in always block, not real register reg [31:0] a; // always @(*) begin a = aa; end // Hex value initialization wire [31:0] b = 32'hbabecafe; // Declaration separate from Assignment wire [15:0] c; wire d; assign c = 16'b1; assign d = 1'b1; // Signed values wire signed [63:0] g; assign g = -’d5; wire signed [31:0] h = 'd5; reg signed[31:0] f; always@(*) begin f = ‘d5; end endmodule ``` ```scala class MyWireAssignmentModule extends Module { val aa = 42.U(32.W) val a = Wire(UInt(32.W)) a := aa val b = \"hbabecafe\".U(32.W) val c = Wire(UInt(16.W)) val d = Wire(Bool()) c := \"b1\".U(16.W) d := true.B val g = Wire(SInt(64.W)) g := -5.S val h = 5.asSInt(32.W) val f = Wire(SInt(32.W)) f := 5.S } ``` # Register Declaration and Assignment Verilog Chisel ```verilog module RegisterModule( input clock, input reset, input [7:0] in, output [7:0] out, input differentClock, input differentSyncReset, input differentAsyncReset ); reg [7:0] registerWithoutInit; reg [7:0] registerWithInit; reg [7:0] registerOnDifferentClockAndSyncReset; reg [7:0] registerOnDifferentClockAndAsyncReset; always @(posedge clock) begin registerWithoutInit &lt;= in + 8'h1; end always @(posedge clock) begin if (reset) begin registerWithInit &lt;= 8'd42; end else begin registerWithInit &lt;= registerWithInit - 8'h1; end end always @(posedge differentClock) begin if (differentSyncReset) begin registerOnDifferentClockAndSyncReset &lt;= 8'h42; end else begin registerOnDifferentClockAndSyncReset &lt;= in - 8'h1; end end always @(posedge differentClock or posedge differentAsyncReset) begin if (differentAsyncReset) begin registerOnDifferentClockAndAsyncReset &lt;= 8'h24; end else begin registerOnDifferentClockAndAsyncReset &lt;= in + 8'h2; end end assign out = in + registerWithoutInit + registerWithInit + registerOnDifferentClockAndSyncReset + registerOnDifferentClockAndAsyncReset; endmodule ``` ```scala class RegisterModule extends Module { val in = IO(Input(UInt(8.W))) val out = IO(Output(UInt(8.W))) val differentClock = IO(Input(Clock())) val differentSyncReset = IO(Input(Bool())) val differentAsyncReset = IO(Input(AsyncReset())) val registerWithoutInit = Reg(UInt(8.W)) val registerWithInit = RegInit(42.U(8.W)) registerWithoutInit := in + 1.U registerWithInit := registerWithInit - 1.U val registerOnDifferentClockAndSyncReset = withClockAndReset(differentClock, differentSyncReset) { val reg = RegInit(\"h42\".U(8.W)) reg } registerOnDifferentClockAndSyncReset := in - 1.U val registerOnDifferentClockAndAsyncReset = withClockAndReset(differentClock, differentAsyncReset) { val reg = RegInit(\"h24\".U(8.W)) reg } registerOnDifferentClockAndAsyncReset := in + 2.U out := in + registerWithoutInit + registerWithInit + registerOnDifferentClockAndSyncReset + registerOnDifferentClockAndAsyncReset } ``` # Case Statements Verilog Chisel ```verilog module CaseStatementModule( input [2:0] a, input [2:0] b, input [2:0] c, input [1:0] sel, output reg [2:0] out ); always @(*) case (sel) 2'b00: out &lt;= a; 2'b01: out &lt;= b; 2'b10: out &lt;= c; default: out &lt;= 3'b0; end end endmodule ``` ```scala class CaseStatementModule extends Module { val a, b, c= IO(Input(UInt(3.W))) val sel = IO(Input(UInt(2.W))) val out = IO(Output(UInt(3.W))) // default goes first out := 0.U switch (sel) { is (\"b00\".U) { out := a } is (\"b01\".U) { out := b } is (\"b10\".U) { out := c } } } ``` # Case Statements Using Enums Verilog Chisel ```verilog module CaseStatementEnumModule1 ( input [2:0] rs1, input [2:0] pc, input AluMux1Sel sel, output reg [2:0] out); typedef enum {SELECT_RS1, SELECT_PC} AluMux1Sel; case(sel) SELECT_RS1: out &lt;= rs1; SELECT_PC: out &lt;= pc; default: out &lt;= 3'b0; end endmodule ``` ```scala class CaseStatementEnumModule1 extends Module { object AluMux1Sel extends ChiselEnum { val selectRS1, selectPC = Value } import AluMux1Sel._ val rs1, pc = IO(Input(UInt(3.W))) val sel = IO(Input(AluMux1Sel())) val out = IO(Output(UInt(3.W))) // default goes first out := 0.U switch (sel) { is (selectRS1) { out := rs1 } is (selectPC) { out := pc } } } ``` ```verilog module CaseStatementEnumModule2 (input clk); typedef enum { INIT = 3, IDLE = 'h13, START = 'h17, READY = 'h23 } StateValue; reg StateValue state; always @(posedge clk) begin case (state) IDLE : state = START; START : state = READY; READY : state = IDLE ; default : state = IDLE ; endcase end endmodule ``` ```scala class CaseStatementEnumModule2 extends Module { object StateValue extends ChiselEnum { val INIT = Value(0x03.U) val IDLE = Value(0x13.U) val START = Value(0x17.U) val READY = Value(0x23.U) } import StateValue._ val state = Reg(StateValue()) switch (state) { is (INIT) {state := IDLE} is (IDLE) {state := START} is (START) {state := READY} is (READY) {state := IDLE} } } ``` # Multi-Dimensional Memories Verilog Chisel ```verilog module ReadWriteSmem( input clock, input reset, input io_enable, input io_write, input [9:0] io_addr, input [31:0] io_dataIn, output [31:0] io_dataOut ); reg [31:0] mem [0:1023]; reg [9:0] addr_delay; assign io_dataOut = mem[addr_delay] always @(posedge clock) begin if (io_enable &amp; io_write) begin mem[io_addr] &lt;= io_data; end if (io_enable) begin addr_delay &lt;= io_addr; end end endmodule ``` ```scala class ReadWriteSmem extends Module { val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val addr = Input(UInt(10.W)) val dataIn = Input(UInt(32.W)) val dataOut = Output(UInt(32.W)) }) val mem = SyncReadMem(1024, UInt(32.W)) // Create one write port and one read port mem.write(io.addr, io.dataIn) io.dataOut := mem.read(io.addr, io.enable) } ``` ```verilog module ReadWriteMem( input clock, input io_enable, input io_write, input [9:0] io_addr, input [31:0] io_dataIn, output [31:0] io_dataOut ); reg [31:0] mem [0:1023]; assign io_dataOut = mem[io_addr]; always @(posedge clock) begin if (io_enable &amp;&amp; io_write) begin mem[io_addr] &lt;= io_dataIn; end end endmodule ``` ```scala class ReadWriteMem extends Module { val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val addr = Input(UInt(10.W)) val dataIn = Input(UInt(32.W)) val dataOut = Output(UInt(32.W)) }) val mem = Mem(1024, UInt(32.W)) // Create one write port and one read port mem.write(io.addr, io.dataIn) io.dataOut := mem.read(io.addr) } ``` # Operators Verilog Chisel ```verilog module OperatorExampleModule( input clock, input reset, input [31:0] x, input [31:0] y, input [31:0] c, output [31:0] add_res, output [31:0] sub_res, output [31:0] mod_res, output [31:0] div_res, output [31:0] and_res, output [31:0] or_res, output [31:0] xor_res, output [31:0] not_res, output [31:0] logical_not_res, output [31:0] mux_res, output [31:0] rshift_res, output [31:0] lshift_res, output andR_res, output logical_and_res, output logical_or_res, output equ_res, output not_equ_res, output orR_res, output xorR_res, output gt_res, output lt_res, output geq_res, output leq_res, output single_bitselect_res, output [63:0] mul_res, output [63:0] cat_res, output [1:0] multiple_bitselect_res, output [95:0] fill_res ); assign add_res = x + y; assign sub_res = x - y; assign mod_res = x % y; assign mul_res = x * y; assign div_res = x / y; assign equ_res = x == y; assign not_equ_res = x != y; assign and_res = x &amp; y; assign or_res = x | y; assign xor_res = x ^ y; assign not_res = ~x; assign logical_not_res = !(x == 32'h0); assign logical_and_res = x[0] &amp;&amp; y[0]; assign logical_or_res = x[0] || y[0]; assign cat_res = {x,y}; assign mux_res = c[0] ? x : y; assign rshift_res = x &gt;&gt; y[2:0]; assign lshift_res = x &lt;&lt; y[2:0]; assign gt_res = x &gt; y; assign lt_res = x &lt; y; assign geq_res = x &gt;= y; assign leq_res = x &lt;= y; assign single_bitselect_res = x[1]; assign multiple_bitselect_res = x[1:0]; assign fill_res = {3{x}}; assign andR_res = &x; assign orR_res = |x; assign xorR_res = ^x; endmodule ``` ```scala class OperatorExampleModule extends Module { val x, y, c = IO(Input(UInt(32.W))) val add_res, sub_res, mod_res, div_res, and_res, or_res, xor_res, not_res, logical_not_res, mux_res, rshift_res , lshift_res = IO(Output(UInt(32.W))) val logical_and_res, logical_or_res, equ_res, not_equ_res, andR_res, orR_res, xorR_res, gt_res,lt_res, geq_res, leq_res,single_bitselect_res = IO(Output(Bool())) val mul_res, cat_res= IO(Output(UInt(64.W))) val multiple_bitselect_res = IO(Output(UInt(2.W))) val fill_res = IO(Output(UInt((3*32).W))) add_res := x + y sub_res := x - y mod_res := x % y mul_res := x * y div_res := x / y equ_res := x === y not_equ_res := x =/= y and_res := x &amp; y or_res := x | y xor_res := x ^ y not_res := ~x logical_not_res := !x logical_and_res := x(0) &amp;&amp; y(0) logical_or_res := x(0) || y(0) cat_res := Cat(x, y) mux_res := Mux(c(0), x, y) rshift_res := x &gt;&gt; y(2, 0) lshift_res := x &lt;&lt; y(2, 0) gt_res := x &gt; y lt_res := x &lt; y geq_res := x &gt;= y leq_res := x &lt;= y single_bitselect_res := x(1) multiple_bitselect_res := x(1, 0) fill_res:= Fill(3,x) andR_res := x.andR orR_res := x.orR xorR_res := x.xorR } ```"
    } ,    
    {
      "title": "Versioning",
      "url": "/chisel3/docs/appendix/versioning.html",
      "content": "Chisel Project Versioning Chisel and related projects follow a versioning scheme similar to PVP. Project versions are of the form A.B.C where A.B specifies the Major version and C specifies the Minor version. Projects maintain binary compatibility between minor versions of the same major version. For example, a project compiled against Chisel3 version 3.4.0 can be used with Chisel3 version 3.4.2 or 3.4.15 without recompilation. Compatible Versions Historically, due to a mistake in versioning with chisel-iotesters as well as some projects originating later than others, the compatible versions of Chisel-related projects has not been obvious. We are taking steps to improve the situation by bringing the major versions more in line (the B part in A.B.C), but the inconsistencies remain in previously published versions. Beginning with Chisel 3.5, the major versions for all projects are aligned on A.5). Please use the following table to determine which versions of the related projects are compatible. In particular, versions of projects in this table were compiled against the version of any dependencies listed in the same row. For example, chisel-iotesters version 1.4 was compiled against chisel3 version 3.3. chisel3 chiseltest chisel-iotesters3 firrtl treadle diagrammer firrtl-interpreter2 3.5 0.54 2.55 1.5 1.54 1.54 - 3.4 0.3 1.5 1.4 1.3 1.3 1.4 3.3 0.2 1.4 1.3 1.2 1.2 1.3 3.2 0.11 1.3 1.2 1.1 1.1 1.2 3.1 - 1.2 1.1 1.0 1.0 1.1 3.0 - 1.1 1.0 - - 1.0 1 chiseltest 0.1 was published under artifact name chisel-testers2 (0.2 was published under both artifact names) 2 Replaced by Treadle, in maintenance mode only since version 1.1, final version is 1.4 3 Replaced by chiseltest, final version is 2.5 4 chiseltest, treadle, and diagrammer skipped X.4 to have a consistent major version with Chisel 5 chisel-iotesters skipped from 1.5 to 2.5 to have a consistent major version with Chisel"
    } ,    
    {
      "title": "Width Inference",
      "url": "/chisel3/docs/explanations/width-inference.html",
      "content": "Width Inference Chisel provides bit width inference to reduce design effort. Users are encouraged to manually specify widths of ports and registers to prevent any surprises, but otherwise unspecified widths will be inferred by the Firrtl compiler. For all circuit components declared with unspecified widths, the FIRRTL compiler will infer the minimum possible width that maintains the legality of all its incoming connections. Implicit here is that inference is done in a right to left fashion in the sense of an assignment statement in chisel, i.e. from the left hand side from the right hand side. If a component has no incoming connections, and the width is unspecified, then an error is thrown to indicate that the width could not be inferred. For module input ports with unspecified widths, the inferred width is the minimum possible width that maintains the legality of all incoming connections to all instantiations of the module. The width of a ground-typed multiplexor expression is the maximum of its two corresponding input widths. For multiplexing aggregate-typed expressions, the resulting widths of each leaf subelement is the maximum of its corresponding two input leaf subelement widths. The width of a conditionally valid expression is the width of its input expression. For the full formal description see the Firrtl Spec. Hardware operators have output widths as defined by the following set of rules: operation bit width z = x + y or z = x +% y w(z) = max(w(x), w(y)) z = x +&amp; y w(z) = max(w(x), w(y)) + 1 z = x - y or z = x -% y w(z) = max(w(x), w(y)) z = x -&amp; y w(z) = max(w(x), w(y)) + 1 z = x &amp; y w(z) = max(w(x), w(y)) z = Mux(c, x, y) w(z) = max(w(x), w(y)) z = w * y w(z) = w(x) + w(y) z = x &lt;&lt; n w(z) = w(x) + maxNum(n) z = x &gt;&gt; n w(z) = w(x) - minNum(n) z = Cat(x, y) w(z) = w(x) + w(y) z = Fill(n, x) w(z) = w(x) * maxNum(n) where for instance w(z) is the bit width of wire z, and the &amp; rule applies to all bitwise logical operations. Given a path of connections that begins with an unspecified width element (most commonly a top-level input), then the compiler will throw an exception indicating a certain width was uninferrable. A common “gotcha” comes from truncating addition and subtraction with the operators + and -. Users who want the result to maintain the full, expanded precision of the addition or subtraction should use the expanding operators +&amp; and -&amp;. The default truncating operation comes from Chisel’s history as a microprocessor design language."
    } ,                      
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
