package svsim

import java.io.{BufferedWriter, FileWriter}

case class ModuleInfo(
  name:  String,
  ports: Seq[ModuleInfo.Port]) {
  private[svsim] val instanceName = "dut"
}
object ModuleInfo {
  case class Port(
    name:       String,
    isSettable: Boolean = false,
    isGettable: Boolean = false) {
    assert(name.matches("^[a-zA-Z0-9\\-_]*$"))
  }
}

object Workspace {
  val testbenchModuleName: String = "svsimTestbench"
}
final class Workspace(
  val path: String) {

  protected final val workspacePath: os.Path = if (path.startsWith("/")) os.Path(path) else os.pwd / os.RelPath(path)

  protected final val supportArtifactsPath = os.rel / "support-artifacts"
  protected final val primarySourcesPath = os.rel / "primary-sources"
  protected final val generatedSourcesPath = os.rel / "generated-sources"

  protected var _moduleInfo: Option[ModuleInfo] = None

  protected val cacheDirectoryNames = Seq[String]()

  final def reset(clearCaches: Boolean = false) = {
    if (os.exists(workspacePath)) {
      os.list(workspacePath)
        .filter { path =>
          clearCaches || !cacheDirectoryNames.contains(path.baseName)
        }
        .foreach(os.remove.all(_))
    }
    os.makeDir.all(workspacePath / supportArtifactsPath)
    os.makeDir.all(workspacePath / primarySourcesPath)
    os.makeDir.all(workspacePath / generatedSourcesPath)
  }

  /** A directory where the user can store additional artifacts which are relevant to the primary sources (for instance, artifacts related to the generation of primary sources). These artifacts have no impact on the simulation, but it may be useful to group them with the other files generated by svsim for debugging purposes.
    */
  final def supportArtifactsDirectoryPath: String = (workspacePath / supportArtifactsPath).toString()

  /** The directory containing user-provided source files used to compile the simulation when `compile` is called.
    */
  final def primarySourcesDirectoryPath: String = (workspacePath / primarySourcesPath).toString()

  private final def copyResource(klass: Class[_], name: String, targetDirectory: os.Path) = {
    val inputStream = klass.getResourceAsStream(name)
    if (inputStream == null) throw new java.io.FileNotFoundException(name)
    val file = new java.io.File(targetDirectory.toString(), name.split("/").last)
    val outputStream = new java.io.FileOutputStream(file)
    Iterator
      .continually(inputStream.read)
      .takeWhile(_ != -1)
      .foreach(outputStream.write)
    inputStream.close()
    outputStream.close()
  }

  /** A helper method which copies the specified resource into the primary sources directory.
    */
  final def addPrimarySourceFromResource(klass: Class[_], name: String) = {
    copyResource(klass, name, workspacePath / primarySourcesPath)
  }

  final def elaborate(moduleInfo: ModuleInfo) = {
    assert(_moduleInfo.isEmpty)
    _moduleInfo = Some(moduleInfo)
  }

  /** Generate additional sources necessary for simulating the module.
    */
  //format: off
  final def generateAdditionalSources() = {
    val dut = _moduleInfo.get
    val ports = dut.ports.zipWithIndex
    val path = workspacePath/generatedSourcesPath

    val systemVerilogTestbenchWriter = new LineWriter(path/"testbench.sv")
    try {
      val l = systemVerilogTestbenchWriter

      l("module ", Workspace.testbenchModuleName, ";")
      for ((port, index) <- ports) {
        if (port.isSettable) {
      l("  reg  [$bits(", dut.instanceName, ".",  port.name, ")-1:0] ", port.name, ";")
        } else {
      l("  wire [$bits(", dut.instanceName, ".",  port.name, ")-1:0] ", port.name, ";")
        }
      }
      l()
      l(dut.name, " ", dut.instanceName, " (")
      for ((port, index) <- ports) {
      l("    .", port.name, "(", port.name, ")", if (index != ports.length - 1) "," else "")
      }
      l(");")
      l()
      for ((port, index) <- ports) {
      l("  // Port ", index.toHexString, ": ", port.name)
      l("  export \"DPI-C\" function getBitWidth_", port.name, ";")
      l("  function void getBitWidth_", port.name, ";")
      l("    output int value;")
      l("    value", " = $bits(", dut.instanceName, ".",  port.name, ");")
      l("  endfunction")
        if (port.isSettable) {
      l("  export \"DPI-C\" function setBits_", port.name, ";")
      l("  function void setBits_", port.name, ";")
      l("    input bit [$bits(", dut.instanceName, ".",  port.name, ")-1:0] value_", port.name, ";")
      l("    ", port.name, " = value_", port.name, ";")
      l("  endfunction")
        }
        if (port.isGettable) {
      l("  export \"DPI-C\" function getBits_", port.name, ";")
      l("  function void getBits_", port.name, ";")
      l("    output bit [$bits(", dut.instanceName, ".",  port.name, ")-1:0] value_", port.name, ";")
      l("    value_", port.name, " = ", port.name, ";")
      l("  endfunction")
        }
      l()
      }
      l("  // Simulation")
      l("  import \"DPI-C\" context task simulation_body();")
      l("  initial begin")
      l("    simulation_body();")
      l("  end")
      l("  `ifdef ", Backend.supportsDelayInPublicFunctionsFlag)
      l("  export \"DPI-C\" task run_simulation;")
      l("  task run_simulation;")
      l("    input int timesteps;")
      l("    #timesteps;")
      l("  endtask")
      l("  `else")
      l("  import \"DPI-C\" function void run_simulation(int timesteps);")
      l("  `endif")
      l()

      l("  // Tracing")
      l("  export \"DPI-C\" function simulation_initializeTrace;")
      l("  function void simulation_initializeTrace;")
      l("    input string traceFilePath;")
      l("    `ifdef SVSIM_ENABLE_VCD_TRACING")
      l("      $dumpfile({traceFilePath,\".vcd\"});")
      l("      $dumpvars(0, ", dut.instanceName,");")
      l("    `endif")
      l("    `ifdef SVSIM_ENABLE_VPD_TRACING")
      l("      $vcdplusfile({traceFilePath,\".vpd\"});")
      l("      $dumpvars(0, ", dut.instanceName,");")
      l("      $vcdpluson(0, ", dut.instanceName,");")
      l("    `endif")
      l("    `ifdef SVSIM_ENABLE_FSDB_TRACING")
      l("      $fsdbDumpfile({traceFilePath,\".fsdb\"});")
      l("      $fsdbDumpvars(0, ", dut.instanceName,");")
      l("    `endif")
      l("  endfunction")
      l("  export \"DPI-C\" function simulation_enableTrace;")
      l("  function void simulation_enableTrace;")
      l("    `ifdef SVSIM_ENABLE_VCD_TRACING")
      l("    $dumpon;")
      l("    `elsif SVSIM_ENABLE_VPD_TRACING")
      l("    $dumpon;")
      l("    `endif")
      l("    `ifdef SVSIM_ENABLE_FSDB_TRACING")
      l("    $fsdbDumpon;")
      l("    `endif")
      l("  endfunction")
      l("  export \"DPI-C\" function simulation_disableTrace;")
      l("  function void simulation_disableTrace;")
      l("    `ifdef SVSIM_ENABLE_VCD_TRACING")
      l("    $dumpoff;")
      l("    `elsif SVSIM_ENABLE_VPD_TRACING")
      l("    $dumpoff;")
      l("    `endif")
      l("    `ifdef SVSIM_ENABLE_FSDB_TRACING")
      l("    $fsdbDumpoff;")
      l("    `endif")
      l("  endfunction")
      l()
      l("endmodule")
    } finally {
      // `BufferedWriter` closes the underlying `FileWriter` when closed.
      systemVerilogTestbenchWriter.close()
    }

    val cDPIBridgeWriter = new LineWriter(path/"c-dpi-bridge.cpp")
    try {
      val l = cDPIBridgeWriter
      l("#include <stdint.h>")
      l()      
      l("#ifdef SVSIM_ENABLE_VERILATOR_SUPPORT")
      l("#include \"verilated-sources/VsvsimTestbench__Dpi.h\"")
      l("#endif")
      l("#ifdef SVSIM_ENABLE_VCS_SUPPORT")
      l("#include \"vc_hdrs.h\"")
      l("#endif")
      l()
      l("extern \"C\" {")
      l()
      l("int port_getter(int id, int *bitWidth, void (**getter)(uint8_t*)) {")
      l("  switch (id) {")
      for ((port, index) <- ports.filter(_._1.isGettable)) {
      l("    case ", index.toString(), ": // ", port.name)
      l("      getBitWidth_", port.name, "(bitWidth);")
      l("      *getter = (void(*)(uint8_t*))getBits_", port.name, ";")
      l("      return 0;")
      }
      l("    default:")
      l("      return -1;")
      l("  }")
      l("}")
      l()
      l("int port_setter(int id, int *bitWidth, void (**setter)(const uint8_t*)) {")
      l("  switch (id) {")
      for ((port, index) <- ports.filter(_._1.isSettable)) {
      l("    case ", index.toString(), ": // ", port.name)
      l("      getBitWidth_", port.name, "(bitWidth);")
      l("      *setter = (void(*)(const uint8_t*))setBits_", port.name, ";")
      l("      return 0;")
      }
      l("    default:")
      l("      return -1;")
      l("  }")
      l("}")
      l()
      l("} // extern \"C\"")
      l()

    } finally {
      cDPIBridgeWriter.close()
    }
  
    copyResource(this.getClass, "/simulation-driver.cpp", path)
  }
  //format: on

  /** Compiles the simulation using the specified backend.
    *
    * @param outputTag A string which will be used to tag the output directory. This enables compiling and simulating the same workspace with multiple backends.
    */
  def compile[T <: Backend](
    backend:                          T
  )(outputTag:                        String,
    commonSettings:                   SvsimCompilationSettings,
    backendSpecificSettings:          backend.CompilationSettings,
    customSimulationWorkingDirectory: Option[String]
  ): Simulation = {
    val moduleInfo = _moduleInfo.get
    val workingDirectory = workspacePath / s"outputs-${outputTag}"
    if (os.exists(workingDirectory)) os.remove.all(workingDirectory)
    os.makeDir.all(workingDirectory)
    val invocationSettings = backend.invocationSettings(
      outputBinaryName = "simulation",
      topModuleName = Workspace.testbenchModuleName,
      additionalHeaderPaths = Seq(workingDirectory.toString),
      commonSettings = commonSettings,
      backendSpecificSettings = backendSpecificSettings
    )
    val sourceFiles = Seq(primarySourcesPath, generatedSourcesPath)
      .map(workspacePath / _)
      .flatMap(os.list)
      .map(_.relativeTo(workingDirectory))
      .map { path => path.toString() }

    val simulationEnvironment = Seq(
      "SVSIM_SIMULATION_LOG" -> (workingDirectory / "simulation-log.txt").toString(),
      // The simulation driver appends the appropriate extension to the file path
      "SVSIM_SIMULATION_TRACE" -> (workingDirectory / "trace").toString()
    ) ++ invocationSettings.simulationEnvironment

    // Emit Makefile for debugging (will be emitted even if compile fails)
    val makefileWriter = new LineWriter(workingDirectory / "Makefile")
    try {
      val l = makefileWriter
      //format: off
      // For this debug flow, we rebuild the simulation from scratch every time, to avoid issues if the simulation was originally compiled in a different environment, like using SiFive's `wake`.
      l(".PHONY: clean simulation replay")

      l("clean:")
	    l("\tls . | grep -v Makefile | grep -v execution-script.txt | xargs rm -rf")
      l()
      l("simulation: clean")
      l("\t$(compilerEnvironment) \\")
	    l("\t", invocationSettings.compilerPath, " \\")
      for (argument <- invocationSettings.compilerArguments) {
        val sanitizedArugment = argument
          .replace("$", "$$")
          .replace("'", "'\\''")
          .replace(workingDirectory.toString, "$(shell pwd)")
      l("\t\t'", sanitizedArugment, "' \\")
      }
      l("\t\t$(sourcefiles)")
      l()
      l("replay: simulation")
      val executionScriptPath = "$(shell pwd)/execution-script.txt"
      customSimulationWorkingDirectory match {
        case None =>
        case Some(value) => {
          // Calculate relative path, to avoid being broken by wake's directory shenanigans
          val relativePath = os.Path(value).relativeTo(workingDirectory).toString
          l("\tcd ", relativePath, " && \\")
        }
      }
      l("\tcat ", executionScriptPath, " | { grep '^#' || true; } && \\")
      l("\tcat ", executionScriptPath, " | sed -n 's/^[0-9]*> \\(.*\\)/\\1/p' | \\")
      l("\t\t$(simulationEnvironment) $(shell pwd)/simulation \\")
      for (argument <- invocationSettings.simulationArguments) {
      l("\t\t\t'", argument.replace("$", "$$"), "' \\")
      }
      l()
      l("sourcefiles = \\")
      for ((sourceFile, index) <- sourceFiles.zipWithIndex) {
      l("\t'", sourceFile, "'", if (index != sourceFiles.length - 1) " \\" else "")
      }
      l()
      l("compilerEnvironment = \\")
      for (((name, value), index) <- invocationSettings.compilerEnvironment.zipWithIndex) {
      l("\t", name, "=", value, if (index != invocationSettings.compilerEnvironment.length - 1) " \\" else "")
      }
      l()
      l("simulationEnvironment = \\")
      for (((name, value), index) <- simulationEnvironment.zipWithIndex) {
        val sanitizedValue = value.replace(workingDirectory.toString, "$(shell pwd)")
      l("\t", name, "=", sanitizedValue, if (index != simulationEnvironment.length - 1) " \\" else "")
      }
      l()
      //format: on
    } finally {
      makefileWriter.close()
    }

    val process = os
      .proc(
        // We launch the compiler via the "debug" flow since both Verilator and VCS require that `make` is available on the target system, and this way we can validate that the debug flow works as we make changes.
        // invocationSettings.compilerPath,
        // invocationSettings.compilerArguments,
        // sourceFiles
        "make",
        "-C",
        workingDirectory.toString,
        "simulation"
      )
      .spawn(
        cwd = workingDirectory,
        // env = invocationSettings.compilerEnvironment,
        stdout = os.root / "dev" / "null",
        stderr = os.Pipe
        // stderr = os.root / "dev" / "null"
      )
    val sourceLocationRegex = "[\\./]*generated-sources/".r
    process.stderr
      .lines()
      .map(sourceLocationRegex.replaceFirstIn(_, ""))
      .foreach(System.err.println)
    process.waitFor()

    new Simulation(
      executableName = "simulation",
      settings = Simulation.Settings(
        customWorkingDirectory = customSimulationWorkingDirectory,
        arguments = invocationSettings.simulationArguments,
        environment = simulationEnvironment.toMap
      ),
      workingDirectory = workingDirectory,
      moduleInfo = moduleInfo
    )
  }

}

/** A micro-DSL for writing files.
  */
private class LineWriter(path: os.Path) {
  private val wrapped = new BufferedWriter(new FileWriter(path.toString(), false))
  def apply(components: String*) = {
    components.foreach(wrapped.write)
    wrapped.newLine()
  }
  def close() = wrapped.close()
}
