// See LICENSE for license details.

package chisel3.internal

import scala.collection.mutable.ArrayBuffer

import chisel3.core._

class ChiselException(message: String, cause: Throwable) extends Exception(message, cause)

private[chisel3] object throwException {
  def apply(s: String, t: Throwable = null): Nothing =
    throw new ChiselException(s, t)
}

/** Records and reports runtime errors and warnings. */
private[chisel3] class ErrorLog {
  def hasErrors: Boolean = errors.exists(_.isFatal)

  /** Log an error message */
  def error(m: => String): Unit =
    errors += new Error(m, getUserLineNumber)

  /** Log a warning message */
  def warning(m: => String): Unit =
    errors += new Warning(m, getUserLineNumber)

  /** Log a deprecation warning message */
  def deprecated(m: => String): Unit = {
    errors += new DeprecationWarning(m, getUserLineNumber)
  }

  /** Emit an informational message */
  def info(m: String): Unit =
    println(new Info("[%2.3f] %s".format(elapsedTime/1e3, m), None))  // scalastyle:ignore regex

  /** Prints error messages generated by Chisel at runtime. */
  def report(): Unit = errors foreach println  // scalastyle:ignore regex

  /** Throw an exception if any errors have yet occurred. */
  def checkpoint(): Unit = {
    if(hasErrors) {
      import Console._
      throwException(errors.map(_ + "\n").reduce(_ + _) +
        UNDERLINED + "CODE HAS " + errors.filter(_.isFatal).length + RESET +
        UNDERLINED + " " + RED + "ERRORS" + RESET +
        UNDERLINED + " and " + errors.filterNot(_.isFatal).length + RESET +
        UNDERLINED + " " + YELLOW + "WARNINGS" + RESET)
    } else {
      // No fatal errors. Report accumulated warnings and clear them.
      report()
      errors.clear()
    }
  }

  /** Returns the best guess at the first stack frame that belongs to user code.
    */
  private def getUserLineNumber = {
    def isChiselClassname(className: String): Boolean = {
      // List of classpath prefixes that are Chisel internals and should be ignored when looking for user code
      // utils are not part of internals and errors there can be reported
      val chiselPrefixes = Set(
          "chisel3.internal.",
          "chisel3.core.",
          "chisel3.package$"  // for some compatibility / deprecated types
          )
      !chiselPrefixes.filter(className.startsWith(_)).isEmpty
    }

    Thread.currentThread().getStackTrace.toList.dropWhile(
          // Get rid of anything before entry to Chisel, like the java.lang.Thread.getStackTrace frame
          ste => !isChiselClassname(ste.getClassName)
        ).dropWhile(
          // Get rid of everything in Chisel core
          ste => isChiselClassname(ste.getClassName)
        ).headOption
  }

  private val errors = ArrayBuffer[LogEntry]()

  private val startTime = System.currentTimeMillis
  private def elapsedTime: Long = System.currentTimeMillis - startTime
}

private abstract class LogEntry(msg: => String, line: Option[StackTraceElement]) {
  def isFatal: Boolean = false
  def format: String

  override def toString: String = line match {
    case Some(l) => s"${format} ${l.getFileName}:${l.getLineNumber}: ${msg} in class ${l.getClassName}"
    case None => s"${format} ${msg}"
  }

  protected def tag(name: String, color: String): String =
    s"[${color}${name}${Console.RESET}]"
}

private class Error(msg: => String, line: Option[StackTraceElement]) extends LogEntry(msg, line) {
  override def isFatal: Boolean = true
  def format: String = tag("error", Console.RED)
}

private class Warning(msg: => String, line: Option[StackTraceElement]) extends LogEntry(msg, line) {
  def format: String = tag("warn", Console.YELLOW)
}

private class DeprecationWarning(msg: => String, line: Option[StackTraceElement]) extends LogEntry(msg, line) {
  def format: String = tag("warn", Console.CYAN)
}

private class Info(msg: => String, line: Option[StackTraceElement]) extends LogEntry(msg, line) {
  def format: String = tag("info", Console.MAGENTA)
}
