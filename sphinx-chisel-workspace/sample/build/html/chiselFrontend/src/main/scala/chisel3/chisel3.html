
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>chiselFrontend/src/main/scala/chisel3 &#8212; chisel-test  documentation</title>
    <link rel="stylesheet" href="../../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <link rel="next" title="chiselFrontend/src/main/scala/chisel3/experimental" href="experimental/experimental.html" />
    <link rel="prev" title="chiselFrontend/src/main/scala" href="../scala.html" />
   
  <link rel="stylesheet" href="../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="chiselfrontend-src-main-scala-chisel3">
<h1>chiselFrontend/src/main/scala/chisel3<a class="headerlink" href="#chiselfrontend-src-main-scala-chisel3" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="experimental/experimental.html">chiselFrontend/src/main/scala/chisel3/experimental</a><ul>
<li class="toctree-l2"><a class="reference internal" href="experimental/experimental.html#package-scala">package.scala</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="internal/internal.html">chiselFrontend/src/main/scala/chisel3/internal</a><ul>
<li class="toctree-l2"><a class="reference internal" href="internal/firrtl/firrtl.html">chiselFrontend/src/main/scala/chisel3/internal/firrtl</a><ul>
<li class="toctree-l3"><a class="reference internal" href="internal/firrtl/firrtl.html#ir-scala">IR.scala</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="internal/internal.html#monoconnect-scala">MonoConnect.scala</a></li>
<li class="toctree-l2"><a class="reference internal" href="internal/internal.html#builder-scala">Builder.scala</a></li>
<li class="toctree-l2"><a class="reference internal" href="internal/internal.html#binding-scala">Binding.scala</a></li>
<li class="toctree-l2"><a class="reference internal" href="internal/internal.html#namer-scala">Namer.scala</a></li>
<li class="toctree-l2"><a class="reference internal" href="internal/internal.html#sourceinfo-scala">SourceInfo.scala</a></li>
<li class="toctree-l2"><a class="reference internal" href="internal/internal.html#error-scala">Error.scala</a></li>
<li class="toctree-l2"><a class="reference internal" href="internal/internal.html#biconnect-scala">BiConnect.scala</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="core/core.html">chiselFrontend/src/main/scala/chisel3/core</a><ul>
<li class="toctree-l2"><a class="reference internal" href="core/core.html#package-scala">package.scala</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="mux-scala">
<h2>Mux.scala<a class="headerlink" href="#mux-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-object Mux extends SourceInfoDoc">
<code class="descname">object Mux extends SourceInfoDoc</code><a class="headerlink" href="#attr-object Mux extends SourceInfoDoc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply[T &lt;: Data](cond: Bool, con: T, alt: T): T">
<code class="descname">def apply[T &lt;: Data](cond: Bool, con: T, alt: T): T</code><a class="headerlink" href="#attr-def apply[T <: Data](cond: Bool, con: T, alt: T): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a mux, whose output is one of the inputs depending on the       value of the condition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param cond:</th><td class="field-body">condition determining the input to choose</td>
</tr>
<tr class="field-even field"><th class="field-name">Param con:</th><td class="field-body">the value chosen when <cite>cond</cite> is true</td>
</tr>
<tr class="field-odd field"><th class="field-name">Param alt:</th><td class="field-body">the value chosen when <cite>cond</cite> is false
&#64;example</td>
</tr>
</tbody>
</table>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">muxOut</span> <span class="k">=</span> <span class="nc">Mux</span><span class="o">(</span><span class="n">data_in</span> <span class="o">===</span> <span class="mf">3.</span><span class="n">U</span><span class="o">,</span> <span class="mf">3.</span><span class="n">U</span><span class="o">(</span><span class="mf">4.</span><span class="n">W</span><span class="o">),</span> <span class="mf">0.</span><span class="n">U</span><span class="o">(</span><span class="mf">4.</span><span class="n">W</span><span class="o">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_apply[T &lt;: Data](cond: Bool, con: T, alt: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def do_apply[T &lt;: Data](cond: Bool, con: T, alt: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def do_apply[T <: Data](cond: Bool, con: T, alt: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="when-scala">
<h2>When.scala<a class="headerlink" href="#when-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-object when">
<code class="descname">object when</code><a class="headerlink" href="#attr-object when" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply(cond: =&gt; Bool)(block: =&gt; Unit)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): WhenContext =">
<code class="descname">def apply(cond: =&gt; Bool)(block: =&gt; Unit)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): WhenContext =</code><a class="headerlink" href="#attr-def apply(cond: => Bool)(block: => Unit)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): WhenContext =" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <cite>when</cite> condition block, where whether a block of logic is      executed or not depends on the conditional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param cond:</th><td class="field-body"><p class="first">condition to execute upon</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Param block:</th><td class="field-body"><p class="first">logic that runs only if <cite>cond</cite> is true</p>
<p class="last">&#64;example</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">when</span> <span class="o">(</span> <span class="n">myData</span> <span class="o">===</span> <span class="mf">3.</span><span class="n">U</span> <span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Some logic to run when myData equals 3.</span>
<span class="o">}</span> <span class="o">.</span><span class="n">elsewhen</span> <span class="o">(</span> <span class="n">myData</span> <span class="o">===</span> <span class="mf">1.</span><span class="n">U</span> <span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Some logic to run when myData equals 1.</span>
<span class="o">}</span> <span class="o">.</span><span class="n">otherwise</span> <span class="o">{</span>
  <span class="c1">// Some logic to run when myData is neither 3 nor 1.</span>
<span class="o">}</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-final class WhenContext(sourceInfo: SourceInfo, cond: Option[() =&gt; Bool], block: =&gt; Unit, firrtlDepth: Int = 0)">
<code class="descname">final class WhenContext(sourceInfo: SourceInfo, cond: Option[() =&gt; Bool], block: =&gt; Unit, firrtlDepth: Int = 0)</code><a class="headerlink" href="#attr-final class WhenContext(sourceInfo: SourceInfo, cond: Option[() => Bool], block: => Unit, firrtlDepth: Int = 0)" title="Permalink to this definition">¶</a></dt>
<dd><p>A WhenContext may represent a when, and elsewhen, or an otherwise. Since FIRRTL does not have an “elsif” statement,
alternatives must be mapped to nested if-else statements inside
the alternatives of the preceeding condition. In order to emit
proper FIRRTL, it is necessary to keep track of the depth of
nesting of the FIRRTL whens. Due to the “thin frontend” nature of
Chisel3, it is not possible to know if a when or elsewhen has a
succeeding elsewhen or otherwise; therefore, this information is
added by preprocessing the command queue.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final class WhenContext(sourceInfo: SourceInfo, cond: Option[() =&gt; Bool], block: =&gt; Unit, firrtlDepth: Int">
<code class="descname">final class WhenContext(sourceInfo: SourceInfo, cond: Option[() =&gt; Bool], block: =&gt; Unit, firrtlDepth: Int</code><a class="headerlink" href="#attr-final class WhenContext(sourceInfo: SourceInfo, cond: Option[() => Bool], block: => Unit, firrtlDepth: Int" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def elsewhen (elseCond: =&gt; Bool)(block: =&gt; Unit)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): WhenContext =">
<code class="descname">def elsewhen (elseCond: =&gt; Bool)(block: =&gt; Unit)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): WhenContext =</code><a class="headerlink" href="#attr-def elsewhen (elseCond: => Bool)(block: => Unit)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): WhenContext =" title="Permalink to this definition">¶</a></dt>
<dd><p>This block of logic gets executed if above conditions have been false and this condition is true. The lazy argument pattern
makes it possible to delay evaluation of cond, emitting the
declaration and assignment of the Bool node of the predicate in
the correct place.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def otherwise(block: =&gt; Unit)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit">
<code class="descname">def otherwise(block: =&gt; Unit)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit</code><a class="headerlink" href="#attr-def otherwise(block: => Unit)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>This block of logic gets executed only if the above conditions  were all false. No additional logic blocks may be appended past
the <cite>otherwise</cite>. The lazy argument pattern makes it possible to
delay evaluation of cond, emitting the declaration and
assignment of the Bool node of the predicate in the correct
place.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="data-scala">
<h2>Data.scala<a class="headerlink" href="#data-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-sealed abstract class SpecifiedDirection object SpecifiedDirection">
<code class="descname">sealed abstract class SpecifiedDirection object SpecifiedDirection</code><a class="headerlink" href="#attr-sealed abstract class SpecifiedDirection object SpecifiedDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>User-specified directions.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-object SpecifiedDirection">
<code class="descname">object SpecifiedDirection</code><a class="headerlink" href="#attr-object SpecifiedDirection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-case object Unspecified extends SpecifiedDirection">
<code class="descname">case object Unspecified extends SpecifiedDirection</code><a class="headerlink" href="#attr-case object Unspecified extends SpecifiedDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>Default user direction, also meaning ‘not-flipped’</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case object Output extends SpecifiedDirection">
<code class="descname">case object Output extends SpecifiedDirection</code><a class="headerlink" href="#attr-case object Output extends SpecifiedDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>Node and its children are forced as output</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case object Input extends SpecifiedDirection">
<code class="descname">case object Input extends SpecifiedDirection</code><a class="headerlink" href="#attr-case object Input extends SpecifiedDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>Node and its children are forced as inputs</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case object Flip extends SpecifiedDirection">
<code class="descname">case object Flip extends SpecifiedDirection</code><a class="headerlink" href="#attr-case object Flip extends SpecifiedDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>Mainly for containers, children are flipped.</p>
<dl class="attr">
<dt id="attr-def fromParent(parentDirection: SpecifiedDirection, thisDirection: SpecifiedDirection): SpecifiedDirection">
<code class="descname">def fromParent(parentDirection: SpecifiedDirection, thisDirection: SpecifiedDirection): SpecifiedDirection</code><a class="headerlink" href="#attr-def fromParent(parentDirection: SpecifiedDirection, thisDirection: SpecifiedDirection): SpecifiedDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the effective SpecifiedDirection of this node given the parent’s effective SpecifiedDirection   and the user-specified SpecifiedDirection of this node.</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-sealed abstract class ActualDirection">
<code class="descname">sealed abstract class ActualDirection</code><a class="headerlink" href="#attr-sealed abstract class ActualDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolved directions for both leaf and container nodes, only visible after       a node is bound (since higher-level specifications like Input and Output
can override directions).</p>
</dd></dl>

<dl class="attr">
<dt id="attr-sealed abstract class ActualDirection  object ActualDirection">
<code class="descname">sealed abstract class ActualDirection  object ActualDirection</code><a class="headerlink" href="#attr-sealed abstract class ActualDirection  object ActualDirection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-object ActualDirection">
<code class="descname">object ActualDirection</code><a class="headerlink" href="#attr-object ActualDirection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-case object Empty extends ActualDirection">
<code class="descname">case object Empty extends ActualDirection</code><a class="headerlink" href="#attr-case object Empty extends ActualDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>The object does not exist / is empty and hence has no direction</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case object Unspecified extends ActualDirection">
<code class="descname">case object Unspecified extends ActualDirection</code><a class="headerlink" href="#attr-case object Unspecified extends ActualDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>Undirectioned, struct-like</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case object Output extends ActualDirection">
<code class="descname">case object Output extends ActualDirection</code><a class="headerlink" href="#attr-case object Output extends ActualDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>Output element, or container with all outputs (even if forced)</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case object Input extends ActualDirection">
<code class="descname">case object Input extends ActualDirection</code><a class="headerlink" href="#attr-case object Input extends ActualDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>Input element, or container with all inputs (even if forced)</p>
<dl class="attr">
<dt id="attr-def fromChildren(childDirections: Set[ActualDirection], containerDirection: SpecifiedDirection): Option[ActualDirection] =">
<code class="descname">def fromChildren(childDirections: Set[ActualDirection], containerDirection: SpecifiedDirection): Option[ActualDirection] =</code><a class="headerlink" href="#attr-def fromChildren(childDirections: Set[ActualDirection], containerDirection: SpecifiedDirection): Option[ActualDirection] =" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the actual binding of a container given directions of its children.   Returns None in the case of mixed specified / unspecified directionality.</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-object DataMirror">
<code class="descname">object DataMirror</code><a class="headerlink" href="#attr-object DataMirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Experimental hardware construction reflection API</p>
</dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] object cloneSupertype">
<code class="descname">private[chisel3] object cloneSupertype</code><a class="headerlink" href="#attr-private[chisel3] object cloneSupertype" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a clone of the super-type of the input elements. Super-type is defined as:      - for Bits type of the same class: the cloned type of the largest width
- Bools are treated as UInts
- For other types of the same class are are the same: clone of any of the elements
- Otherwise: fail</p>
</dd></dl>

<dl class="attr">
<dt id="attr-object chiselTypeOf">
<code class="descname">object chiselTypeOf</code><a class="headerlink" href="#attr-object chiselTypeOf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the chisel type of a hardware object, allowing other hardware to be constructed from it.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-object Input">
<code class="descname">object Input</code><a class="headerlink" href="#attr-object Input" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Input, Output, and Flipped are used to define the directions of Module IOs.</div></blockquote>
<p>Note that they currently clone their source argument, including its bindings.</p>
<p>Thus, an error will be thrown if these are used on bound Data</p>
</dd></dl>

<dl class="attr">
<dt id="attr-object Output">
<code class="descname">object Output</code><a class="headerlink" href="#attr-object Output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-object Flipped">
<code class="descname">object Flipped</code><a class="headerlink" href="#attr-object Flipped" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc">
<code class="descname">abstract class Data extends HasId with NamedComponent with SourceInfoDoc</code><a class="headerlink" href="#attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc" title="Permalink to this definition">¶</a></dt>
<dd><p>This forms the root of the type system for wire data types. The data value      must be representable as some number (need not be known at Chisel compile
time) of bits, and must have methods to pack / unpack structured data to /
from bits.</p>
<p>&#64;groupdesc Connect Utilities for connecting hardware components
&#64;define coll data</p>
<dl class="attr">
<dt id="attr-private[chisel3] def _assignCompatibilityExplicitDirection: Unit =">
<code class="descname">private[chisel3] def _assignCompatibilityExplicitDirection: Unit =</code><a class="headerlink" href="#attr-private[chisel3] def _assignCompatibilityExplicitDirection: Unit =" title="Permalink to this definition">¶</a></dt>
<dd><p>This overwrites a relative SpecifiedDirection with an explicit one, and is used to implement    the compatibility layer where, at the elements, Flip is Input and unspecified is Output.
DO NOT USE OUTSIDE THIS PURPOSE. THIS OPERATION IS DANGEROUS!</p>
</dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] def bind(target: Binding, parentDirection: SpecifiedDirection = SpecifiedDirection.Unspecified)">
<code class="descname">private[chisel3] def bind(target: Binding, parentDirection: SpecifiedDirection = SpecifiedDirection.Unspecified)</code><a class="headerlink" href="#attr-private[chisel3] def bind(target: Binding, parentDirection: SpecifiedDirection = SpecifiedDirection.Unspecified)" title="Permalink to this definition">¶</a></dt>
<dd><p>Binds this node to the hardware graph.  parentDirection is the direction of the parent node, or Unspecified (default) if the target
node is the top-level.
binding and direction are valid after this call completes.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] def typeEquivalent(that: Data): Boolean">
<code class="descname">private[chisel3] def typeEquivalent(that: Data): Boolean</code><a class="headerlink" href="#attr-private[chisel3] def typeEquivalent(that: Data): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether this Data has the same model (“data type”) as that Data.        Data subtypes should overload this with checks against their own type.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def cloneType: this.type">
<code class="descname">def cloneType: this.type</code><a class="headerlink" href="#attr-def cloneType: this.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal API; Chisel users should look at chisel3.chiselTypeOf(…).
cloneType must be defined for any Chisel object extending Data.
It is responsible for constructing a basic copy of the object being cloned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return:</th><td class="field-body">a copy of the object.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] def cloneTypeFull: this.type =">
<code class="descname">private[chisel3] def cloneTypeFull: this.type =</code><a class="headerlink" href="#attr-private[chisel3] def cloneTypeFull: this.type =" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal API; Chisel users should look at chisel3.chiselTypeOf(…).
Returns a copy of this data type, with hardware bindings (if any) removed.
Directionality data is still preserved.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def := (that: Data)(implicit sourceInfo: SourceInfo, connectionCompileOptions: CompileOptions): Unit">
<code class="descname">final def := (that: Data)(implicit sourceInfo: SourceInfo, connectionCompileOptions: CompileOptions): Unit</code><a class="headerlink" href="#attr-final def := (that: Data)(implicit sourceInfo: SourceInfo, connectionCompileOptions: CompileOptions): Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect this $coll to that $coll mono-directionally and element-wise.
This uses the <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">MonoConnect</span></code>  algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">the $coll to connect to
&#64;group Connect</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &lt;&gt; (that: Data)(implicit sourceInfo: SourceInfo, connectionCompileOptions: CompileOptions): Unit">
<code class="descname">final def &lt;&gt; (that: Data)(implicit sourceInfo: SourceInfo, connectionCompileOptions: CompileOptions): Unit</code><a class="headerlink" href="#attr-final def <> (that: Data)(implicit sourceInfo: SourceInfo, connectionCompileOptions: CompileOptions): Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect this $coll to that $coll bi-directionally and element-wise.
This uses the <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">BiConnect</span></code>  algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">the $coll to connect to
&#64;group Connect</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def litOption(): Option[BigInt]">
<code class="descname">def litOption(): Option[BigInt]</code><a class="headerlink" href="#attr-def litOption(): Option[BigInt]" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>If this is a literal that is representable as bits, returns the value as a BigInt.</div></blockquote>
<p>If not a literal, or not representable as bits (for example, is or contains Analog), returns None.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def litValue(): BigInt">
<code class="descname">def litValue(): BigInt</code><a class="headerlink" href="#attr-def litValue(): BigInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the literal value if this is a literal that is representable as bits, otherwise crashes.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def getWidth: Int">
<code class="descname">final def getWidth: Int</code><a class="headerlink" href="#attr-final def getWidth: Int" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the width, in bits, if currently known.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def isWidthKnown: Boolean">
<code class="descname">final def isWidthKnown: Boolean</code><a class="headerlink" href="#attr-final def isWidthKnown: Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the width is currently known.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def widthOption: Option[Int]">
<code class="descname">final def widthOption: Option[Int]</code><a class="headerlink" href="#attr-final def widthOption: Option[Int]" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Some(width) if the width is known, else None.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def asTypeOf[T &lt;: Data](that: T): T">
<code class="descname">def asTypeOf[T &lt;: Data](that: T): T</code><a class="headerlink" href="#attr-def asTypeOf[T <: Data](that: T): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Does a reinterpret cast of the bits in this node into the format that provides. Returns a new Wire of that type. Does not modify existing nodes.</p>
<p>x.asTypeOf(that) performs the inverse operation of x := that.toBits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">bit widths are NOT checked, may pad or drop bits from input</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">that should have known widths</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_asTypeOf[T &lt;: Data](that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def do_asTypeOf[T &lt;: Data](that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def do_asTypeOf[T <: Data](that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] def connectFromBits(that: Bits)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit">
<code class="descname">private[chisel3] def connectFromBits(that: Bits)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit</code><a class="headerlink" href="#attr-private[chisel3] def connectFromBits(that: Bits)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns this node from Bits type. Internal implementation for asTypeOf.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def asUInt(): UInt">
<code class="descname">final def asUInt(): UInt</code><a class="headerlink" href="#attr-final def asUInt(): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Reinterpret cast to UInt.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">value not guaranteed to be preserved: for example, a SInt of width
3 and value -1 (0b111) would become an UInt with value 7</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">Aggregates are recursively packed with the first element appearing
in the least-significant bits of the result.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_asUInt(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_asUInt(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_asUInt(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def toPrintable: Printable">
<code class="descname">def toPrintable: Printable</code><a class="headerlink" href="#attr-def toPrintable: Printable" title="Permalink to this definition">¶</a></dt>
<dd><p>Default pretty printing</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-trait WireFactory">
<code class="descname">trait WireFactory</code><a class="headerlink" href="#attr-trait WireFactory" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply[T &lt;: Data](t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def apply[T &lt;: Data](t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def apply[T <: Data](t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a>  from a type template
:param t: The template from which to construct this wire</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-object Wire extends WireFactory">
<code class="descname">object Wire extends WireFactory</code><a class="headerlink" href="#attr-object Wire extends WireFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility for constructing hardware wires
The width of a <cite>Wire</cite> (inferred or not) is copied from the type template</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">w0</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="nc">UInt</span><span class="o">())</span> <span class="c1">// width is inferred</span>
<span class="k">val</span> <span class="n">w1</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">))</span> <span class="c1">// width is set to 8</span>

<span class="k">val</span> <span class="n">w2</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">UInt</span><span class="o">()))</span> <span class="c1">// width is inferred</span>
<span class="k">val</span> <span class="n">w3</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">)))</span> <span class="c1">// width of each element is set to 8</span>

<span class="k">class</span> <span class="nc">MyBundle</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">unknown</span> <span class="k">=</span> <span class="nc">UInt</span><span class="o">()</span>
  <span class="k">val</span> <span class="n">known</span>   <span class="k">=</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">w4</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyBundle</span><span class="o">)</span>
<span class="c1">// Width of w4.unknown is inferred</span>
<span class="c1">// Width of w4.known is set to 8</span>
</pre></div>
</div>
</dd></dl>

<dl class="attr">
<dt id="attr-object WireDefault">
<code class="descname">object WireDefault</code><a class="headerlink" href="#attr-object WireDefault" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility for constructing hardware wires with a default connection
The two forms of <cite>WireDefault</cite> differ in how the type and width of the resulting <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a>  are
specified.</p>
<p>==Single Argument==
The single argument form uses the argument to specify both the type and default connection. For
non-literal <a class="reference internal" href="core/core.html#attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable" title="attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bits</span></code></a> , the width of the <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a>  will be inferred. For literal <a class="reference internal" href="core/core.html#attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable" title="attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bits</span></code></a>  and all
non-Bits arguments, the type will be copied from the argument. See the following examples for
more details:</p>
<ol class="arabic simple">
<li>Literal <a class="reference internal" href="core/core.html#attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable" title="attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bits</span></code></a>  initializer: width will be set to match</li>
</ol>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">w1</span> <span class="k">=</span> <span class="nc">WireDefault</span><span class="o">(</span><span class="mf">1.</span><span class="n">U</span><span class="o">)</span> <span class="c1">// width will be inferred to be 1</span>
<span class="k">val</span> <span class="n">w2</span> <span class="k">=</span> <span class="nc">WireDefault</span><span class="o">(</span><span class="mf">1.</span><span class="n">U</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">))</span> <span class="c1">// width is set to 8</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>Non-Literal <a class="reference internal" href="core/core.html#attr-case class ElementLitBinding(litArg: LitArg) extends LitBinding" title="attr-case class ElementLitBinding(litArg: LitArg) extends LitBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Element</span></code></a>  initializer - width will be inferred</li>
</ol>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="nc">UInt</span><span class="o">())</span>
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">))</span>
<span class="k">val</span> <span class="n">w1</span> <span class="k">=</span> <span class="nc">WireDefault</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// width will be inferred</span>
<span class="k">val</span> <span class="n">w2</span> <span class="k">=</span> <span class="nc">WireDefault</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="c1">// width will be inferred</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><a class="reference internal" href="core/core.html#attr-sealed abstract class Aggregate extends Data" title="attr-sealed abstract class Aggregate extends Data"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Aggregate</span></code></a>  initializer - width will be set to match the aggregate</li>
</ol>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyBundle</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">unknown</span> <span class="k">=</span> <span class="nc">UInt</span><span class="o">()</span>
  <span class="k">val</span> <span class="n">known</span>   <span class="k">=</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">w1</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyBundle</span><span class="o">)</span>
<span class="k">val</span> <span class="n">w2</span> <span class="k">=</span> <span class="nc">WireDefault</span><span class="o">(</span><span class="n">w1</span><span class="o">)</span>
<span class="c1">// Width of w2.unknown is inferred</span>
<span class="c1">// Width of w2.known is set to 8</span>
</pre></div>
</div>
<p>==Double Argument==
The double argument form allows the type of the <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a>  and the default connection to be
specified independently.</p>
<p>The width inference semantics for <cite>WireDefault</cite> with two arguments match those of <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a> . The
first argument to <cite>WireDefault</cite> is the type template which defines the width of the <cite>Wire</cite> in
exactly the same way as the only argument to <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a> .</p>
<p>More explicitly, you can reason about <cite>WireDefault</cite> with multiple arguments as if it were defined
as:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nc">WireDefault</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Data</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">init</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="n">x</span> <span class="o">:=</span> <span class="n">init</span>
  <span class="n">x</span>
<span class="o">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">The <cite>Default</cite> in <cite>WireDefault</cite> refers to a <cite>default</cite> connection. This is in contrast to
<a class="reference internal" href="../../../../../src/test/scala/chiselTests/chiselTests.html#attr-class RegInitWidthSpec extends WireDefaultRegInitSpecImpl" title="attr-class RegInitWidthSpec extends WireDefaultRegInitSpecImpl"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">RegInit</span></code></a>  where the <cite>Init</cite> refers to a value on reset.</td>
</tr>
</tbody>
</table>
<dl class="attr">
<dt id="attr-def apply[T &lt;: Data](t: T, init: DontCare.type)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def apply[T &lt;: Data](t: T, init: DontCare.type)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def apply[T <: Data](t: T, init: DontCare.type)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a>  with a type template and a <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">chisel3.DontCare</span></code>  default
:param t: The type template used to construct this <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param init:</th><td class="field-body">The default connection to this <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a> , can only be <a class="reference internal" href="core/core.html#attr-case class DontCareBinding() extends UnconstrainedBinding  sealed trait LitBinding extends UnconstrainedBinding with ReadOnlyBinding" title="attr-case class DontCareBinding() extends UnconstrainedBinding  sealed trait LitBinding extends UnconstrainedBinding with ReadOnlyBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">DontCare</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">This is really just a specialized form of <cite>apply[T &lt;: Data](t: T, init: T): T</cite> with <a class="reference internal" href="core/core.html#attr-case class DontCareBinding() extends UnconstrainedBinding  sealed trait LitBinding extends UnconstrainedBinding with ReadOnlyBinding" title="attr-case class DontCareBinding() extends UnconstrainedBinding  sealed trait LitBinding extends UnconstrainedBinding with ReadOnlyBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">DontCare</span></code></a>  as <cite>init</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply[T &lt;: Data](t: T, init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def apply[T &lt;: Data](t: T, init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def apply[T <: Data](t: T, init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a>  with a type template and a default connection
:param t: The type template used to construct this <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param init:</th><td class="field-body">The hardware value that will serve as the default value</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply[T &lt;: Data](init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def apply[T &lt;: Data](init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def apply[T <: Data](init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a>  with a default connection
:param init: The hardware value that will serve as a type template and default value</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] object InternalDontCare extends Element">
<code class="descname">private[chisel3] object InternalDontCare extends Element</code><a class="headerlink" href="#attr-private[chisel3] object InternalDontCare extends Element" title="Permalink to this definition">¶</a></dt>
<dd><p>RHS (source) for Invalidate API.        Causes connection logic to emit a DefInvalid when connected to an output port (or wire).</p>
</dd></dl>

</div>
<div class="section" id="assert-scala">
<h2>Assert.scala<a class="headerlink" href="#assert-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-object assert">
<code class="descname">object assert</code><a class="headerlink" href="#attr-object assert" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply(cond: Bool, message: String, data: Bits*)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit">
<code class="descname">def apply(cond: Bool, message: String, data: Bits*)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit</code><a class="headerlink" href="#attr-def apply(cond: Bool, message: String, data: Bits*)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks for a condition to be valid in the circuit at all times. If the  condition evaluates to false, the circuit simulation stops with an error.</p>
<p>Does not fire when in reset (defined as the encapsulating Module’s
reset). If your definition of reset is not the encapsulating Module’s
reset, you will need to gate this externally.</p>
<p>May be called outside of a Module (like defined in a function), so
functions using assert make the standard Module assumptions (single clock
and single reset).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param cond:</th><td class="field-body">condition, assertion fires (simulation fails) when false</td>
</tr>
<tr class="field-even field"><th class="field-name">Param message:</th><td class="field-body">optional format string to print when the assertion fires</td>
</tr>
<tr class="field-odd field"><th class="field-name">Param data:</th><td class="field-body">optional bits to print in the message formatting</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">See <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">printf.apply(fmt:String*</span> <span class="pre">printf</span></code>  for format string documentation</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">currently cannot be used in core Chisel / libraries because macro
defs need to be compiled first and the SBT project is not set up to do
that</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(cond: Boolean, message: =&gt; String)">
<code class="descname">def apply(cond: Boolean, message: =&gt; String)</code><a class="headerlink" href="#attr-def apply(cond: Boolean, message: => String)" title="Permalink to this definition">¶</a></dt>
<dd><p>An elaboration-time assertion, otherwise the same as the above run-time    * assertion.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(cond: Boolean)">
<code class="descname">def apply(cond: Boolean)</code><a class="headerlink" href="#attr-def apply(cond: Boolean)" title="Permalink to this definition">¶</a></dt>
<dd><p>A workaround for default-value overloading problems in Scala, just    * ‘assert(cond, “”)’</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-object stop">
<code class="descname">object stop</code><a class="headerlink" href="#attr-object stop" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply(code: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit =">
<code class="descname">def apply(code: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit =</code><a class="headerlink" href="#attr-def apply(code: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit =" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminate execution with a failure code.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply()(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit =">
<code class="descname">def apply()(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit =</code><a class="headerlink" href="#attr-def apply()(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit =" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminate execution, indicating success.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="reg-scala">
<h2>Reg.scala<a class="headerlink" href="#reg-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-object Reg">
<code class="descname">object Reg</code><a class="headerlink" href="#attr-object Reg" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility for constructing hardware registers
The width of a <cite>Reg</cite> (inferred or not) is copied from the type template</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">r0</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">(</span><span class="nc">UInt</span><span class="o">())</span> <span class="c1">// width is inferred</span>
<span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">))</span> <span class="c1">// width is set to 8</span>

<span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">UInt</span><span class="o">()))</span> <span class="c1">// width is inferred</span>
<span class="k">val</span> <span class="n">r3</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">)))</span> <span class="c1">// width of each element is set to 8</span>

<span class="k">class</span> <span class="nc">MyBundle</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">unknown</span> <span class="k">=</span> <span class="nc">UInt</span><span class="o">()</span>
  <span class="k">val</span> <span class="n">known</span>   <span class="k">=</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">r4</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyBundle</span><span class="o">)</span>
<span class="c1">// Width of r4.unknown is inferred</span>
<span class="c1">// Width of r4.known is set to 8</span>
</pre></div>
</div>
<dl class="attr">
<dt id="attr-def apply[T &lt;: Data](t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def apply[T &lt;: Data](t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def apply[T <: Data](t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="core/core.html#attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Reg</span></code></a>  from a type template with no initialization value (reset is ignored).  Value will not change unless the <a class="reference internal" href="core/core.html#attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Reg</span></code></a>  is given a connection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param t:</th><td class="field-body">The template from which to construct this wire</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-object RegNext">
<code class="descname">object RegNext</code><a class="headerlink" href="#attr-object RegNext" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply[T &lt;: Data](next: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def apply[T &lt;: Data](next: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def apply[T <: Data](next: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a register with the specified next and no reset initialization.
Essentially a 1-cycle delayed version of the input signal.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply[T &lt;: Data](next: T, init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def apply[T &lt;: Data](next: T, init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def apply[T <: Data](next: T, init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a register with the specified next and reset initialization.
Essentially a 1-cycle delayed version of the input signal.</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-object RegInit">
<code class="descname">object RegInit</code><a class="headerlink" href="#attr-object RegInit" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility for constructing hardware registers with an initialization value.
The register is set to the initialization value when the current implicit <cite>reset</cite> is high</p>
<p>The two forms of <cite>RegInit</cite> differ in how the type and width of the resulting <a class="reference internal" href="core/core.html#attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Reg</span></code></a>  are
specified.</p>
<p>==Single Argument==
The single argument form uses the argument to specify both the type and reset value. For
non-literal <a class="reference internal" href="core/core.html#attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable" title="attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bits</span></code></a> , the width of the <a class="reference internal" href="core/core.html#attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Reg</span></code></a>  will be inferred. For literal <a class="reference internal" href="core/core.html#attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable" title="attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bits</span></code></a>  and all
non-Bits arguments, the type will be copied from the argument. See the following examples for
more details:</p>
<ol class="arabic simple">
<li>Literal <a class="reference internal" href="core/core.html#attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable" title="attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bits</span></code></a>  initializer: width will be set to match</li>
</ol>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="nc">RegInit</span><span class="o">(</span><span class="mf">1.</span><span class="n">U</span><span class="o">)</span> <span class="c1">// width will be inferred to be 1</span>
<span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="nc">RegInit</span><span class="o">(</span><span class="mf">1.</span><span class="n">U</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">))</span> <span class="c1">// width is set to 8</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>Non-Literal <a class="reference internal" href="core/core.html#attr-case class ElementLitBinding(litArg: LitArg) extends LitBinding" title="attr-case class ElementLitBinding(litArg: LitArg) extends LitBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Element</span></code></a>  initializer - width will be inferred</li>
</ol>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="nc">UInt</span><span class="o">())</span>
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">))</span>
<span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="nc">RegInit</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// width will be inferred</span>
<span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="nc">RegInit</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="c1">// width will be inferred</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><a class="reference internal" href="core/core.html#attr-sealed abstract class Aggregate extends Data" title="attr-sealed abstract class Aggregate extends Data"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Aggregate</span></code></a>  initializer - width will be set to match the aggregate</li>
</ol>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyBundle</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">unknown</span> <span class="k">=</span> <span class="nc">UInt</span><span class="o">()</span>
  <span class="k">val</span> <span class="n">known</span>   <span class="k">=</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">w1</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyBundle</span><span class="o">)</span>
<span class="k">val</span> <span class="n">w2</span> <span class="k">=</span> <span class="nc">RegInit</span><span class="o">(</span><span class="n">w1</span><span class="o">)</span>
<span class="c1">// Width of w2.unknown is inferred</span>
<span class="c1">// Width of w2.known is set to 8</span>
</pre></div>
</div>
<p>==Double Argument==
The double argument form allows the type of the <a class="reference internal" href="core/core.html#attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Reg</span></code></a>  and the default connection to be
specified independently.</p>
<p>The width inference semantics for <cite>RegInit</cite> with two arguments match those of <a class="reference internal" href="core/core.html#attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Reg</span></code></a> . The
first argument to <cite>RegInit</cite> is the type template which defines the width of the <cite>Reg</cite> in
exactly the same way as the only argument to <a class="reference internal" href="core/core.html#attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding case class WireBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Wire</span></code></a> .</p>
<p>More explicitly, you can reason about <cite>RegInit</cite> with multiple arguments as if it were defined
as:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nc">RegInit</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Data</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">init</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="n">x</span> <span class="o">:=</span> <span class="n">init</span>
  <span class="n">x</span>
<span class="o">}</span>
</pre></div>
</div>
<dl class="attr">
<dt id="attr-def apply[T &lt;: Data](t: T, init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def apply[T &lt;: Data](t: T, init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def apply[T <: Data](t: T, init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="core/core.html#attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Reg</span></code></a>  from a type template initialized to the specified value on reset
:param t: The type template used to construct this <a class="reference internal" href="core/core.html#attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Reg</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param init:</th><td class="field-body">The value the <a class="reference internal" href="core/core.html#attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Reg</span></code></a>  is initialized to on reset</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply[T &lt;: Data](init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def apply[T &lt;: Data](init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def apply[T <: Data](init: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="core/core.html#attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Reg</span></code></a>  initialized on reset to the specified value.
:param init: Initial value that serves as a type template and reset value</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="compileoptions-scala">
<h2>CompileOptions.scala<a class="headerlink" href="#compileoptions-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-trait CompileOptions">
<code class="descname">trait CompileOptions</code><a class="headerlink" href="#attr-trait CompileOptions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-object CompileOptions">
<code class="descname">object CompileOptions</code><a class="headerlink" href="#attr-object CompileOptions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-object ExplicitCompileOptions">
<code class="descname">object ExplicitCompileOptions</code><a class="headerlink" href="#attr-object ExplicitCompileOptions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="aggregate-scala">
<h2>Aggregate.scala<a class="headerlink" href="#aggregate-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-class AliasedAggregateFieldException(message: String) extends ChiselException(message)">
<code class="descname">class AliasedAggregateFieldException(message: String) extends ChiselException(message)</code><a class="headerlink" href="#attr-class AliasedAggregateFieldException(message: String) extends ChiselException(message)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-sealed abstract class Aggregate extends Data">
<code class="descname">sealed abstract class Aggregate extends Data</code><a class="headerlink" href="#attr-sealed abstract class Aggregate extends Data" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for data types that solely consist of (are an aggregate       of) other Data objects.</p>
<dl class="attr">
<dt id="attr-def getElements: Seq[Data]">
<code class="descname">def getElements: Seq[Data]</code><a class="headerlink" href="#attr-def getElements: Seq[Data]" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Seq of the immediate contents of this Aggregate, in order.</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-trait VecFactory extends SourceInfoDoc">
<code class="descname">trait VecFactory extends SourceInfoDoc</code><a class="headerlink" href="#attr-trait VecFactory extends SourceInfoDoc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply[T &lt;: Data](n: Int, gen: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Vec[T] =">
<code class="descname">def apply[T &lt;: Data](n: Int, gen: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Vec[T] =</code><a class="headerlink" href="#attr-def apply[T <: Data](n: Int, gen: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Vec[T] =" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new <a class="reference internal" href="core/core.html#attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]" title="attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Vec</span></code></a>  with <cite>n</cite> entries of the specified data type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">elements are NOT assigned by default and have no value</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] def truncateIndex(idx: UInt, n: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =">
<code class="descname">private[chisel3] def truncateIndex(idx: UInt, n: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =</code><a class="headerlink" href="#attr-private[chisel3] def truncateIndex(idx: UInt, n: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>Truncate an index to implement modulo-power-of-2 addressing.</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-sealed class Vec[T &lt;: Data] private[chisel3] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]">
<code class="descname">sealed class Vec[T &lt;: Data] private[chisel3] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]</code><a class="headerlink" href="#attr-sealed class Vec[T <: Data] private[chisel3] (gen: => T, val length: Int) extends Aggregate with VecLike[T]" title="Permalink to this definition">¶</a></dt>
<dd><p>A vector (array) of <a class="reference internal" href="core/core.html#attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc" title="attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Data</span></code></a>  elements. Provides hardware versions of various       collection transformation functions found in software array implementations.</p>
<p>Careful consideration should be given over the use of <a class="reference internal" href="core/core.html#attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]" title="attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Vec</span></code></a>  vs
<code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">scala.collection.immutable.Seq</span> <span class="pre">Seq</span></code>  or some other Scala collection. In general <a class="reference internal" href="core/core.html#attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]" title="attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Vec</span></code></a>  only
needs to be used when there is a need to express the hardware collection in a <a class="reference internal" href="core/core.html#attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding" title="attr-case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding case class RegBinding(enclosure: RawModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Reg</span></code></a>  or IO
<a class="reference internal" href="core/core.html#attr-case class BundleLitBinding(litMap: Map[Data, LitArg]) extends LitBinding" title="attr-case class BundleLitBinding(litMap: Map[Data, LitArg]) extends LitBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bundle</span></code></a>  or when access to elements of the array is indexed via a hardware signal.</p>
<p>Example of indexing into a <a class="reference internal" href="core/core.html#attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]" title="attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Vec</span></code></a>  using a hardware address and where the <a class="reference internal" href="core/core.html#attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]" title="attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Vec</span></code></a>  is defined in
an IO <a class="reference internal" href="core/core.html#attr-case class BundleLitBinding(litMap: Map[Data, LitArg]) extends LitBinding" title="attr-case class BundleLitBinding(litMap: Map[Data, LitArg]) extends LitBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bundle</span></code></a></p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">io</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">Bundle</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Input</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="mi">20</span><span class="o">,</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">16.</span><span class="n">W</span><span class="o">)))</span>
  <span class="k">val</span> <span class="n">addr</span> <span class="k">=</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">5.</span><span class="n">W</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Output</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">16.</span><span class="n">W</span><span class="o">))</span>
<span class="o">})</span>
<span class="n">io</span><span class="o">.</span><span class="n">out</span> <span class="o">:=</span> <span class="n">io</span><span class="o">.</span><span class="n">in</span><span class="o">(</span><span class="n">io</span><span class="o">.</span><span class="n">addr</span><span class="o">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type-param T:</th><td class="field-body"><p class="first">type of elements</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><ul class="first last simple">
<li>when multiple conflicting assignments are performed on a Vec element, the last one takes effect (unlike Mem, where the result is undefined)</li>
<li>Vecs, unlike classes in Scala’s collection library, are propagated intact to FIRRTL as a vector type, which may make debugging easier</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attr">
<dt id="attr-def &lt;&gt; (that: Seq[T])(implicit sourceInfo: SourceInfo, moduleCompileOptions: CompileOptions): Unit =">
<code class="descname">def &lt;&gt; (that: Seq[T])(implicit sourceInfo: SourceInfo, moduleCompileOptions: CompileOptions): Unit =</code><a class="headerlink" href="#attr-def <> (that: Seq[T])(implicit sourceInfo: SourceInfo, moduleCompileOptions: CompileOptions): Unit =" title="Permalink to this definition">¶</a></dt>
<dd><p>Strong bulk connect, assigning elements in this Vec from elements in a Seq.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">the length of this Vec must match the length of the input Seq</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def := (that: Seq[T])(implicit sourceInfo: SourceInfo, moduleCompileOptions: CompileOptions): Unit =">
<code class="descname">def := (that: Seq[T])(implicit sourceInfo: SourceInfo, moduleCompileOptions: CompileOptions): Unit =</code><a class="headerlink" href="#attr-def := (that: Seq[T])(implicit sourceInfo: SourceInfo, moduleCompileOptions: CompileOptions): Unit =" title="Permalink to this definition">¶</a></dt>
<dd><p>Strong bulk connect, assigning elements in this Vec from elements in a Seq.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">the length of this Vec must match the length of the input Seq</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-override def apply(p: UInt): T">
<code class="descname">override def apply(p: UInt): T</code><a class="headerlink" href="#attr-override def apply(p: UInt): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dynamically indexed read or write accessor into the array.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_apply(p: UInt)(implicit compileOptions: CompileOptions): T =">
<code class="descname">def do_apply(p: UInt)(implicit compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def do_apply(p: UInt)(implicit compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(idx: Int): T">
<code class="descname">def apply(idx: Int): T</code><a class="headerlink" href="#attr-def apply(idx: Int): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a statically indexed read or write accessor into the array.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def toPrintable: Printable =">
<code class="descname">def toPrintable: Printable =</code><a class="headerlink" href="#attr-def toPrintable: Printable =" title="Permalink to this definition">¶</a></dt>
<dd><p>Default “pretty-print” implementation   Analogous to printing a Seq
Results in “Vec(elt0, elt1, …)”</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-object VecInit extends SourceInfoDoc">
<code class="descname">object VecInit extends SourceInfoDoc</code><a class="headerlink" href="#attr-object VecInit extends SourceInfoDoc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply[T &lt;: Data](elts: Seq[T]): Vec[T]">
<code class="descname">def apply[T &lt;: Data](elts: Seq[T]): Vec[T]</code><a class="headerlink" href="#attr-def apply[T <: Data](elts: Seq[T]): Vec[T]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new <a class="reference internal" href="core/core.html#attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]" title="attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Vec</span></code></a>  composed of elements of the input Seq of <a class="reference internal" href="core/core.html#attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc" title="attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Data</span></code></a>        nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">input elements should be of the same type (this is checked at the
FIRRTL level, but not at the Scala / Chisel level)</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">the width of all output elements is the width of the largest input
element</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">output elements are connected from the input elements</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_apply[T &lt;: Data](elts: Seq[T])(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Vec[T] =">
<code class="descname">def do_apply[T &lt;: Data](elts: Seq[T])(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Vec[T] =</code><a class="headerlink" href="#attr-def do_apply[T <: Data](elts: Seq[T])(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Vec[T] =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply[T &lt;: Data](elt0: T, elts: T*): Vec[T]">
<code class="descname">def apply[T &lt;: Data](elt0: T, elts: T*): Vec[T]</code><a class="headerlink" href="#attr-def apply[T <: Data](elt0: T, elts: T*): Vec[T]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new <a class="reference internal" href="core/core.html#attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]" title="attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Vec</span></code></a>  composed of the input <a class="reference internal" href="core/core.html#attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc" title="attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Data</span></code></a>  nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">input elements should be of the same type (this is checked at the
FIRRTL level, but not at the Scala / Chisel level)</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">the width of all output elements is the width of the largest input
element</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">output elements are connected from the input elements</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_apply[T &lt;: Data](elt0: T, elts: T*)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Vec[T]">
<code class="descname">def do_apply[T &lt;: Data](elt0: T, elts: T*)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Vec[T]</code><a class="headerlink" href="#attr-def do_apply[T <: Data](elt0: T, elts: T*)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Vec[T]" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def tabulate[T &lt;: Data](n: Int)(gen: (Int) =&gt; T): Vec[T]">
<code class="descname">def tabulate[T &lt;: Data](n: Int)(gen: (Int) =&gt; T): Vec[T]</code><a class="headerlink" href="#attr-def tabulate[T <: Data](n: Int)(gen: (Int) => T): Vec[T]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new <a class="reference internal" href="core/core.html#attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]" title="attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Vec</span></code></a>  of length <cite>n</cite> composed of the results of the given   function applied over a range of integer values starting from 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param n:</th><td class="field-body">number of elements in the vector (the function is applied from
0 to <cite>n-1</cite>)</td>
</tr>
<tr class="field-even field"><th class="field-name">Param gen:</th><td class="field-body">function that takes in an Int (the index) and returns a
<a class="reference internal" href="core/core.html#attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc" title="attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Data</span></code></a>  that becomes the output element</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_tabulate[T &lt;: Data](n: Int)(gen: (Int) =&gt; T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Vec[T]">
<code class="descname">def do_tabulate[T &lt;: Data](n: Int)(gen: (Int) =&gt; T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Vec[T]</code><a class="headerlink" href="#attr-def do_tabulate[T <: Data](n: Int)(gen: (Int) => T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Vec[T]" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-trait VecLike[T &lt;: Data] extends collection.IndexedSeq[T] with HasId with SourceInfoDoc">
<code class="descname">trait VecLike[T &lt;: Data] extends collection.IndexedSeq[T] with HasId with SourceInfoDoc</code><a class="headerlink" href="#attr-trait VecLike[T <: Data] extends collection.IndexedSeq[T] with HasId with SourceInfoDoc" title="Permalink to this definition">¶</a></dt>
<dd><p>A trait for <a class="reference internal" href="core/core.html#attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]" title="attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Vec</span></code></a> s containing common hardware generators for collection  operations.</p>
<dl class="attr">
<dt id="attr-def do_apply(p: UInt)(implicit compileOptions: CompileOptions): T">
<code class="descname">def do_apply(p: UInt)(implicit compileOptions: CompileOptions): T</code><a class="headerlink" href="#attr-def do_apply(p: UInt)(implicit compileOptions: CompileOptions): T" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def forall(p: T =&gt; Bool): Bool">
<code class="descname">def forall(p: T =&gt; Bool): Bool</code><a class="headerlink" href="#attr-def forall(p: T => Bool): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs true if p outputs true for every element.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_forall(p: T =&gt; Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_forall(p: T =&gt; Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_forall(p: T => Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def exists(p: T =&gt; Bool): Bool">
<code class="descname">def exists(p: T =&gt; Bool): Bool</code><a class="headerlink" href="#attr-def exists(p: T => Bool): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs true if p outputs true for at least one element.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_exists(p: T =&gt; Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_exists(p: T =&gt; Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_exists(p: T => Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def contains(x: T)(implicit ev: T &lt;:&lt; UInt): Bool">
<code class="descname">def contains(x: T)(implicit ev: T &lt;:&lt; UInt): Bool</code><a class="headerlink" href="#attr-def contains(x: T)(implicit ev: T <:< UInt): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs true if the vector contains at least one element equal to x (using      the === operator).</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_contains(x: T)(implicit sourceInfo: SourceInfo, ev: T &lt;:&lt; UInt, compileOptions: CompileOptions): Bool">
<code class="descname">def do_contains(x: T)(implicit sourceInfo: SourceInfo, ev: T &lt;:&lt; UInt, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_contains(x: T)(implicit sourceInfo: SourceInfo, ev: T <:< UInt, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def count(p: T =&gt; Bool): UInt">
<code class="descname">def count(p: T =&gt; Bool): UInt</code><a class="headerlink" href="#attr-def count(p: T => Bool): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the number of elements for which p is true.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_count(p: T =&gt; Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_count(p: T =&gt; Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_count(p: T => Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-private def indexWhereHelper(p: T =&gt; Bool)">
<code class="descname">private def indexWhereHelper(p: T =&gt; Bool)</code><a class="headerlink" href="#attr-private def indexWhereHelper(p: T => Bool)" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function that appends an index (literal value) to each element,  useful for hardware generators which output an index.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def indexWhere(p: T =&gt; Bool): UInt">
<code class="descname">def indexWhere(p: T =&gt; Bool): UInt</code><a class="headerlink" href="#attr-def indexWhere(p: T => Bool): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the index of the first element for which p outputs true.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_indexWhere(p: T =&gt; Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_indexWhere(p: T =&gt; Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_indexWhere(p: T => Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def lastIndexWhere(p: T =&gt; Bool): UInt">
<code class="descname">def lastIndexWhere(p: T =&gt; Bool): UInt</code><a class="headerlink" href="#attr-def lastIndexWhere(p: T => Bool): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the index of the last element for which p outputs true.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_lastIndexWhere(p: T =&gt; Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_lastIndexWhere(p: T =&gt; Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_lastIndexWhere(p: T => Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def onlyIndexWhere(p: T =&gt; Bool): UInt">
<code class="descname">def onlyIndexWhere(p: T =&gt; Bool): UInt</code><a class="headerlink" href="#attr-def onlyIndexWhere(p: T => Bool): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the index of the element for which p outputs true, assuming that        the there is exactly one such element.</p>
<p>The implementation may be more efficient than a priority mux, but
incorrect results are possible if there is not exactly one true element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">the assumption that there is only one element for which p outputs
true is NOT checked (useful in cases where the condition doesn’t always
hold, but the results are not used in those cases)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_onlyIndexWhere(p: T =&gt; Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_onlyIndexWhere(p: T =&gt; Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_onlyIndexWhere(p: T => Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-abstract class Record(private[chisel3] implicit val compileOptions: CompileOptions) extends Aggregate">
<code class="descname">abstract class Record(private[chisel3] implicit val compileOptions: CompileOptions) extends Aggregate</code><a class="headerlink" href="#attr-abstract class Record(private[chisel3] implicit val compileOptions: CompileOptions) extends Aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for Aggregates based on key values pairs of String and Data
Record should only be extended by libraries and fairly sophisticated generators.
RTL writers should use <a class="reference internal" href="core/core.html#attr-case class BundleLitBinding(litMap: Map[Data, LitArg]) extends LitBinding" title="attr-case class BundleLitBinding(litMap: Map[Data, LitArg]) extends LitBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bundle</span></code></a> .  See <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Record#elements</span></code>  for an example.</p>
<dl class="attr">
<dt id="attr-private[chisel3] def _makeLit(elems: (this.type =&gt; (Data, Data))*): this.type =">
<code class="descname">private[chisel3] def _makeLit(elems: (this.type =&gt; (Data, Data))*): this.type =</code><a class="headerlink" href="#attr-private[chisel3] def _makeLit(elems: (this.type => (Data, Data))*): this.type =" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a Bundle literal of this type with specified values. this must be a chisel type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param elems:</th><td class="field-body">literal values, specified as a pair of the Bundle field to the literal value.
The Bundle field is specified as a function from an object of this type to the field.
Fields that aren’t initialized to DontCare, and assignment to a wire will overwrite any
existing value with DontCare.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a Bundle literal of this type with subelement values specified</td>
</tr>
</tbody>
</table>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyBundle</span> <span class="k">extends</span> <span class="nc">Bundle</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">8.</span><span class="n">W</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="nc">Bool</span><span class="o">()</span>
<span class="o">}</span>

<span class="o">(</span><span class="n">mew</span> <span class="nc">MyBundle</span><span class="o">).</span><span class="nc">Lit</span><span class="o">(</span>
  <span class="k">_</span><span class="o">.</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="mf">42.</span><span class="n">U</span><span class="o">,</span>
  <span class="k">_</span><span class="o">.</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kc">true</span><span class="o">.</span><span class="n">B</span>
<span class="o">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attr">
<dt id="attr-override def toString: String =">
<code class="descname">override def toString: String =</code><a class="headerlink" href="#attr-override def toString: String =" title="Permalink to this definition">¶</a></dt>
<dd><p>The collection of <a class="reference internal" href="core/core.html#attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc" title="attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Data</span></code></a>
This underlying datastructure is a ListMap because the elements must
remain ordered for serialization/deserialization. Elements added later
are higher order when serialized (this is similar to <a class="reference internal" href="core/core.html#attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]" title="attr-sealed class Vec[T &lt;: Data] private[core] (gen: =&gt; T, val length: Int) extends Aggregate with VecLike[T]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Vec</span></code></a> ). For example:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assume we have some type MyRecord that creates a Record from the ListMap</span>
<span class="k">val</span> <span class="n">record</span> <span class="k">=</span> <span class="nc">MyRecord</span><span class="o">(</span><span class="nc">ListMap</span><span class="o">(</span><span class="s">&quot;fizz&quot;</span> <span class="o">-&gt;</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">16.</span><span class="n">W</span><span class="o">),</span> <span class="s">&quot;buzz&quot;</span> <span class="o">-&gt;</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">16.</span><span class="n">W</span><span class="o">)))</span>
<span class="c1">// &quot;buzz&quot; is higher order because it was added later than &quot;fizz&quot;</span>
<span class="n">record</span><span class="o">(</span><span class="s">&quot;fizz&quot;</span><span class="o">)</span> <span class="o">:=</span> <span class="s">&quot;hdead&quot;</span><span class="o">.</span><span class="n">U</span>
<span class="n">record</span><span class="o">(</span><span class="s">&quot;buzz&quot;</span><span class="o">)</span> <span class="o">:=</span> <span class="s">&quot;hbeef&quot;</span><span class="o">.</span><span class="n">U</span>
<span class="k">val</span> <span class="n">uint</span> <span class="k">=</span> <span class="n">record</span><span class="o">.</span><span class="n">asUInt</span>
<span class="n">assert</span><span class="o">(</span><span class="n">uint</span> <span class="o">===</span> <span class="s">&quot;hbeefdead&quot;</span><span class="o">.</span><span class="n">U</span><span class="o">)</span> <span class="c1">// This will pass</span>
</pre></div>
</div>
</dd></dl>

<dl class="attr">
<dt id="attr-def className: String">
<code class="descname">def className: String</code><a class="headerlink" href="#attr-def className: String" title="Permalink to this definition">¶</a></dt>
<dd><p>Name for Pretty Printing</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def toPrintable: Printable">
<code class="descname">def toPrintable: Printable</code><a class="headerlink" href="#attr-def toPrintable: Printable" title="Permalink to this definition">¶</a></dt>
<dd><p>Default “pretty-print” implementation   Analogous to printing a Map
Results in “<cite>$className(elt0.name -&gt; elt0.value, …)</cite>”</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-trait IgnoreSeqInBundle">
<code class="descname">trait IgnoreSeqInBundle</code><a class="headerlink" href="#attr-trait IgnoreSeqInBundle" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Mix-in for Bundles that have arbitrary Seqs of Chisel types that aren’t</div></blockquote>
<p>involved in hardware construction.</p>
<p>Used to avoid raising an error/exception when a Seq is a public member of the
bundle.
This is useful if we those public Seq fields in the Bundle are unrelated to
hardware construction.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-class AutoClonetypeException(message: String) extends ChiselException(message)  package experimental">
<code class="descname">class AutoClonetypeException(message: String) extends ChiselException(message)  package experimental</code><a class="headerlink" href="#attr-class AutoClonetypeException(message: String) extends ChiselException(message)  package experimental" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-abstract class Bundle(implicit compileOptions: CompileOptions) extends Record">
<code class="descname">abstract class Bundle(implicit compileOptions: CompileOptions) extends Record</code><a class="headerlink" href="#attr-abstract class Bundle(implicit compileOptions: CompileOptions) extends Record" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for data types defined as a bundle of other data types.
Usage: extend this class (either as an anonymous or named class) and define
members variables of <a class="reference internal" href="core/core.html#attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc" title="attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Data</span></code></a>  subtypes to be elements in the Bundle.</p>
<p>Example of an anonymous IO bundle</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModule</span> <span class="k">extends</span> <span class="nc">Module</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">io</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">Bundle</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Input</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">64.</span><span class="n">W</span><span class="o">))</span>
    <span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Output</span><span class="o">(</span><span class="nc">SInt</span><span class="o">(</span><span class="mf">128.</span><span class="n">W</span><span class="o">))</span>
  <span class="o">})</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Or as a named class</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Packet</span> <span class="k">extends</span> <span class="nc">Bundle</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">header</span> <span class="k">=</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">16.</span><span class="n">W</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">addr</span>   <span class="k">=</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">16.</span><span class="n">W</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">data</span>   <span class="k">=</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">32.</span><span class="n">W</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">MyModule</span> <span class="k">extends</span> <span class="nc">Module</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">io</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">Bundle</span> <span class="o">{</span>
     <span class="k">val</span> <span class="n">inPacket</span> <span class="k">=</span> <span class="nc">Input</span><span class="o">(</span><span class="k">new</span> <span class="nc">Packet</span><span class="o">)</span>
     <span class="k">val</span> <span class="n">outPacket</span> <span class="k">=</span> <span class="nc">Output</span><span class="o">(</span><span class="k">new</span> <span class="nc">Packet</span><span class="o">)</span>
   <span class="o">})</span>
   <span class="k">val</span> <span class="n">reg</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">(</span><span class="k">new</span> <span class="nc">Packet</span><span class="o">)</span>
   <span class="n">reg</span> <span class="o">&lt;&gt;</span> <span class="n">inPacket</span>
   <span class="n">outPacket</span> <span class="o">&lt;&gt;</span> <span class="n">reg</span>
<span class="o">}</span>
</pre></div>
</div>
<dl class="attr">
<dt id="attr-def ignoreSeq: Boolean">
<code class="descname">def ignoreSeq: Boolean</code><a class="headerlink" href="#attr-def ignoreSeq: Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden by <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">IgnoreSeqInBundle</span></code>  to allow arbitrary Seqs of Chisel elements.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-private def getBundleField(m: java.lang.reflect.Method): Option[Data]">
<code class="descname">private def getBundleField(m: java.lang.reflect.Method): Option[Data]</code><a class="headerlink" href="#attr-private def getBundleField(m: java.lang.reflect.Method): Option[Data]" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a field’s contained user-defined Bundle element if it appears to        be one, otherwise returns None.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-override def toPrintable: Printable">
<code class="descname">override def toPrintable: Printable</code><a class="headerlink" href="#attr-override def toPrintable: Printable" title="Permalink to this definition">¶</a></dt>
<dd><p>Default “pretty-print” implementation   Analogous to printing a Map
Results in “<cite>Bundle(elt0.name -&gt; elt0.value, …)</cite>”</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">The order is reversed from the order of elements in order to print
the fields in the order they were defined</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="multiclock-scala">
<h2>MultiClock.scala<a class="headerlink" href="#multiclock-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-object withClockAndReset">
<code class="descname">object withClockAndReset</code><a class="headerlink" href="#attr-object withClockAndReset" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply[T](clock: Clock, reset: Reset)(block: =&gt; T): T =">
<code class="descname">def apply[T](clock: Clock, reset: Reset)(block: =&gt; T): T =</code><a class="headerlink" href="#attr-def apply[T](clock: Clock, reset: Reset)(block: => T): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new Clock and Reset scope</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param clock:</th><td class="field-body">the new implicit Clock</td>
</tr>
<tr class="field-even field"><th class="field-name">Param reset:</th><td class="field-body">the new implicit Reset</td>
</tr>
<tr class="field-odd field"><th class="field-name">Param block:</th><td class="field-body">the block of code to run with new implicit Clock and Reset</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the result of the block</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-object withClock">
<code class="descname">object withClock</code><a class="headerlink" href="#attr-object withClock" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply[T](clock: Clock)(block: =&gt; T): T =">
<code class="descname">def apply[T](clock: Clock)(block: =&gt; T): T =</code><a class="headerlink" href="#attr-def apply[T](clock: Clock)(block: => T): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new Clock scope</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param clock:</th><td class="field-body">the new implicit Clock</td>
</tr>
<tr class="field-even field"><th class="field-name">Param block:</th><td class="field-body">the block of code to run with new implicit Clock</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return:</th><td class="field-body">the result of the block</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-object withReset">
<code class="descname">object withReset</code><a class="headerlink" href="#attr-object withReset" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply[T](reset: Reset)(block: =&gt; T): T =">
<code class="descname">def apply[T](reset: Reset)(block: =&gt; T): T =</code><a class="headerlink" href="#attr-def apply[T](reset: Reset)(block: => T): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new Reset scope</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param reset:</th><td class="field-body">the new implicit Reset</td>
</tr>
<tr class="field-even field"><th class="field-name">Param block:</th><td class="field-body">the block of code to run with new implicit Reset</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return:</th><td class="field-body">the result of the block</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="annotation-scala">
<h2>Annotation.scala<a class="headerlink" href="#annotation-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-trait ChiselAnnotation">
<code class="descname">trait ChiselAnnotation</code><a class="headerlink" href="#attr-trait ChiselAnnotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface for Annotations in Chisel
Defines a conversion to a corresponding FIRRTL Annotation</p>
<dl class="attr">
<dt id="attr-def toFirrtl: Annotation">
<code class="descname">def toFirrtl: Annotation</code><a class="headerlink" href="#attr-def toFirrtl: Annotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion to FIRRTL Annotation</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-trait RunFirrtlTransform extends ChiselAnnotation">
<code class="descname">trait RunFirrtlTransform extends ChiselAnnotation</code><a class="headerlink" href="#attr-trait RunFirrtlTransform extends ChiselAnnotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Mixin for <a class="reference internal" href="../../../../../src/test/scala/chiselTests/stage/stage.html#attr-class ChiselAnnotationsSpecFoo extends RawModule" title="attr-class ChiselAnnotationsSpecFoo extends RawModule"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">ChiselAnnotation</span></code></a>  that instantiates an associated FIRRTL Transform when this Annotation is present    during a run of
<code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Driver$.execute(args:Array[String],dut:()=&gt;chisel3.experimental.RawModule)*</span> <span class="pre">Driver.execute</span></code> .
Automatic Transform instantiation is <em>not</em> supported when the Circuit and Annotations are serialized before invoking
FIRRTL.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final case class ChiselLegacyAnnotation private[chisel3] (component: InstanceId, transformClass: Class[_ &lt;: Transform], value: String) extends ChiselAnnotation with RunFirrtlTransform">
<code class="descname">final case class ChiselLegacyAnnotation private[chisel3] (component: InstanceId, transformClass: Class[_ &lt;: Transform], value: String) extends ChiselAnnotation with RunFirrtlTransform</code><a class="headerlink" href="#attr-final case class ChiselLegacyAnnotation private[chisel3] (component: InstanceId, transformClass: Class[_ <: Transform], value: String) extends ChiselAnnotation with RunFirrtlTransform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] object ChiselLegacyAnnotation  object annotate">
<code class="descname">private[chisel3] object ChiselLegacyAnnotation  object annotate</code><a class="headerlink" href="#attr-private[chisel3] object ChiselLegacyAnnotation  object annotate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-object annotate">
<code class="descname">object annotate</code><a class="headerlink" href="#attr-object annotate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-object dontTouch">
<code class="descname">object dontTouch</code><a class="headerlink" href="#attr-object dontTouch" title="Permalink to this definition">¶</a></dt>
<dd><p>Marks that a signal should not be removed by Chisel and Firrtl optimization passes</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModule</span> <span class="k">extends</span> <span class="nc">Module</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">io</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">Bundle</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="nc">Input</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">32.</span><span class="n">W</span><span class="o">))</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="nc">Output</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">32.</span><span class="n">W</span><span class="o">))</span>
  <span class="o">})</span>
  <span class="n">io</span><span class="o">.</span><span class="n">b</span> <span class="o">:=</span> <span class="n">io</span><span class="o">.</span><span class="n">a</span>
  <span class="k">val</span> <span class="n">dead</span> <span class="k">=</span> <span class="n">io</span><span class="o">.</span><span class="n">a</span> <span class="o">+%</span> <span class="mf">1.</span><span class="n">U</span> <span class="c1">// normally dead would be pruned by DCE</span>
  <span class="n">dontTouch</span><span class="o">(</span><span class="n">dead</span><span class="o">)</span> <span class="c1">// Marking it as such will preserve it</span>
<span class="o">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">Calling this on <a class="reference internal" href="core/core.html#attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc" title="attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Data</span></code></a>  creates an annotation that Chisel emits to a separate annotations
file. This file must be passed to FIRRTL independently of the <cite>.fir</cite> file. The execute methods
in <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">chisel3.Driver</span></code>  will pass the annotations to FIRRTL automatically.</td>
</tr>
</tbody>
</table>
<dl class="attr">
<dt id="attr-def apply[T &lt;: Data](data: T)(implicit compileOptions: CompileOptions): T =">
<code class="descname">def apply[T &lt;: Data](data: T)(implicit compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def apply[T <: Data](data: T)(implicit compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Marks a signal to be preserved in Chisel and Firrtl</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">Requires the argument to be bound to hardware</td>
</tr>
<tr class="field-even field"><th class="field-name">Param data:</th><td class="field-body">The signal to be marked</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return:</th><td class="field-body">Unmodified signal <cite>data</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-object doNotDedup">
<code class="descname">object doNotDedup</code><a class="headerlink" href="#attr-object doNotDedup" title="Permalink to this definition">¶</a></dt>
<dd><p>Marks that a module to be ignored in Dedup Transform in Firrtl pass</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">fullAdder</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">UInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">UInt</span><span class="o">,</span> <span class="n">myName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">UInt</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="nc">Module</span><span class="o">(</span><span class="k">new</span> <span class="nc">Module</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">io</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">Bundle</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="nc">Input</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">32.</span><span class="n">W</span><span class="o">))</span>
        <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="nc">Input</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">32.</span><span class="n">W</span><span class="o">))</span>
        <span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Output</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">32.</span><span class="n">W</span><span class="o">))</span>
      <span class="o">})</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">desiredName</span> <span class="k">=</span> <span class="s">&quot;adder_&quot;</span> <span class="o">+</span> <span class="n">myNname</span>
      <span class="n">io</span><span class="o">.</span><span class="n">out</span> <span class="o">:=</span> <span class="n">io</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">io</span><span class="o">.</span><span class="n">b</span>
    <span class="o">})</span>
    <span class="n">doNotDedup</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
    <span class="n">m</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">a</span> <span class="o">:=</span> <span class="n">a</span>
    <span class="n">m</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>
    <span class="n">m</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">out</span>
  <span class="o">}</span>

<span class="k">class</span> <span class="nc">AdderTester</span> <span class="k">extends</span> <span class="nc">Module</span>
  <span class="k">with</span> <span class="nc">ConstantPropagationTest</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">io</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">Bundle</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="nc">Input</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">32.</span><span class="n">W</span><span class="o">))</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="nc">Input</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">32.</span><span class="n">W</span><span class="o">))</span>
    <span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Output</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">UInt</span><span class="o">(</span><span class="mf">32.</span><span class="n">W</span><span class="o">)))</span>
  <span class="o">})</span>

  <span class="n">io</span><span class="o">.</span><span class="n">out</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fullAdder</span><span class="o">(</span><span class="n">io</span><span class="o">.</span><span class="n">a</span><span class="o">,</span> <span class="n">io</span><span class="o">.</span><span class="n">b</span><span class="o">,</span> <span class="s">&quot;mod1&quot;</span><span class="o">)</span>
  <span class="n">io</span><span class="o">.</span><span class="n">out</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fullAdder</span><span class="o">(</span><span class="n">io</span><span class="o">.</span><span class="n">a</span><span class="o">,</span> <span class="n">io</span><span class="o">.</span><span class="n">b</span><span class="o">,</span> <span class="s">&quot;mod2&quot;</span><span class="o">)</span>
 <span class="o">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">Calling this on <a class="reference internal" href="core/core.html#attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc" title="attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Data</span></code></a>  creates an annotation that Chisel emits to a separate annotations
file. This file must be passed to FIRRTL independently of the <cite>.fir</cite> file. The execute methods
in <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">chisel3.Driver</span></code>  will pass the annotations to FIRRTL automatically.</td>
</tr>
</tbody>
</table>
<dl class="attr">
<dt id="attr-def apply[T &lt;: LegacyModule](module: T)(implicit compileOptions: CompileOptions): Unit =">
<code class="descname">def apply[T &lt;: LegacyModule](module: T)(implicit compileOptions: CompileOptions): Unit =</code><a class="headerlink" href="#attr-def apply[T <: LegacyModule](module: T)(implicit compileOptions: CompileOptions): Unit =" title="Permalink to this definition">¶</a></dt>
<dd><p>Marks a module to be ignored in Dedup Transform in Firrtl</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param data:</th><td class="field-body">The module to be marked</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">Unmodified signal <cite>module</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="rawmodule-scala">
<h2>RawModule.scala<a class="headerlink" href="#rawmodule-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-abstract class RawModule(implicit moduleCompileOptions: CompileOptions) extends BaseModule">
<code class="descname">abstract class RawModule(implicit moduleCompileOptions: CompileOptions) extends BaseModule</code><a class="headerlink" href="#attr-abstract class RawModule(implicit moduleCompileOptions: CompileOptions) extends BaseModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for Modules that contain Chisel RTL.        This abstract base class is a user-defined module which does not include implicit clock and reset and supports
multiple IO() declarations.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-abstract class MultiIOModule(implicit moduleCompileOptions: CompileOptions) extends RawModule">
<code class="descname">abstract class MultiIOModule(implicit moduleCompileOptions: CompileOptions) extends RawModule</code><a class="headerlink" href="#attr-abstract class MultiIOModule(implicit moduleCompileOptions: CompileOptions) extends RawModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for Modules, which behave much like Verilog modules.        These may contain both logic and state which are written in the Module
body (constructor).
This abstract base class includes an implicit clock and reset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">Module instantiations must be wrapped in a Module() call.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-abstract class LegacyModule(implicit moduleCompileOptions: CompileOptions) extends MultiIOModule">
<code class="descname">abstract class LegacyModule(implicit moduleCompileOptions: CompileOptions) extends MultiIOModule</code><a class="headerlink" href="#attr-abstract class LegacyModule(implicit moduleCompileOptions: CompileOptions) extends MultiIOModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Legacy Module class that restricts IOs to just io, clock, and reset, and provides a constructor for threading through explicit clock and reset.</p>
<p>While this class isn’t planned to be removed anytime soon (there are benefits to restricting
IO), the clock and reset constructors will be phased out. Recommendation is to wrap the module
in a withClock/withReset/withClockAndReset block, or directly hook up clock or reset IO pins.</p>
</dd></dl>

</div>
<div class="section" id="attach-scala">
<h2>Attach.scala<a class="headerlink" href="#attach-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-object attach">
<code class="descname">object attach</code><a class="headerlink" href="#attr-object attach" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply(elts: Analog*)(implicit sourceInfo: SourceInfo): Unit =">
<code class="descname">def apply(elts: Analog*)(implicit sourceInfo: SourceInfo): Unit =</code><a class="headerlink" href="#attr-def apply(elts: Analog*)(implicit sourceInfo: SourceInfo): Unit =" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an electrical connection between <a class="reference internal" href="core/core.html#attr-final class Analog private (private[chisel3] val width: Width) extends Element" title="attr-final class Analog private (private[chisel3] val width: Width) extends Element"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Analog</span></code></a>  components</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param elts:</th><td class="field-body"><p class="first">The components to attach</p>
<p class="last">&#64;example</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a1</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="nc">Analog</span><span class="o">(</span><span class="mf">32.</span><span class="n">W</span><span class="o">))</span>
<span class="k">val</span> <span class="n">a2</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="nc">Analog</span><span class="o">(</span><span class="mf">32.</span><span class="n">W</span><span class="o">))</span>
<span class="n">attach</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sequtils-scala">
<h2>SeqUtils.scala<a class="headerlink" href="#sequtils-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-private[chisel3] object SeqUtils">
<code class="descname">private[chisel3] object SeqUtils</code><a class="headerlink" href="#attr-private[chisel3] object SeqUtils" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def asUInt[T &lt;: Bits](in: Seq[T]): UInt">
<code class="descname">def asUInt[T &lt;: Bits](in: Seq[T]): UInt</code><a class="headerlink" href="#attr-def asUInt[T <: Bits](in: Seq[T]): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates the data elements of the input sequence, in sequence order, together.      The first element of the sequence forms the least significant bits, while the last element
in the sequence forms the most significant bits.</p>
<p>Equivalent to r(n-1) ## … ## r(1) ## r(0).</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_asUInt[T &lt;: Bits](in: Seq[T])(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =">
<code class="descname">def do_asUInt[T &lt;: Bits](in: Seq[T])(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =</code><a class="headerlink" href="#attr-def do_asUInt[T <: Bits](in: Seq[T])(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacros</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def count(in: Seq[Bool]): UInt">
<code class="descname">def count(in: Seq[Bool]): UInt</code><a class="headerlink" href="#attr-def count(in: Seq[Bool]): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the number of elements that === true.B.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_count(in: Seq[Bool])(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_count(in: Seq[Bool])(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_count(in: Seq[Bool])(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacros</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def priorityMux[T &lt;: Data](in: Seq[(Bool, T)]): T">
<code class="descname">def priorityMux[T &lt;: Data](in: Seq[(Bool, T)]): T</code><a class="headerlink" href="#attr-def priorityMux[T <: Data](in: Seq[(Bool, T)]): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data value corresponding to the first true predicate.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_priorityMux[T &lt;: Data](in: Seq[(Bool, T)]) (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def do_priorityMux[T &lt;: Data](in: Seq[(Bool, T)]) (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def do_priorityMux[T <: Data](in: Seq[(Bool, T)]) (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacros</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def oneHotMux[T &lt;: Data](in: Iterable[(Bool, T)]): T">
<code class="descname">def oneHotMux[T &lt;: Data](in: Iterable[(Bool, T)]): T</code><a class="headerlink" href="#attr-def oneHotMux[T <: Data](in: Iterable[(Bool, T)]): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data value corresponding to the lone true predicate.        This is elaborated to firrtl using a structure that should be optimized into and and/or tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">assumes exactly one true predicate, results undefined otherwise
FixedPoint values or aggregates containing FixedPoint values cause this optimized structure to be lost</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_oneHotMux[T &lt;: Data](in: Iterable[(Bool, T)]) (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def do_oneHotMux[T &lt;: Data](in: Iterable[(Bool, T)]) (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def do_oneHotMux[T <: Data](in: Iterable[(Bool, T)]) (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacros</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="package-scala">
<h2>package.scala<a class="headerlink" href="#package-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-package object chisel3">
<code class="descname">package object chisel3</code><a class="headerlink" href="#attr-package object chisel3" title="Permalink to this definition">¶</a></dt>
<dd><p>This package contains the main chisel3 API.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-implicit class fromBigIntToLiteral(bigint: BigInt)">
<code class="descname">implicit class fromBigIntToLiteral(bigint: BigInt)</code><a class="headerlink" href="#attr-implicit class fromBigIntToLiteral(bigint: BigInt)" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>These implicit classes allow one to convert scala.Int|scala.BigInt to</div></blockquote>
<p>Chisel.UInt|Chisel.SInt by calling .asUInt|.asSInt on them, respectively.
The versions .asUInt(width)|.asSInt(width) are also available to explicitly
mark a width for the new literal.</p>
<p>Also provides .asBool to scala.Boolean and .asUInt to String</p>
<p>Note that, for stylistic reasons, one should avoid extracting immediately
after this call using apply, ie. 0.asUInt(1)(0) due to potential for
confusion (the 1 is a bit length and the 0 is a bit extraction position).
Prefer storing the result and then extracting from it.</p>
<p>Implementation note: the empty parameter list (like <cite>U()</cite>) is necessary to prevent
interpreting calls that have a non-Width parameter as a chained apply, otherwise things like
<cite>0.asUInt(16)</cite> (instead of <cite>16.W</cite>) compile without error and produce undesired results.</p>
<dl class="attr">
<dt id="attr-def B: Bool">
<code class="descname">def B: Bool</code><a class="headerlink" href="#attr-def B: Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Int to Bool conversion, allowing compact syntax like 1.B and 0.B</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def U: UInt">
<code class="descname">def U: UInt</code><a class="headerlink" href="#attr-def U: UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Int to UInt conversion, recommended style for constants.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def S: SInt">
<code class="descname">def S: SInt</code><a class="headerlink" href="#attr-def S: SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Int to SInt conversion, recommended style for constants.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def U(width: Width): UInt">
<code class="descname">def U(width: Width): UInt</code><a class="headerlink" href="#attr-def U(width: Width): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Int to UInt conversion with specified width, recommended style for constants.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def S(width: Width): SInt">
<code class="descname">def S(width: Width): SInt</code><a class="headerlink" href="#attr-def S(width: Width): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Int to SInt conversion with specified width, recommended style for constants.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def asUInt(): UInt">
<code class="descname">def asUInt(): UInt</code><a class="headerlink" href="#attr-def asUInt(): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Int to UInt conversion, recommended style for variables.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def asSInt(): SInt">
<code class="descname">def asSInt(): SInt</code><a class="headerlink" href="#attr-def asSInt(): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Int to SInt conversion, recommended style for variables.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def asUInt(width: Width): UInt">
<code class="descname">def asUInt(width: Width): UInt</code><a class="headerlink" href="#attr-def asUInt(width: Width): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Int to UInt conversion with specified width, recommended style for variables.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def asSInt(width: Width): SInt">
<code class="descname">def asSInt(width: Width): SInt</code><a class="headerlink" href="#attr-def asSInt(width: Width): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Int to SInt conversion with specified width, recommended style for variables.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def U: UInt">
<code class="descname">def U: UInt</code><a class="headerlink" href="#attr-def U: UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>String to UInt parse, recommended style for constants.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def U(width: Width): UInt">
<code class="descname">def U(width: Width): UInt</code><a class="headerlink" href="#attr-def U(width: Width): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>String to UInt parse with specified width, recommended style for constants.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def asUInt(): UInt =">
<code class="descname">def asUInt(): UInt =</code><a class="headerlink" href="#attr-def asUInt(): UInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>String to UInt parse, recommended style for variables.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def asUInt(width: Width): UInt">
<code class="descname">def asUInt(width: Width): UInt</code><a class="headerlink" href="#attr-def asUInt(width: Width): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>String to UInt parse with specified width, recommended style for variables.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def B: Bool">
<code class="descname">def B: Bool</code><a class="headerlink" href="#attr-def B: Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean to Bool conversion, recommended style for constants.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def asBool(): Bool">
<code class="descname">def asBool(): Bool</code><a class="headerlink" href="#attr-def asBool(): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean to Bool conversion, recommended style for variables.</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-implicit class PrintableHelper(val sc: StringContext) extends AnyVal">
<code class="descname">implicit class PrintableHelper(val sc: StringContext) extends AnyVal</code><a class="headerlink" href="#attr-implicit class PrintableHelper(val sc: StringContext) extends AnyVal" title="Permalink to this definition">¶</a></dt>
<dd><p>Implicit for custom Printable string interpolator</p>
<dl class="attr">
<dt id="attr-def p(args: Any*): Printable =">
<code class="descname">def p(args: Any*): Printable =</code><a class="headerlink" href="#attr-def p(args: Any*): Printable =" title="Permalink to this definition">¶</a></dt>
<dd><p>Custom string interpolator for generating Printables: p”…”    Will call .toString on any non-Printable arguments (mimicking s”…”)</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-case class ExpectedChiselTypeException(message: String) extends BindingException(message)">
<code class="descname">case class ExpectedChiselTypeException(message: String) extends BindingException(message)</code><a class="headerlink" href="#attr-case class ExpectedChiselTypeException(message: String) extends BindingException(message)" title="Permalink to this definition">¶</a></dt>
<dd><p>A function expected a Chisel type but got a hardware object</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case class ExpectedHardwareException(message: String) extends BindingException(message)">
<code class="descname">case class ExpectedHardwareException(message: String) extends BindingException(message)</code><a class="headerlink" href="#attr-case class ExpectedHardwareException(message: String) extends BindingException(message)" title="Permalink to this definition">¶</a></dt>
<dd><p>A function expected a hardware object but got a Chisel type</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case class MixedDirectionAggregateException(message: String) extends BindingException(message)">
<code class="descname">case class MixedDirectionAggregateException(message: String) extends BindingException(message)</code><a class="headerlink" href="#attr-case class MixedDirectionAggregateException(message: String) extends BindingException(message)" title="Permalink to this definition">¶</a></dt>
<dd><p>An aggregate had a mix of specified and unspecified directionality children</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case class RebindingException(message: String) extends BindingException(message)">
<code class="descname">case class RebindingException(message: String) extends BindingException(message)</code><a class="headerlink" href="#attr-case class RebindingException(message: String) extends BindingException(message)" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempted to re-bind an already bound (directionality or hardware) object</p>
</dd></dl>

</div>
<div class="section" id="strongenum-scala">
<h2>StrongEnum.scala<a class="headerlink" href="#strongenum-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-object EnumAnnotations">
<code class="descname">object EnumAnnotations</code><a class="headerlink" href="#attr-object EnumAnnotations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-case class EnumComponentAnnotation(target: Named, enumTypeName: String) extends SingleTargetAnnotation[Named]">
<code class="descname">case class EnumComponentAnnotation(target: Named, enumTypeName: String) extends SingleTargetAnnotation[Named]</code><a class="headerlink" href="#attr-case class EnumComponentAnnotation(target: Named, enumTypeName: String) extends SingleTargetAnnotation[Named]" title="Permalink to this definition">¶</a></dt>
<dd><p>An annotation for strong enum instances that are ‘’not’’ inside of Vecs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param target:</th><td class="field-body">the enum instance being annotated</td>
</tr>
<tr class="field-even field"><th class="field-name">Param typeName:</th><td class="field-body">the name of the enum’s type (e.g. ‘‘“mypackage.MyEnum”’’)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-case class EnumVecAnnotation(target: Named, typeName: String, fields: Seq[Seq[String]]) extends SingleTargetAnnotation[Named]">
<code class="descname">case class EnumVecAnnotation(target: Named, typeName: String, fields: Seq[Seq[String]]) extends SingleTargetAnnotation[Named]</code><a class="headerlink" href="#attr-case class EnumVecAnnotation(target: Named, typeName: String, fields: Seq[Seq[String]]) extends SingleTargetAnnotation[Named]" title="Permalink to this definition">¶</a></dt>
<dd><p>An annotation for Vecs of strong enums.
The ‘’fields’’ parameter deserves special attention, since it may be difficult to understand. Suppose you create a the following Vec:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">VecInit</span><span class="o">(</span><span class="k">new</span> <span class="nc">Bundle</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">e</span> <span class="k">=</span> <span class="nc">MyEnum</span><span class="o">()</span>
  <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Bundle</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">inner_e</span> <span class="k">=</span> <span class="nc">MyEnum</span><span class="o">()</span>
  <span class="o">}</span>
  <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">MyEnum</span><span class="o">())</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Then, the ‘’fields’’ parameter will be: ‘’Seq(Seq(“e”), Seq(“b”, “inner_e”), Seq(“v”))’’. Note that for any Vec that doesn’t contain Bundles, this field will simply be an empty Seq.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param target:</th><td class="field-body">the Vec being annotated</td>
</tr>
<tr class="field-even field"><th class="field-name">Param typeName:</th><td class="field-body">the name of the enum’s type (e.g. ‘‘“mypackage.MyEnum”’’)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Param fields:</th><td class="field-body">a list of all chains of elements leading from the Vec instance to its inner enum fields.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-case class EnumDefAnnotation(typeName: String, definition: Map[String, BigInt]) extends NoTargetAnnotation">
<code class="descname">case class EnumDefAnnotation(typeName: String, definition: Map[String, BigInt]) extends NoTargetAnnotation</code><a class="headerlink" href="#attr-case class EnumDefAnnotation(typeName: String, definition: Map[String, BigInt]) extends NoTargetAnnotation" title="Permalink to this definition">¶</a></dt>
<dd><p>An annotation for enum types (rather than enum ‘’instances’’).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param typeName:</th><td class="field-body">the name of the enum’s type (e.g. ‘‘“mypackage.MyEnum”’’)</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Param definition:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">a map describing which integer values correspond to which enum names</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-abstract class EnumType(private val factory: EnumFactory, selfAnnotating: Boolean">
<code class="descname">abstract class EnumType(private val factory: EnumFactory, selfAnnotating: Boolean</code><a class="headerlink" href="#attr-abstract class EnumType(private val factory: EnumFactory, selfAnnotating: Boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-abstract class EnumFactory">
<code class="descname">abstract class EnumFactory</code><a class="headerlink" href="#attr-abstract class EnumFactory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] object EnumMacros">
<code class="descname">private[chisel3] object EnumMacros</code><a class="headerlink" href="#attr-private[chisel3] object EnumMacros" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] class UnsafeEnum(override val width: Width) extends EnumType(UnsafeEnum, selfAnnotating">
<code class="descname">private[chisel3] class UnsafeEnum(override val width: Width) extends EnumType(UnsafeEnum, selfAnnotating</code><a class="headerlink" href="#attr-private[chisel3] class UnsafeEnum(override val width: Width) extends EnumType(UnsafeEnum, selfAnnotating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-private object UnsafeEnum extends EnumFactory">
<code class="descname">private object UnsafeEnum extends EnumFactory</code><a class="headerlink" href="#attr-private object UnsafeEnum extends EnumFactory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="printf-scala">
<h2>Printf.scala<a class="headerlink" href="#printf-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-object printf">
<code class="descname">object printf</code><a class="headerlink" href="#attr-object printf" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a message in simulation
See apply methods for use</p>
<dl class="attr">
<dt id="attr-private[chisel3] def format(formatIn: String): String =">
<code class="descname">private[chisel3] def format(formatIn: String): String =</code><a class="headerlink" href="#attr-private[chisel3] def format(formatIn: String): String =" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for packing escape characters</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(fmt: String, data: Bits*)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit">
<code class="descname">def apply(fmt: String, data: Bits*)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit</code><a class="headerlink" href="#attr-def apply(fmt: String, data: Bits*)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a message in simulation
Prints a message every cycle. If defined within the scope of a <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">when</span></code>  block, the message
will only be printed on cycles that the when condition is true.</p>
<p>Does not fire when in reset (defined as the encapsulating Module’s reset). If your definition
of reset is not the encapsulating Module’s reset, you will need to gate this externally.</p>
<p>May be called outside of a Module (like defined in a function), uses the current default clock
and reset. These can be overriden with <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">withClockAndReset</span></code> .</p>
<p>==Format Strings==</p>
<p>This method expects a ‘’format string’’ and an ‘’argument list’’ in a similar style to printf
in C. The format string expects a <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">scala.Predef.String</span> <span class="pre">String</span></code>  that may contain ‘’format
specifiers’’ For example:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">printf</span><span class="o">(</span><span class="s">&quot;myWire has the value %d\n&quot;</span><span class="o">,</span> <span class="n">myWire</span><span class="o">)</span>
</pre></div>
</div>
<p>This prints the string “myWire has the value ” followed by the current value of <cite>myWire</cite> (in
decimal, followed by a newline.</p>
<p>There must be exactly as many arguments as there are format specifiers</p>
<p>===Format Specifiers===</p>
<p>Format specifiers are prefixed by <cite>%</cite>. If you wish to print a literal <cite>%</cite>, use <cite>%%</cite>.
- <cite>%d</cite> - Decimal
- <cite>%x</cite> - Hexadecimal
- <cite>%b</cite> - Binary
- <cite>%c</cite> - 8-bit Character
- <cite>%n</cite> - Name of a signal
- <cite>%N</cite> - Full name of a leaf signal (in an aggregate)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param fmt:</th><td class="field-body">printf format string</td>
</tr>
<tr class="field-even field"><th class="field-name">Param data:</th><td class="field-body">format string varargs containing data to print</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(pable: Printable)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit =">
<code class="descname">def apply(pable: Printable)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit =</code><a class="headerlink" href="#attr-def apply(pable: Printable)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Unit =" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a message in simulation
Prints a message every cycle. If defined within the scope of a <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">when</span></code>  block, the message
will only be printed on cycles that the when condition is true.</p>
<p>Does not fire when in reset (defined as the encapsulating Module’s reset). If your definition
of reset is not the encapsulating Module’s reset, you will need to gate this externally.</p>
<p>May be called outside of a Module (like defined in a function), uses the current default clock
and reset. These can be overriden with <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">withClockAndReset</span></code> .</p>
<p>&#64;see <a class="reference internal" href="core/core.html#attr-sealed abstract class Printable" title="attr-sealed abstract class Printable"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Printable</span></code></a>  documentation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param pable:</th><td class="field-body"><a class="reference internal" href="core/core.html#attr-sealed abstract class Printable" title="attr-sealed abstract class Printable"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Printable</span></code></a>  to print</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mem-scala">
<h2>Mem.scala<a class="headerlink" href="#mem-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-object Mem">
<code class="descname">object Mem</code><a class="headerlink" href="#attr-object Mem" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply[T &lt;: Data](size: BigInt, t: T): Mem[T]">
<code class="descname">def apply[T &lt;: Data](size: BigInt, t: T): Mem[T]</code><a class="headerlink" href="#attr-def apply[T <: Data](size: BigInt, t: T): Mem[T]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a combinational/asynchronous-read, sequential/synchronous-write <a class="reference internal" href="core/core.html#attr-case class OpBinding(enclosure: RawModule) extends ConstrainedBinding with ReadOnlyBinding case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding" title="attr-case class OpBinding(enclosure: RawModule) extends ConstrainedBinding with ReadOnlyBinding case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Mem</span></code></a> .</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param size:</th><td class="field-body">number of elements in the memory</td>
</tr>
<tr class="field-even field"><th class="field-name">Param t:</th><td class="field-body">data type of memory element</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply[T &lt;: Data](size: Int, t: T): Mem[T]">
<code class="descname">def apply[T &lt;: Data](size: Int, t: T): Mem[T]</code><a class="headerlink" href="#attr-def apply[T <: Data](size: Int, t: T): Mem[T]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a combinational/asynchronous-read, sequential/synchronous-write <a class="reference internal" href="core/core.html#attr-case class OpBinding(enclosure: RawModule) extends ConstrainedBinding with ReadOnlyBinding case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding" title="attr-case class OpBinding(enclosure: RawModule) extends ConstrainedBinding with ReadOnlyBinding case class MemoryPortBinding(enclosure: RawModule) extends ConstrainedBinding case class PortBinding(enclosure: BaseModule) extends ConstrainedBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Mem</span></code></a> .</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param size:</th><td class="field-body">number of elements in the memory</td>
</tr>
<tr class="field-even field"><th class="field-name">Param t:</th><td class="field-body">data type of memory element</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_apply[T &lt;: Data](size: BigInt, t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Mem[T] =">
<code class="descname">def do_apply[T &lt;: Data](size: BigInt, t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Mem[T] =</code><a class="headerlink" href="#attr-def do_apply[T <: Data](size: BigInt, t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Mem[T] =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_apply[T &lt;: Data](size: Int, t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Mem[T]">
<code class="descname">def do_apply[T &lt;: Data](size: Int, t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Mem[T]</code><a class="headerlink" href="#attr-def do_apply[T <: Data](size: Int, t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Mem[T]" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-sealed abstract class MemBase[T &lt;: Data](t: T, val length: BigInt) extends HasId with NamedComponent with SourceInfoDoc">
<code class="descname">sealed abstract class MemBase[T &lt;: Data](t: T, val length: BigInt) extends HasId with NamedComponent with SourceInfoDoc</code><a class="headerlink" href="#attr-sealed abstract class MemBase[T <: Data](t: T, val length: BigInt) extends HasId with NamedComponent with SourceInfoDoc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply(x: BigInt): T">
<code class="descname">def apply(x: BigInt): T</code><a class="headerlink" href="#attr-def apply(x: BigInt): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a read accessor into the memory with static addressing. See the class documentation of the memory for more detailed information.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(x: Int): T">
<code class="descname">def apply(x: Int): T</code><a class="headerlink" href="#attr-def apply(x: Int): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a read accessor into the memory with static addressing. See the class documentation of the memory for more detailed information.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_apply(idx: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def do_apply(idx: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def do_apply(idx: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_apply(idx: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T">
<code class="descname">def do_apply(idx: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T</code><a class="headerlink" href="#attr-def do_apply(idx: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(x: UInt): T">
<code class="descname">def apply(x: UInt): T</code><a class="headerlink" href="#attr-def apply(x: UInt): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a read/write accessor into the memory with dynamic addressing.  See the class documentation of the memory for more detailed information.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_apply(idx: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T">
<code class="descname">def do_apply(idx: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T</code><a class="headerlink" href="#attr-def do_apply(idx: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def read(x: UInt): T">
<code class="descname">def read(x: UInt): T</code><a class="headerlink" href="#attr-def read(x: UInt): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a read accessor into the memory with dynamic addressing. See the        class documentation of the memory for more detailed information.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_read(idx: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T">
<code class="descname">def do_read(idx: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T</code><a class="headerlink" href="#attr-def do_read(idx: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def write(idx: UInt, data: T)(implicit compileOptions: CompileOptions): Unit =">
<code class="descname">def write(idx: UInt, data: T)(implicit compileOptions: CompileOptions): Unit =</code><a class="headerlink" href="#attr-def write(idx: UInt, data: T)(implicit compileOptions: CompileOptions): Unit =" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a write accessor into the memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param idx:</th><td class="field-body">memory element index to write into</td>
</tr>
<tr class="field-even field"><th class="field-name">Param data:</th><td class="field-body">new data to write</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def write(idx: UInt, data: T, mask: Seq[Bool]) (implicit evidence: T &lt;:&lt; Vec[_], compileOptions: CompileOptions): Unit =">
<code class="descname">def write(idx: UInt, data: T, mask: Seq[Bool]) (implicit evidence: T &lt;:&lt; Vec[_], compileOptions: CompileOptions): Unit =</code><a class="headerlink" href="#attr-def write(idx: UInt, data: T, mask: Seq[Bool]) (implicit evidence: T <:< Vec[_], compileOptions: CompileOptions): Unit =" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a masked write accessor into the memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param idx:</th><td class="field-body">memory element index to write into</td>
</tr>
<tr class="field-even field"><th class="field-name">Param data:</th><td class="field-body">new data to write</td>
</tr>
<tr class="field-odd field"><th class="field-name">Param mask:</th><td class="field-body">write mask as a Seq of Bool: a write to the Vec element in
memory is only performed if the corresponding mask index is true.</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">this is only allowed if the memory’s element data type is a Vec</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-sealed class Mem[T &lt;: Data] private (t: T, length: BigInt) extends MemBase(t, length)">
<code class="descname">sealed class Mem[T &lt;: Data] private (t: T, length: BigInt) extends MemBase(t, length)</code><a class="headerlink" href="#attr-sealed class Mem[T <: Data] private (t: T, length: BigInt) extends MemBase(t, length)" title="Permalink to this definition">¶</a></dt>
<dd><p>A combinational/asynchronous-read, sequential/synchronous-write memory.
Writes take effect on the rising clock edge after the request. Reads are
combinational (requests will return data on the same cycle).
Read-after-write hazards are not an issue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">when multiple conflicting writes are performed on a Mem element, the
result is undefined (unlike Vec, where the last assignment wins)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-sealed class Mem[T &lt;: Data] private (t: T, length: BigInt) extends MemBase(t, length)  object SyncReadMem">
<code class="descname">sealed class Mem[T &lt;: Data] private (t: T, length: BigInt) extends MemBase(t, length)  object SyncReadMem</code><a class="headerlink" href="#attr-sealed class Mem[T <: Data] private (t: T, length: BigInt) extends MemBase(t, length)  object SyncReadMem" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-object SyncReadMem">
<code class="descname">object SyncReadMem</code><a class="headerlink" href="#attr-object SyncReadMem" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply[T &lt;: Data](size: BigInt, t: T): SyncReadMem[T]">
<code class="descname">def apply[T &lt;: Data](size: BigInt, t: T): SyncReadMem[T]</code><a class="headerlink" href="#attr-def apply[T <: Data](size: BigInt, t: T): SyncReadMem[T]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a sequential/synchronous-read, sequential/synchronous-write <a class="reference internal" href="core/core.html#attr-sealed class SyncReadMem[T &lt;: Data] private (t: T, n: BigInt) extends MemBase[T](t, n)" title="attr-sealed class SyncReadMem[T &lt;: Data] private (t: T, n: BigInt) extends MemBase[T](t, n)"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">SyncReadMem</span></code></a> .</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param size:</th><td class="field-body">number of elements in the memory</td>
</tr>
<tr class="field-even field"><th class="field-name">Param t:</th><td class="field-body">data type of memory element</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply[T &lt;: Data](size: Int, t: T): SyncReadMem[T]">
<code class="descname">def apply[T &lt;: Data](size: Int, t: T): SyncReadMem[T]</code><a class="headerlink" href="#attr-def apply[T <: Data](size: Int, t: T): SyncReadMem[T]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a sequential/synchronous-read, sequential/synchronous-write <a class="reference internal" href="core/core.html#attr-sealed class SyncReadMem[T &lt;: Data] private (t: T, n: BigInt) extends MemBase[T](t, n)" title="attr-sealed class SyncReadMem[T &lt;: Data] private (t: T, n: BigInt) extends MemBase[T](t, n)"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">SyncReadMem</span></code></a> .</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param size:</th><td class="field-body">number of elements in the memory</td>
</tr>
<tr class="field-even field"><th class="field-name">Param t:</th><td class="field-body">data type of memory element</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_apply[T &lt;: Data](size: BigInt, t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SyncReadMem[T] =">
<code class="descname">def do_apply[T &lt;: Data](size: BigInt, t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SyncReadMem[T] =</code><a class="headerlink" href="#attr-def do_apply[T <: Data](size: BigInt, t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SyncReadMem[T] =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_apply[T &lt;: Data](size: Int, t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SyncReadMem[T]">
<code class="descname">def do_apply[T &lt;: Data](size: Int, t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SyncReadMem[T]</code><a class="headerlink" href="#attr-def do_apply[T <: Data](size: Int, t: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SyncReadMem[T]" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-sealed class SyncReadMem[T &lt;: Data] private (t: T, n: BigInt) extends MemBase[T](t, n)">
<code class="descname">sealed class SyncReadMem[T &lt;: Data] private (t: T, n: BigInt) extends MemBase[T](t, n)</code><a class="headerlink" href="#attr-sealed class SyncReadMem[T <: Data] private (t: T, n: BigInt) extends MemBase[T](t, n)" title="Permalink to this definition">¶</a></dt>
<dd><p>A sequential/synchronous-read, sequential/synchronous-write memory.
Writes take effect on the rising clock edge after the request. Reads return
data on the rising edge after the request. Read-after-write behavior (when
a read and write to the same address are requested on the same cycle) is
undefined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">when multiple conflicting writes are performed on a Mem element, the
result is undefined (unlike Vec, where the last assignment wins)</td>
</tr>
</tbody>
</table>
<dl class="attr">
<dt id="attr-def do_read(addr: UInt, enable: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def do_read(addr: UInt, enable: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def do_read(addr: UInt, enable: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="bits-scala">
<h2>Bits.scala<a class="headerlink" href="#bits-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-abstract class Element extends Data">
<code class="descname">abstract class Element extends Data</code><a class="headerlink" href="#attr-abstract class Element extends Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Element is a leaf data type: it cannot contain other <a class="reference internal" href="core/core.html#attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc" title="attr-abstract class Data extends HasId with NamedComponent with SourceInfoDoc"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Data</span></code></a>  objects. Example uses are for representing primitive data types, like integers and bits.</p>
<p>&#64;define coll element</p>
</dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] sealed trait ToBoolable extends Element">
<code class="descname">private[chisel3] sealed trait ToBoolable extends Element</code><a class="headerlink" href="#attr-private[chisel3] sealed trait ToBoolable extends Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Exists to unify common interfaces of <a class="reference internal" href="core/core.html#attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable" title="attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bits</span></code></a>  and <a class="reference internal" href="../../../../../src/test/scala/chiselTests/chiselTests.html#attr-class ResetAsTypeOfBoolTester extends BasicTester" title="attr-class ResetAsTypeOfBoolTester extends BasicTester"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Reset</span></code></a> .</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">This is a workaround because macros cannot override abstract methods.</td>
</tr>
</tbody>
</table>
<dl class="attr">
<dt id="attr-final def asBool(): Bool">
<code class="descname">final def asBool(): Bool</code><a class="headerlink" href="#attr-final def asBool(): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Casts this $coll to a <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">The width must be known and equal to 1</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_asBool(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_asBool(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_asBool(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def toBool(): Bool">
<code class="descname">final def toBool(): Bool</code><a class="headerlink" href="#attr-final def toBool(): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Casts this $coll to a <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">The width must be known and equal to 1</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_toBool(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_toBool(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_toBool(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable">
<code class="descname">sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable</code><a class="headerlink" href="#attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable" title="Permalink to this definition">¶</a></dt>
<dd><p>A data type for values represented by a single bitvector. This provides basic bitwise operations.
&#64;groupdesc Bitwise Bitwise hardware operators
&#64;define coll <a class="reference internal" href="core/core.html#attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable" title="attr-sealed abstract class Bits(private[chisel3] val width: Width) extends Element with ToBoolable"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bits</span></code></a></p>
<p>&#64;define sumWidthInt    :note: The width of the returned $coll is <cite>width of this</cite> + <cite>that</cite>.</p>
<p>&#64;define sumWidth       :note: The width of the returned $coll is <cite>width of this</cite> + <cite>width of that</cite>.</p>
<p>&#64;define unchangedWidth :note: The width of the returned $coll is unchanged, i.e., the <cite>width of this</cite>.</p>
<dl class="attr">
<dt id="attr-final def tail(n: Int): UInt">
<code class="descname">final def tail(n: Int): UInt</code><a class="headerlink" href="#attr-final def tail(n: Int): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Tail operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param n:</th><td class="field-body">the number of bits to remove</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">This $coll with the <cite>n</cite> most significant bits removed.
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def head(n: Int): UInt">
<code class="descname">final def head(n: Int): UInt</code><a class="headerlink" href="#attr-final def head(n: Int): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Head operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param n:</th><td class="field-body">the number of bits to take</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">The <cite>n</cite> most significant bits of this $coll
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_tail(n: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =">
<code class="descname">def do_tail(n: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =</code><a class="headerlink" href="#attr-def do_tail(n: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_head(n: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =">
<code class="descname">def do_head(n: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =</code><a class="headerlink" href="#attr-def do_head(n: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def apply(x: BigInt): Bool">
<code class="descname">final def apply(x: BigInt): Bool</code><a class="headerlink" href="#attr-final def apply(x: BigInt): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the specified bit on this $coll as a <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a> , statically addressed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param x:</th><td class="field-body">an index</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the specified bit</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def do_apply(x: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool =">
<code class="descname">final def do_apply(x: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool =</code><a class="headerlink" href="#attr-final def do_apply(x: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def apply(x: Int): Bool">
<code class="descname">final def apply(x: Int): Bool</code><a class="headerlink" href="#attr-final def apply(x: Int): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the specified bit on this $coll as a <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a> , statically addressed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param x:</th><td class="field-body">an index</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the specified bit</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">convenience method allowing direct use of <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">scala.Int</span></code>  without implicits</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def do_apply(x: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">final def do_apply(x: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-final def do_apply(x: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def apply(x: UInt): Bool">
<code class="descname">final def apply(x: UInt): Bool</code><a class="headerlink" href="#attr-final def apply(x: UInt): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the specified bit on this wire as a <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a> , dynamically addressed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param x:</th><td class="field-body">a hardware component whose value will be used for dynamic addressing</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the specified bit</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def do_apply(x: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool =">
<code class="descname">final def do_apply(x: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool =</code><a class="headerlink" href="#attr-final def do_apply(x: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def apply(x: Int, y: Int): UInt">
<code class="descname">final def apply(x: Int, y: Int): UInt</code><a class="headerlink" href="#attr-final def apply(x: Int, y: Int): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subset of bits on this $coll from <cite>hi</cite> to <cite>lo</cite> (inclusive), statically addressed.
&#64;example</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">myBits</span> <span class="k">=</span> <span class="mh">0x5</span> <span class="k">=</span> <span class="mi">0</span><span class="n">b101</span>
<span class="n">myBits</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="n">b01</span>  <span class="c1">// extracts the two least significant bits</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param x:</th><td class="field-body">the high bit</td>
</tr>
<tr class="field-even field"><th class="field-name">Param y:</th><td class="field-body">the low bit</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return:</th><td class="field-body">a hardware component contain the requested bits</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def do_apply(x: Int, y: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =">
<code class="descname">final def do_apply(x: Int, y: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =</code><a class="headerlink" href="#attr-final def do_apply(x: Int, y: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def apply(x: BigInt, y: BigInt): UInt">
<code class="descname">final def apply(x: BigInt, y: BigInt): UInt</code><a class="headerlink" href="#attr-final def apply(x: BigInt, y: BigInt): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subset of bits on this $coll from <cite>hi</cite> to <cite>lo</cite> (inclusive), statically addressed.
&#64;example</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">myBits</span> <span class="k">=</span> <span class="mh">0x5</span> <span class="k">=</span> <span class="mi">0</span><span class="n">b101</span>
<span class="n">myBits</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="n">b01</span>  <span class="c1">// extracts the two least significant bits</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param x:</th><td class="field-body">the high bit</td>
</tr>
<tr class="field-even field"><th class="field-name">Param y:</th><td class="field-body">the low bit</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return:</th><td class="field-body">a hardware component contain the requested bits</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def do_apply(x: BigInt, y: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">final def do_apply(x: BigInt, y: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-final def do_apply(x: BigInt, y: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def pad(that: Int): this.type">
<code class="descname">final def pad(that: Int): this.type</code><a class="headerlink" href="#attr-final def pad(that: Int): this.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">the width to pad to</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">this &#64;coll zero padded up to width <cite>that</cite>. If <cite>that</cite> is less than the width of the original component,
this method returns the original component.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">For <a class="reference internal" href="core/core.html#attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]" title="attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">SInt</span></code></a> s only, this will do sign extension.
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_pad(that: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): this.type">
<code class="descname">def do_pad(that: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): this.type</code><a class="headerlink" href="#attr-def do_pad(that: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): this.type" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def unary_~ (): Bits">
<code class="descname">final def unary_~ (): Bits</code><a class="headerlink" href="#attr-final def unary_~ (): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise inversion operator
:return: this $coll with each bit inverted</p>
<blockquote>
<div>&#64;group Bitwise</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits">
<code class="descname">def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits</code><a class="headerlink" href="#attr-def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &lt;&lt; (that: BigInt): Bits">
<code class="descname">final def &lt;&lt; (that: BigInt): Bits</code><a class="headerlink" href="#attr-final def << (that: BigInt): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Static left shift operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">an amount to shift by</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">this $coll with <cite>that</cite> many zeros concatenated to its least significant end
$sumWidthInt
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&lt;&lt; (that: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits">
<code class="descname">def do_&lt;&lt; (that: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits</code><a class="headerlink" href="#attr-def do_<< (that: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &lt;&lt; (that: Int): Bits">
<code class="descname">final def &lt;&lt; (that: Int): Bits</code><a class="headerlink" href="#attr-final def << (that: Int): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Static left shift operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">an amount to shift by</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">this $coll with <cite>that</cite> many zeros concatenated to its least significant end
$sumWidthInt
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&lt;&lt; (that: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits">
<code class="descname">def do_&lt;&lt; (that: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits</code><a class="headerlink" href="#attr-def do_<< (that: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &lt;&lt; (that: UInt): Bits">
<code class="descname">final def &lt;&lt; (that: UInt): Bits</code><a class="headerlink" href="#attr-final def << (that: UInt): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic left shift operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware component</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">this $coll dynamically shifted left by <cite>that</cite> many places, shifting in zeros from the right</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">The width of the returned $coll is <cite>width of this + pow(2, width of that) - 1</cite>.
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&lt;&lt; (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits">
<code class="descname">def do_&lt;&lt; (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits</code><a class="headerlink" href="#attr-def do_<< (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &gt;&gt; (that: BigInt): Bits">
<code class="descname">final def &gt;&gt; (that: BigInt): Bits</code><a class="headerlink" href="#attr-final def >> (that: BigInt): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Static right shift operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">an amount to shift by</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">this $coll with <cite>that</cite> many least significant bits truncated
$unchangedWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&gt;&gt; (that: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits">
<code class="descname">def do_&gt;&gt; (that: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits</code><a class="headerlink" href="#attr-def do_>> (that: BigInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &gt;&gt; (that: Int): Bits">
<code class="descname">final def &gt;&gt; (that: Int): Bits</code><a class="headerlink" href="#attr-final def >> (that: Int): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Static right shift operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">an amount to shift by</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">this $coll with <cite>that</cite> many least significant bits truncated
$unchangedWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&gt;&gt; (that: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits">
<code class="descname">def do_&gt;&gt; (that: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits</code><a class="headerlink" href="#attr-def do_>> (that: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &gt;&gt; (that: UInt): Bits">
<code class="descname">final def &gt;&gt; (that: UInt): Bits</code><a class="headerlink" href="#attr-final def >> (that: UInt): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic right shift operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware component</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">this $coll dynamically shifted right by the value of <cite>that</cite> component, inserting zeros into the most
significant bits.
$unchangedWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&gt;&gt; (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits">
<code class="descname">def do_&gt;&gt; (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits</code><a class="headerlink" href="#attr-def do_>> (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def toBools(): Seq[Bool]">
<code class="descname">final def toBools(): Seq[Bool]</code><a class="headerlink" href="#attr-final def toBools(): Seq[Bool]" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the contents of this wire as a <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">scala.collection.Seq</span></code>  of <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a> .</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_toBools(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Seq[Bool]">
<code class="descname">def do_toBools(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Seq[Bool]</code><a class="headerlink" href="#attr-def do_toBools(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Seq[Bool]" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def asBools(): Seq[Bool]">
<code class="descname">final def asBools(): Seq[Bool]</code><a class="headerlink" href="#attr-final def asBools(): Seq[Bool]" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the contents of this wire as a <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">scala.collection.Seq</span></code>  of <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a> .</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_asBools(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Seq[Bool]">
<code class="descname">def do_asBools(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Seq[Bool]</code><a class="headerlink" href="#attr-def do_asBools(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Seq[Bool]" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def asSInt(): SInt">
<code class="descname">final def asSInt(): SInt</code><a class="headerlink" href="#attr-final def asSInt(): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Reinterpret this $coll as an <a class="reference internal" href="core/core.html#attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]" title="attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">SInt</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">The arithmetic value is not preserved if the most-significant bit is set. For example, a <a class="reference internal" href="core/core.html#attr-sealed class UInt private[core] (width: Width) extends Bits(width) with Num[UInt]" title="attr-sealed class UInt private[core] (width: Width) extends Bits(width) with Num[UInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">UInt</span></code></a>  of
width 3 and value 7 (0b111) would become an <a class="reference internal" href="core/core.html#attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]" title="attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">SInt</span></code></a>  of width 3 and value -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_asSInt(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def do_asSInt(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def do_asSInt(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def asFixedPoint(that: BinaryPoint): FixedPoint">
<code class="descname">final def asFixedPoint(that: BinaryPoint): FixedPoint</code><a class="headerlink" href="#attr-final def asFixedPoint(that: BinaryPoint): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Reinterpret this $coll as a <a class="reference internal" href="core/core.html#attr-sealed class FixedPoint private (width: Width, val binaryPoint: BinaryPoint) extends Bits(width) with Num[FixedPoint]" title="attr-sealed class FixedPoint private (width: Width, val binaryPoint: BinaryPoint) extends Bits(width) with Num[FixedPoint]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">FixedPoint</span></code></a> .</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">The value is not guaranteed to be preserved. For example, a <a class="reference internal" href="core/core.html#attr-sealed class UInt private[core] (width: Width) extends Bits(width) with Num[UInt]" title="attr-sealed class UInt private[core] (width: Width) extends Bits(width) with Num[UInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">UInt</span></code></a>  of width 3 and value 7 (0b111) would
become a <a class="reference internal" href="core/core.html#attr-sealed class FixedPoint private (width: Width, val binaryPoint: BinaryPoint) extends Bits(width) with Num[FixedPoint]" title="attr-sealed class FixedPoint private (width: Width, val binaryPoint: BinaryPoint) extends Bits(width) with Num[FixedPoint]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">FixedPoint</span></code></a>  with value -1. The interpretation of the number is also affected by the specified binary
point. ‘’’Caution is advised!’’’</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_asFixedPoint(that: BinaryPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint =">
<code class="descname">def do_asFixedPoint(that: BinaryPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint =</code><a class="headerlink" href="#attr-def do_asFixedPoint(that: BinaryPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def ## (that: Bits): UInt">
<code class="descname">final def ## (that: Bits): UInt</code><a class="headerlink" href="#attr-final def ## (that: Bits): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenation operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware component</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">this $coll concatenated to the most significant end of <cite>that</cite>
$sumWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_## (that: Bits)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =">
<code class="descname">def do_## (that: Bits)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =</code><a class="headerlink" href="#attr-def do_## (that: Bits)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def toPrintable: Printable">
<code class="descname">final def toPrintable: Printable</code><a class="headerlink" href="#attr-final def toPrintable: Printable" title="Permalink to this definition">¶</a></dt>
<dd><p>Default print as <a class="reference internal" href="core/core.html#attr-case class Decimal(bits: Bits) extends FirrtlFormat('d')" title="attr-case class Decimal(bits: Bits) extends FirrtlFormat('d')"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Decimal</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-abstract trait Num[T &lt;: Data]">
<code class="descname">abstract trait Num[T &lt;: Data]</code><a class="headerlink" href="#attr-abstract trait Num[T <: Data]" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract trait defining operations available on numeric-like hardware data types.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type-param T:</th><td class="field-body">the underlying type of the number
&#64;groupdesc Arithmetic Arithmetic hardware operators
&#64;groupdesc Comparison Comparison hardware operators
&#64;groupdesc Logical Logical hardware operators
&#64;define coll numeric-like type
&#64;define numType hardware type
&#64;define canHaveHighCost can result in significant cycle time and area costs
&#64;define canGenerateA This method generates a</td>
</tr>
</tbody>
</table>
<p>&#64;define singleCycleMul  :note: $canGenerateA fully combinational multiplier which $canHaveHighCost.</p>
<p>&#64;define singleCycleDiv  :note: $canGenerateA fully combinational divider which $canHaveHighCost.</p>
<p>&#64;define maxWidth        :note: The width of the returned $numType is <cite>max(width of this, width of that)</cite>.</p>
<p>&#64;define maxWidthPlusOne :note: The width of the returned $numType is <cite>max(width of this, width of that) + 1</cite>.</p>
<p>&#64;define sumWidth        :note: The width of the returned $numType is <cite>width of this</cite> + <cite>width of that</cite>.</p>
<p>&#64;define unchangedWidth  :note: The width of the returned $numType is unchanged, i.e., the <cite>width of this</cite>.</p>
<dl class="attr">
<dt id="attr-final def + (that: T): T">
<code class="descname">final def + (that: T): T</code><a class="headerlink" href="#attr-final def + (that: T): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a $numType</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the sum of this $coll and <cite>that</cite>
$maxWidth
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_+ (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T">
<code class="descname">def do_+ (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T</code><a class="headerlink" href="#attr-def do_+ (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def * (that: T): T">
<code class="descname">final def * (that: T): T</code><a class="headerlink" href="#attr-final def * (that: T): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a $numType</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the product of this $coll and <cite>that</cite>
$sumWidth
$singleCycleMul
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_* (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T">
<code class="descname">def do_* (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T</code><a class="headerlink" href="#attr-def do_* (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def / (that: T): T">
<code class="descname">final def / (that: T): T</code><a class="headerlink" href="#attr-final def / (that: T): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Division operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a $numType</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the quotient of this $coll divided by <cite>that</cite>
$singleCycleDiv
&#64;todo full rules
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_/ (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T">
<code class="descname">def do_/ (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T</code><a class="headerlink" href="#attr-def do_/ (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def % (that: T): T">
<code class="descname">final def % (that: T): T</code><a class="headerlink" href="#attr-final def % (that: T): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Modulo operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a $numType</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the remainder of this $coll divided by <cite>that</cite>
$singleCycleDiv
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_% (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T">
<code class="descname">def do_% (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T</code><a class="headerlink" href="#attr-def do_% (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def - (that: T): T">
<code class="descname">final def - (that: T): T</code><a class="headerlink" href="#attr-final def - (that: T): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtraction operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a $numType</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the difference of this $coll less <cite>that</cite>
$maxWidthPlusOne
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_- (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T">
<code class="descname">def do_- (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T</code><a class="headerlink" href="#attr-def do_- (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &lt; (that: T): Bool">
<code class="descname">final def &lt; (that: T): Bool</code><a class="headerlink" href="#attr-final def < (that: T): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Less than operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a $numType</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  asserted if this $coll is less than <cite>that</cite>
&#64;group Comparison</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&lt; (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_&lt; (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_< (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &lt;= (that: T): Bool">
<code class="descname">final def &lt;= (that: T): Bool</code><a class="headerlink" href="#attr-final def <= (that: T): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Less than or equal to operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a $numType</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  asserted if this $coll is less than or equal to <cite>that</cite>
&#64;group Comparison</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&lt;= (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_&lt;= (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_<= (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &gt; (that: T): Bool">
<code class="descname">final def &gt; (that: T): Bool</code><a class="headerlink" href="#attr-final def > (that: T): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Greater than operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware component</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  asserted if this $coll is greater than <cite>that</cite>
&#64;group Comparison</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&gt; (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_&gt; (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_> (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &gt;= (that: T): Bool">
<code class="descname">final def &gt;= (that: T): Bool</code><a class="headerlink" href="#attr-final def >= (that: T): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Greater than or equal to operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware component</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  asserted if this $coll is greather than or equal to <cite>that</cite>
&#64;group Comparison</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&gt;= (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_&gt;= (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_>= (that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def abs(): T">
<code class="descname">final def abs(): T</code><a class="headerlink" href="#attr-final def abs(): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute value operator
:return: a $numType with a value equal to the absolute value of this $coll</p>
<blockquote>
<div>$unchangedWidth
&#64;group Arithmetic</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_abs(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T">
<code class="descname">def do_abs(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T</code><a class="headerlink" href="#attr-def do_abs(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def min(that: T): T">
<code class="descname">final def min(that: T): T</code><a class="headerlink" href="#attr-final def min(that: T): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a $numType with a value equal to the mimimum value of this $coll and <cite>that</cite>
$maxWidth
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_min(that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T">
<code class="descname">def do_min(that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T</code><a class="headerlink" href="#attr-def do_min(that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def max(that: T): T">
<code class="descname">final def max(that: T): T</code><a class="headerlink" href="#attr-final def max(that: T): T" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a $numType</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a $numType with a value equal to the mimimum value of this $coll and <cite>that</cite>
$maxWidth
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_max(that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T">
<code class="descname">def do_max(that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T</code><a class="headerlink" href="#attr-def do_max(that: T)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-sealed class UInt private[chisel3] (width: Width) extends Bits(width) with Num[UInt]">
<code class="descname">sealed class UInt private[chisel3] (width: Width) extends Bits(width) with Num[UInt]</code><a class="headerlink" href="#attr-sealed class UInt private[chisel3] (width: Width) extends Bits(width) with Num[UInt]" title="Permalink to this definition">¶</a></dt>
<dd><p>A data type for unsigned integers, represented as a binary bitvector. Defines arithmetic operations between other       integer types.</p>
<p>&#64;define coll <a class="reference internal" href="core/core.html#attr-sealed class UInt private[core] (width: Width) extends Bits(width) with Num[UInt]" title="attr-sealed class UInt private[core] (width: Width) extends Bits(width) with Num[UInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">UInt</span></code></a>
&#64;define numType $coll</p>
<p>&#64;define expandingWidth :note: The width of the returned $coll is <cite>width of this</cite> + <cite>1</cite>.</p>
<p>&#64;define constantWidth  :note: The width of the returned $coll is unchanged, i.e., <cite>width of this</cite>.</p>
<dl class="attr">
<dt id="attr-final def unary_- (): UInt">
<code class="descname">final def unary_- (): UInt</code><a class="headerlink" href="#attr-final def unary_- (): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary negation (expanding width)
:return: a $coll equal to zero minus this $coll</p>
<blockquote>
<div>$constantWidth
&#64;group Arithmetic</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-final def unary_-% (): UInt">
<code class="descname">final def unary_-% (): UInt</code><a class="headerlink" href="#attr-final def unary_-% (): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary negation (constant width)
:return: a $coll equal to zero minus this $coll shifted right by one.</p>
<blockquote>
<div>$constantWidth
&#64;group Arithmetic</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_unary_- (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions) : UInt">
<code class="descname">def do_unary_- (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions) : UInt</code><a class="headerlink" href="#attr-def do_unary_- (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions) : UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_unary_-% (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_unary_-% (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_unary_-% (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def * (that: SInt): SInt">
<code class="descname">final def * (that: SInt): SInt</code><a class="headerlink" href="#attr-final def * (that: SInt): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]" title="attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">SInt</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the product of this $coll and <cite>that</cite>
$sumWidth
$singleCycleMul
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_* (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def do_* (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def do_* (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def +&amp; (that: UInt): UInt">
<code class="descname">final def +&amp; (that: UInt): UInt</code><a class="headerlink" href="#attr-final def +& (that: UInt): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition operator (expanding width)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the sum of this $coll and <cite>that</cite>
$maxWidthPlusOne
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def +% (that: UInt): UInt">
<code class="descname">final def +% (that: UInt): UInt</code><a class="headerlink" href="#attr-final def +% (that: UInt): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition operator (constant width)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the sum of this $coll and <cite>that</cite>
$maxWidth
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def -&amp; (that: UInt): UInt">
<code class="descname">final def -&amp; (that: UInt): UInt</code><a class="headerlink" href="#attr-final def -& (that: UInt): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtraction operator (increasing width)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the difference of this $coll less <cite>that</cite>
$maxWidthPlusOne
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def -% (that: UInt): UInt">
<code class="descname">final def -% (that: UInt): UInt</code><a class="headerlink" href="#attr-final def -% (that: UInt): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtraction operator (constant width)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the difference of this $coll less <cite>that</cite>
$maxWidth
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_+&amp; (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_+&amp; (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_+& (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_+% (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_+% (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_+% (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_-&amp; (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_-&amp; (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_-& (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_-% (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_-% (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_-% (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &amp; (that: UInt): UInt">
<code class="descname">final def &amp; (that: UInt): UInt</code><a class="headerlink" href="#attr-final def & (that: UInt): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise and operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the bitwise and of  this $coll and <cite>that</cite>
$maxWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def | (that: UInt): UInt">
<code class="descname">final def | (that: UInt): UInt</code><a class="headerlink" href="#attr-final def | (that: UInt): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise or operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the bitwise or of this $coll and <cite>that</cite>
$maxWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def ^ (that: UInt): UInt">
<code class="descname">final def ^ (that: UInt): UInt</code><a class="headerlink" href="#attr-final def ^ (that: UInt): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise exclusive or (xor) operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the bitwise xor of this $coll and <cite>that</cite>
$maxWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&amp; (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_&amp; (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_& (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_| (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_| (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_| (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_^ (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_^ (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_^ (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt">
<code class="descname">def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt</code><a class="headerlink" href="#attr-def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def orR(): Bool">
<code class="descname">final def orR(): Bool</code><a class="headerlink" href="#attr-final def orR(): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Or reduction operator
:return: a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  resulting from every bit of this $coll or’d together</p>
<blockquote>
<div>&#64;group Bitwise</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-final def andR(): Bool">
<code class="descname">final def andR(): Bool</code><a class="headerlink" href="#attr-final def andR(): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>And reduction operator
:return: a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  resulting from every bit of this $coll and’d together</p>
<blockquote>
<div>&#64;group Bitwise</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-final def xorR(): Bool">
<code class="descname">final def xorR(): Bool</code><a class="headerlink" href="#attr-final def xorR(): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclusive or (xor) reduction operator
:return: a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  resulting from every bit of this $coll xor’d together</p>
<blockquote>
<div>&#64;group Bitwise</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_orR(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_orR(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_orR(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_andR(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_andR(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_andR(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_xorR(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_xorR(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_xorR(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def =/= (that: UInt): Bool">
<code class="descname">final def =/= (that: UInt): Bool</code><a class="headerlink" href="#attr-final def =/= (that: UInt): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic not equals operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  asserted if this $coll is not equal to <cite>that</cite>
&#64;group Comparison</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def === (that: UInt): Bool">
<code class="descname">final def === (that: UInt): Bool</code><a class="headerlink" href="#attr-final def === (that: UInt): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic equals operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  asserted if this $coll is equal to <cite>that</cite>
&#64;group Comparison</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_=/= (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_=/= (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_=/= (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_=== (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_=== (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_=== (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def unary_! () : Bool">
<code class="descname">final def unary_! () : Bool</code><a class="headerlink" href="#attr-final def unary_! () : Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary not
:return: a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  asserted if this $coll equals zero</p>
<blockquote>
<div>&#64;group Bitwise</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_unary_! (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions) : Bool">
<code class="descname">def do_unary_! (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions) : Bool</code><a class="headerlink" href="#attr-def do_unary_! (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions) : Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def bitSet(off: UInt, dat: Bool): UInt">
<code class="descname">final def bitSet(off: UInt, dat: Bool): UInt</code><a class="headerlink" href="#attr-final def bitSet(off: UInt, dat: Bool): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditionally set or clear a bit</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param off:</th><td class="field-body">a dynamic offset</td>
</tr>
<tr class="field-even field"><th class="field-name">Param dat:</th><td class="field-body">set if true, clear if false</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return:</th><td class="field-body">a hrdware $coll with bit <cite>off</cite> set or cleared based on the value of <cite>dat</cite>
$unchangedWidth</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_bitSet(off: UInt, dat: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =">
<code class="descname">def do_bitSet(off: UInt, dat: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =</code><a class="headerlink" href="#attr-def do_bitSet(off: UInt, dat: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): UInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def zext(): SInt">
<code class="descname">final def zext(): SInt</code><a class="headerlink" href="#attr-final def zext(): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero extend as <a class="reference internal" href="core/core.html#attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]" title="attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">SInt</span></code></a>
:return: an <a class="reference internal" href="core/core.html#attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]" title="attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">SInt</span></code></a>  equal to this $coll with an additional zero in its most significant bit</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">The width of the returned <a class="reference internal" href="core/core.html#attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]" title="attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">SInt</span></code></a>  is <cite>width of this</cite> + <cite>1</cite>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_zext(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def do_zext(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def do_zext(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-trait UIntFactory">
<code class="descname">trait UIntFactory</code><a class="headerlink" href="#attr-trait UIntFactory" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply(): UInt">
<code class="descname">def apply(): UInt</code><a class="headerlink" href="#attr-def apply(): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a UInt type with inferred width.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(width: Width): UInt">
<code class="descname">def apply(width: Width): UInt</code><a class="headerlink" href="#attr-def apply(width: Width): UInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a UInt port with specified width.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-protected[chisel3] def Lit(value: BigInt, width: Width): UInt =">
<code class="descname">protected[chisel3] def Lit(value: BigInt, width: Width): UInt =</code><a class="headerlink" href="#attr-protected[chisel3] def Lit(value: BigInt, width: Width): UInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a UInt literal with specified width.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(range: Range): UInt =">
<code class="descname">def apply(range: Range): UInt =</code><a class="headerlink" href="#attr-def apply(range: Range): UInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a UInt with the specified range</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(range: (NumericBound[Int], NumericBound[Int])): UInt =">
<code class="descname">def apply(range: (NumericBound[Int], NumericBound[Int])): UInt =</code><a class="headerlink" href="#attr-def apply(range: (NumericBound[Int], NumericBound[Int])): UInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a UInt with the specified range</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-sealed class SInt private[chisel3] (width: Width) extends Bits(width) with Num[SInt]">
<code class="descname">sealed class SInt private[chisel3] (width: Width) extends Bits(width) with Num[SInt]</code><a class="headerlink" href="#attr-sealed class SInt private[chisel3] (width: Width) extends Bits(width) with Num[SInt]" title="Permalink to this definition">¶</a></dt>
<dd><p>A data type for signed integers, represented as a binary bitvector. Defines arithmetic operations between other integer types.</p>
<p>&#64;define coll <a class="reference internal" href="core/core.html#attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]" title="attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">SInt</span></code></a>
&#64;define numType $coll</p>
<p>&#64;define expandingWidth :note: The width of the returned $coll is <cite>width of this</cite> + <cite>1</cite>.</p>
<p>&#64;define constantWidth  :note: The width of the returned $coll is unchanged, i.e., <cite>width of this</cite>.</p>
<dl class="attr">
<dt id="attr-final def unary_- (): SInt">
<code class="descname">final def unary_- (): SInt</code><a class="headerlink" href="#attr-final def unary_- (): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary negation (expanding width)
:return: a hardware $coll equal to zero minus this $coll</p>
<blockquote>
<div>$constantWidth
&#64;group Arithmetic</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-final def unary_-% (): SInt">
<code class="descname">final def unary_-% (): SInt</code><a class="headerlink" href="#attr-final def unary_-% (): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary negation (constant width)
:return: a hardware $coll equal to zero minus <cite>this</cite> shifted right by one</p>
<blockquote>
<div>$constantWidth
&#64;group Arithmetic</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-def unary_- (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def unary_- (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def unary_- (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def unary_-% (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def unary_-% (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def unary_-% (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-override def do_+ (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">override def do_+ (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-override def do_+ (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>add (default - no growth) operator</p>
</dd></dl>

<dl class="attr">
<dt id="attr-override def do_- (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">override def do_- (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-override def do_- (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>subtract (default - no growth) operator</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def * (that: UInt): SInt">
<code class="descname">final def * (that: UInt): SInt</code><a class="headerlink" href="#attr-final def * (that: UInt): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the product of this $coll and <cite>that</cite>
$sumWidth
$singleCycleMul
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_* (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt =">
<code class="descname">def do_* (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt =</code><a class="headerlink" href="#attr-def do_* (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def +&amp; (that: SInt): SInt">
<code class="descname">final def +&amp; (that: SInt): SInt</code><a class="headerlink" href="#attr-final def +& (that: SInt): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition operator (expanding width)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the sum of this $coll and <cite>that</cite>
$maxWidthPlusOne
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def +% (that: SInt): SInt">
<code class="descname">final def +% (that: SInt): SInt</code><a class="headerlink" href="#attr-final def +% (that: SInt): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition operator (constant width)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the sum of this $coll and <cite>that</cite> shifted right by one
$maxWidth
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def -&amp; (that: SInt): SInt">
<code class="descname">final def -&amp; (that: SInt): SInt</code><a class="headerlink" href="#attr-final def -& (that: SInt): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtraction operator (increasing width)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the difference of this $coll less <cite>that</cite>
$maxWidthPlusOne
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def -% (that: SInt): SInt">
<code class="descname">final def -% (that: SInt): SInt</code><a class="headerlink" href="#attr-final def -% (that: SInt): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtraction operator (constant width)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the difference of this $coll less <cite>that</cite> shifted right by one
$maxWidth
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_+&amp; (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def do_+&amp; (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def do_+& (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_+% (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def do_+% (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def do_+% (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_-&amp; (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def do_-&amp; (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def do_-& (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_-% (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def do_-% (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def do_-% (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &amp; (that: SInt): SInt">
<code class="descname">final def &amp; (that: SInt): SInt</code><a class="headerlink" href="#attr-final def & (that: SInt): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise and operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the bitwise and of  this $coll and <cite>that</cite>
$maxWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def | (that: SInt): SInt">
<code class="descname">final def | (that: SInt): SInt</code><a class="headerlink" href="#attr-final def | (that: SInt): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise or operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the bitwise or of this $coll and <cite>that</cite>
$maxWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def ^ (that: SInt): SInt">
<code class="descname">final def ^ (that: SInt): SInt</code><a class="headerlink" href="#attr-final def ^ (that: SInt): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise exclusive or (xor) operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the bitwise xor of this $coll and <cite>that</cite>
$maxWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&amp; (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def do_&amp; (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def do_& (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_| (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def do_| (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def do_| (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_^ (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def do_^ (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def do_^ (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt">
<code class="descname">def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt</code><a class="headerlink" href="#attr-def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def =/= (that: SInt): Bool">
<code class="descname">final def =/= (that: SInt): Bool</code><a class="headerlink" href="#attr-final def =/= (that: SInt): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic not equals operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  asserted if this $coll is not equal to <cite>that</cite>
&#64;group Comparison</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def === (that: SInt): Bool">
<code class="descname">final def === (that: SInt): Bool</code><a class="headerlink" href="#attr-final def === (that: SInt): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic equals operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  asserted if this $coll is equal to <cite>that</cite>
&#64;group Comparison</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_=/= (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_=/= (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_=/= (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_=== (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_=== (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_=== (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-trait SIntFactory">
<code class="descname">trait SIntFactory</code><a class="headerlink" href="#attr-trait SIntFactory" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply(): SInt">
<code class="descname">def apply(): SInt</code><a class="headerlink" href="#attr-def apply(): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an SInt type with inferred width.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(width: Width): SInt">
<code class="descname">def apply(width: Width): SInt</code><a class="headerlink" href="#attr-def apply(width: Width): SInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a SInt type or port with fixed width.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(range: Range): SInt =">
<code class="descname">def apply(range: Range): SInt =</code><a class="headerlink" href="#attr-def apply(range: Range): SInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a SInt with the specified range</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(range: (NumericBound[Int], NumericBound[Int])): SInt =">
<code class="descname">def apply(range: (NumericBound[Int], NumericBound[Int])): SInt =</code><a class="headerlink" href="#attr-def apply(range: (NumericBound[Int], NumericBound[Int])): SInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a SInt with the specified range</p>
</dd></dl>

<dl class="attr">
<dt id="attr-protected[chisel3] def Lit(value: BigInt, width: Width): SInt =">
<code class="descname">protected[chisel3] def Lit(value: BigInt, width: Width): SInt =</code><a class="headerlink" href="#attr-protected[chisel3] def Lit(value: BigInt, width: Width): SInt =" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an SInt literal with specified width.</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-object SInt extends SIntFactory  sealed trait Reset extends Element with ToBoolable">
<code class="descname">object SInt extends SIntFactory  sealed trait Reset extends Element with ToBoolable</code><a class="headerlink" href="#attr-object SInt extends SIntFactory  sealed trait Reset extends Element with ToBoolable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-sealed trait Reset extends Element with ToBoolable">
<code class="descname">sealed trait Reset extends Element with ToBoolable</code><a class="headerlink" href="#attr-sealed trait Reset extends Element with ToBoolable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-sealed class Bool() extends UInt(1.W) with Reset">
<code class="descname">sealed class Bool() extends UInt(1.W) with Reset</code><a class="headerlink" href="#attr-sealed class Bool() extends UInt(1.W) with Reset" title="Permalink to this definition">¶</a></dt>
<dd><p>A data type for booleans, defined as a single bit indicating true or false.
&#64;define coll <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>
&#64;define numType $coll</p>
<dl class="attr">
<dt id="attr-def litToBooleanOption: Option[Boolean]">
<code class="descname">def litToBooleanOption: Option[Boolean]</code><a class="headerlink" href="#attr-def litToBooleanOption: Option[Boolean]" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">scala.Option</span></code>  of <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">scala.Boolean</span></code></p>
</dd></dl>

<dl class="attr">
<dt id="attr-def litToBoolean: Boolean">
<code class="descname">def litToBoolean: Boolean</code><a class="headerlink" href="#attr-def litToBoolean: Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">scala.Boolean</span></code></p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &amp; (that: Bool): Bool">
<code class="descname">final def &amp; (that: Bool): Bool</code><a class="headerlink" href="#attr-final def & (that: Bool): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise and operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the bitwise and of  this $coll and <cite>that</cite>
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def | (that: Bool): Bool">
<code class="descname">final def | (that: Bool): Bool</code><a class="headerlink" href="#attr-final def | (that: Bool): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise or operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the bitwise or of this $coll and <cite>that</cite>
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def ^ (that: Bool): Bool">
<code class="descname">final def ^ (that: Bool): Bool</code><a class="headerlink" href="#attr-final def ^ (that: Bool): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise exclusive or (xor) operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the bitwise xor of this $coll and <cite>that</cite>
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&amp; (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_&amp; (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_& (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_| (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_| (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_| (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_^ (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_^ (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_^ (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-override def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">override def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-override def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def || (that: Bool): Bool">
<code class="descname">def || (that: Bool): Bool</code><a class="headerlink" href="#attr-def || (that: Bool): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical or operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the lgocial or of this $coll and <cite>that</cite></td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">this is equivalent to <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool!.|(that:chisel3.Bool)*</span> <span class="pre">Bool.|)</span></code>
&#64;group Logical</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_|| (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_|| (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_|| (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def &amp;&amp; (that: Bool): Bool">
<code class="descname">def &amp;&amp; (that: Bool): Bool</code><a class="headerlink" href="#attr-def && (that: Bool): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical and operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the lgocial and of this $coll and <cite>that</cite></td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">this is equivalent to <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool!.&amp;(that:chisel3.Bool)*</span> <span class="pre">Bool.&amp;</span></code>
&#64;group Logical</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&amp;&amp; (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_&amp;&amp; (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_&& (that: Bool)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def asClock(): Clock">
<code class="descname">def asClock(): Clock</code><a class="headerlink" href="#attr-def asClock(): Clock" title="Permalink to this definition">¶</a></dt>
<dd><p>Reinterprets this $coll as a clock</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_asClock(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Clock">
<code class="descname">def do_asClock(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Clock</code><a class="headerlink" href="#attr-def do_asClock(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Clock" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-trait BoolFactory">
<code class="descname">trait BoolFactory</code><a class="headerlink" href="#attr-trait BoolFactory" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply(): Bool">
<code class="descname">def apply(): Bool</code><a class="headerlink" href="#attr-def apply(): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an empty Bool.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-protected[chisel3] def Lit(x: Boolean): Bool =">
<code class="descname">protected[chisel3] def Lit(x: Boolean): Bool =</code><a class="headerlink" href="#attr-protected[chisel3] def Lit(x: Boolean): Bool =" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates Bool literal.</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-object Bool extends BoolFactory  package experimental">
<code class="descname">object Bool extends BoolFactory  package experimental</code><a class="headerlink" href="#attr-object Bool extends BoolFactory  package experimental" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-sealed class FixedPoint private(width: Width, val binaryPoint: BinaryPoint) extends Bits(width) with Num[FixedPoint]">
<code class="descname">sealed class FixedPoint private(width: Width, val binaryPoint: BinaryPoint) extends Bits(width) with Num[FixedPoint]</code><a class="headerlink" href="#attr-sealed class FixedPoint private(width: Width, val binaryPoint: BinaryPoint) extends Bits(width) with Num[FixedPoint]" title="Permalink to this definition">¶</a></dt>
<dd><p>A sealed class representing a fixed point number that has a bit width and a binary point The width and binary point     may be inferred.</p>
<p>IMPORTANT: The API provided here is experimental and may change in the future.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param width:</th><td class="field-body">bit width of the fixed point number</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Param binaryPoint:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">the position of the binary point with respect to the right most bit of the width currently this
should be positive but it is hoped to soon support negative points and thus use this field as a
simple exponent
&#64;define coll           <a class="reference internal" href="core/core.html#attr-sealed class FixedPoint private (width: Width, val binaryPoint: BinaryPoint) extends Bits(width) with Num[FixedPoint]" title="attr-sealed class FixedPoint private (width: Width, val binaryPoint: BinaryPoint) extends Bits(width) with Num[FixedPoint]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">FixedPoint</span></code></a>
&#64;define numType        $coll</td>
</tr>
</tbody>
</table>
<p>&#64;define expandingWidth :note: The width of the returned $coll is <cite>width of this</cite> + <cite>1</cite>.</p>
<p>&#64;define constantWidth  :note: The width of the returned $coll is unchanged, i.e., <cite>width of this</cite>.</p>
<dl class="attr">
<dt id="attr-def litToDoubleOption: Option[Double]">
<code class="descname">def litToDoubleOption: Option[Double]</code><a class="headerlink" href="#attr-def litToDoubleOption: Option[Double]" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">scala.Option</span></code>  of <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">scala.Boolean</span></code></p>
</dd></dl>

<dl class="attr">
<dt id="attr-def litToDouble: Double">
<code class="descname">def litToDouble: Double</code><a class="headerlink" href="#attr-def litToDouble: Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">scala.Option</span></code></p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def unary_- (): FixedPoint">
<code class="descname">final def unary_- (): FixedPoint</code><a class="headerlink" href="#attr-final def unary_- (): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary negation (expanding width)
:return: a hardware $coll equal to zero minus this $coll</p>
<blockquote>
<div>$expandingWidth
&#64;group Arithmetic</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-final def unary_-% (): FixedPoint">
<code class="descname">final def unary_-% (): FixedPoint</code><a class="headerlink" href="#attr-final def unary_-% (): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary negation (constant width)
:return: a hardware $coll equal to zero minus <cite>this</cite> shifted right by one</p>
<blockquote>
<div>$constantWidth
&#64;group Arithmetic</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-def unary_- (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">def unary_- (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-def unary_- (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def unary_-% (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">def unary_-% (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-def unary_-% (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-override def do_+ (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">override def do_+ (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-override def do_+ (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>add (default - no growth) operator</p>
</dd></dl>

<dl class="attr">
<dt id="attr-override def do_- (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">override def do_- (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-override def do_- (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>subtract (default - no growth) operator</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def * (that: UInt): FixedPoint">
<code class="descname">final def * (that: UInt): FixedPoint</code><a class="headerlink" href="#attr-final def * (that: UInt): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class UInt private[core] (width: Width) extends Bits(width) with Num[UInt]" title="attr-sealed class UInt private[core] (width: Width) extends Bits(width) with Num[UInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">UInt</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the product of this $coll and <cite>that</cite>
$sumWidth
$singleCycleMul
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_* (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">def do_* (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-def do_* (that: UInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def * (that: SInt): FixedPoint">
<code class="descname">final def * (that: SInt): FixedPoint</code><a class="headerlink" href="#attr-final def * (that: SInt): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]" title="attr-sealed class SInt private[core] (width: Width) extends Bits(width) with Num[SInt]"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">SInt</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the product of this $coll and <cite>that</cite>
$sumWidth
$singleCycleMul
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_* (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">def do_* (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-def do_* (that: SInt)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def +&amp; (that: FixedPoint): FixedPoint">
<code class="descname">final def +&amp; (that: FixedPoint): FixedPoint</code><a class="headerlink" href="#attr-final def +& (that: FixedPoint): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition operator (expanding width)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the sum of this $coll and <cite>that</cite>
$maxWidthPlusOne
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def +% (that: FixedPoint): FixedPoint">
<code class="descname">final def +% (that: FixedPoint): FixedPoint</code><a class="headerlink" href="#attr-final def +% (that: FixedPoint): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition operator (constant width)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the sum of this $coll and <cite>that</cite> shifted right by one
$maxWidth
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def -&amp; (that: FixedPoint): FixedPoint">
<code class="descname">final def -&amp; (that: FixedPoint): FixedPoint</code><a class="headerlink" href="#attr-final def -& (that: FixedPoint): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtraction operator (increasing width)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the difference of this $coll less <cite>that</cite>
$maxWidthPlusOne
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def -% (that: FixedPoint): FixedPoint">
<code class="descname">final def -% (that: FixedPoint): FixedPoint</code><a class="headerlink" href="#attr-final def -% (that: FixedPoint): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtraction operator (constant width)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the difference of this $coll less <cite>that</cite> shifted right by one
$maxWidth
&#64;group Arithmetic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_+&amp; (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint =">
<code class="descname">def do_+&amp; (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint =</code><a class="headerlink" href="#attr-def do_+& (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_+% (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">def do_+% (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-def do_+% (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_-&amp; (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint =">
<code class="descname">def do_-&amp; (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint =</code><a class="headerlink" href="#attr-def do_-& (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_-% (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">def do_-% (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-def do_-% (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def &amp; (that: FixedPoint): FixedPoint">
<code class="descname">final def &amp; (that: FixedPoint): FixedPoint</code><a class="headerlink" href="#attr-final def & (that: FixedPoint): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise and operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the bitwise and of  this $coll and <cite>that</cite>
$maxWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def | (that: FixedPoint): FixedPoint">
<code class="descname">final def | (that: FixedPoint): FixedPoint</code><a class="headerlink" href="#attr-final def | (that: FixedPoint): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise or operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the bitwise or of this $coll and <cite>that</cite>
$maxWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def ^ (that: FixedPoint): FixedPoint">
<code class="descname">final def ^ (that: FixedPoint): FixedPoint</code><a class="headerlink" href="#attr-final def ^ (that: FixedPoint): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise exclusive or (xor) operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the bitwise xor of this $coll and <cite>that</cite>
$maxWidth
&#64;group Bitwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_&amp; (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">def do_&amp; (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-def do_& (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_| (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">def do_| (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-def do_| (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_^ (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">def do_^ (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-def do_^ (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_setBinaryPoint(that: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">def do_setBinaryPoint(that: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-def do_setBinaryPoint(that: Int)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint">
<code class="descname">def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint</code><a class="headerlink" href="#attr-def do_unary_~ (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def =/= (that: FixedPoint): Bool">
<code class="descname">final def =/= (that: FixedPoint): Bool</code><a class="headerlink" href="#attr-final def =/= (that: FixedPoint): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic not equals operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  asserted if this $coll is not equal to <cite>that</cite>
&#64;group Comparison</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-final def === (that: FixedPoint): Bool">
<code class="descname">final def === (that: FixedPoint): Bool</code><a class="headerlink" href="#attr-final def === (that: FixedPoint): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic equals operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param that:</th><td class="field-body">a hardware $coll</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">a hardware <a class="reference internal" href="core/core.html#attr-sealed class Bool() extends UInt(1.W) with Reset" title="attr-sealed class Bool() extends UInt(1.W) with Reset"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bool</span></code></a>  asserted if this $coll is equal to <cite>that</cite>
&#64;group Comparison</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_!= (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_!= (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_!= (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_=/= (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_=/= (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_=/= (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_=== (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool">
<code class="descname">def do_=== (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool</code><a class="headerlink" href="#attr-def do_=== (that: FixedPoint)(implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): Bool" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-sealed trait PrivateType private case object PrivateObject extends PrivateType">
<code class="descname">sealed trait PrivateType private case object PrivateObject extends PrivateType</code><a class="headerlink" href="#attr-sealed trait PrivateType private case object PrivateObject extends PrivateType" title="Permalink to this definition">¶</a></dt>
<dd><p>Use PrivateObject to force users to specify width and binaryPoint by name</p>
</dd></dl>

<dl class="attr">
<dt id="attr-object FixedPoint">
<code class="descname">object FixedPoint</code><a class="headerlink" href="#attr-object FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Factory and convenience methods for the FixedPoint class</div></blockquote>
<p>IMPORTANT: The API provided here is experimental and may change in the future.</p>
<dl class="attr">
<dt id="attr-def apply(): FixedPoint">
<code class="descname">def apply(): FixedPoint</code><a class="headerlink" href="#attr-def apply(): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an FixedPoint type with inferred width.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(width: Width, binaryPoint: BinaryPoint): FixedPoint">
<code class="descname">def apply(width: Width, binaryPoint: BinaryPoint): FixedPoint</code><a class="headerlink" href="#attr-def apply(width: Width, binaryPoint: BinaryPoint): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an FixedPoint type or port with fixed width.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def fromBigInt(value: BigInt, width: Width, binaryPoint: BinaryPoint): FixedPoint =">
<code class="descname">def fromBigInt(value: BigInt, width: Width, binaryPoint: BinaryPoint): FixedPoint =</code><a class="headerlink" href="#attr-def fromBigInt(value: BigInt, width: Width, binaryPoint: BinaryPoint): FixedPoint =" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an FixedPoint literal with inferred width from BigInt.   Use PrivateObject to force users to specify width and binaryPoint by name</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def fromBigInt(value: BigInt, binaryPoint: BinaryPoint = 0.BP): FixedPoint =">
<code class="descname">def fromBigInt(value: BigInt, binaryPoint: BinaryPoint = 0.BP): FixedPoint =</code><a class="headerlink" href="#attr-def fromBigInt(value: BigInt, binaryPoint: BinaryPoint = 0.BP): FixedPoint =" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an FixedPoint literal with inferred width from BigInt.   Use PrivateObject to force users to specify width and binaryPoint by name</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def fromBigInt(value: BigInt, width: Int, binaryPoint: Int): FixedPoint">
<code class="descname">def fromBigInt(value: BigInt, width: Int, binaryPoint: Int): FixedPoint</code><a class="headerlink" href="#attr-def fromBigInt(value: BigInt, width: Int, binaryPoint: Int): FixedPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an FixedPoint literal with inferred width from BigInt.   Use PrivateObject to force users to specify width and binaryPoint by name</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def fromDouble(value: Double, width: Width, binaryPoint: BinaryPoint): FixedPoint =">
<code class="descname">def fromDouble(value: Double, width: Width, binaryPoint: BinaryPoint): FixedPoint =</code><a class="headerlink" href="#attr-def fromDouble(value: Double, width: Width, binaryPoint: BinaryPoint): FixedPoint =" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an FixedPoint literal with inferred width from Double.   Use PrivateObject to force users to specify width and binaryPoint by name</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply(value: BigInt, width: Width, binaryPoint: BinaryPoint): FixedPoint =">
<code class="descname">def apply(value: BigInt, width: Width, binaryPoint: BinaryPoint): FixedPoint =</code><a class="headerlink" href="#attr-def apply(value: BigInt, width: Width, binaryPoint: BinaryPoint): FixedPoint =" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an FixedPoint port with specified width and binary position.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def toBigInt(x: Double, binaryPoint: Int): BigInt =">
<code class="descname">def toBigInt(x: Double, binaryPoint: Int): BigInt =</code><a class="headerlink" href="#attr-def toBigInt(x: Double, binaryPoint: Int): BigInt =" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>How to create a bigint from a double with a specific binaryPoint</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param x:</th><td class="field-body">a double value</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Param binaryPoint:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">a binaryPoint that you would like to use
&#64;return</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def toDouble(i: BigInt, binaryPoint: Int): Double =">
<code class="descname">def toDouble(i: BigInt, binaryPoint: Int): Double =</code><a class="headerlink" href="#attr-def toDouble(i: BigInt, binaryPoint: Int): Double =" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>converts a bigInt with the given binaryPoint into the double representation</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param i:</th><td class="field-body">a bigint</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Param binaryPoint:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">the implied binaryPoint of &#64;i
&#64;return</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-final class Analog private (private[chisel3] val width: Width) extends Element">
<code class="descname">final class Analog private (private[chisel3] val width: Width) extends Element</code><a class="headerlink" href="#attr-final class Analog private (private[chisel3] val width: Width) extends Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Data type for representing bidirectional bitvectors of a given width
Analog support is limited to allowing wiring up of Verilog BlackBoxes with bidirectional (inout)
pins. There is currently no support for reading or writing of Analog types within Chisel code.</p>
<p>Given that Analog is bidirectional, it is illegal to assign a direction to any Analog type. It
is legal to “flip” the direction (since Analog can be a member of aggregate types) which has no
effect.</p>
<p>Analog types are generally connected using the bidirectional <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">attach</span></code>  mechanism, but also
support limited bulkconnect <cite>&lt;&gt;</cite>. Analog types are only allowed to be bulk connected <em>once</em> in a
given module. This is to prevent any surprising consequences of last connect semantics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">This API is experimental and subject to change</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-object Analog">
<code class="descname">object Analog</code><a class="headerlink" href="#attr-object Analog" title="Permalink to this definition">¶</a></dt>
<dd><p>Object that provides factory methods for <a class="reference internal" href="core/core.html#attr-final class Analog private (private[chisel3] val width: Width) extends Element" title="attr-final class Analog private (private[chisel3] val width: Width) extends Element"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Analog</span></code></a>  objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">This API is experimental and subject to change</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="printable-scala">
<h2>Printable.scala<a class="headerlink" href="#printable-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-sealed abstract class Printable">
<code class="descname">sealed abstract class Printable</code><a class="headerlink" href="#attr-sealed abstract class Printable" title="Permalink to this definition">¶</a></dt>
<dd><p>Superclass of things that can be printed in the resulting circuit
Usually created using the custom string interpolator <cite>p”…”</cite>. Printable string interpolation is
similar to <code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">https://docs.scala-lang.org/overviews/core/string-interpolation.html</span> <span class="pre">String</span>
<span class="pre">interpolation</span> <span class="pre">in</span> <span class="pre">Scala</span></code>  For example:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">printf</span><span class="o">(</span><span class="n">p</span><span class="s">&quot;The value of wire = \$wire\n&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>This is equivalent to writing:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">printf</span><span class="o">(</span><span class="n">p</span><span class="s">&quot;The value of wire = %d\n&quot;</span><span class="o">,</span> <span class="n">wire</span><span class="o">)</span>
</pre></div>
</div>
<p>All Chisel data types have a method <cite>.toPrintable</cite> that gives a default pretty print that can be
accessed via <cite>p”…”</cite>. This works even for aggregate types, for example:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">myVec</span> <span class="k">=</span> <span class="nc">VecInit</span><span class="o">(</span><span class="mf">5.</span><span class="n">U</span><span class="o">,</span> <span class="mf">10.</span><span class="n">U</span><span class="o">,</span> <span class="mf">13.</span><span class="n">U</span><span class="o">)</span>
<span class="n">printf</span><span class="o">(</span><span class="n">p</span><span class="s">&quot;myVec = \$myVec\n&quot;</span><span class="o">)</span>
<span class="c1">// myVec = Vec(5, 10, 13)</span>

<span class="k">val</span> <span class="n">myBundle</span> <span class="k">=</span> <span class="nc">Wire</span><span class="o">(</span><span class="k">new</span> <span class="nc">Bundle</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">foo</span> <span class="k">=</span> <span class="nc">UInt</span><span class="o">()</span>
  <span class="k">val</span> <span class="n">bar</span> <span class="k">=</span> <span class="nc">UInt</span><span class="o">()</span>
<span class="o">})</span>
<span class="n">myBundle</span><span class="o">.</span><span class="n">foo</span> <span class="o">:=</span> <span class="mf">3.</span><span class="n">U</span>
<span class="n">myBundle</span><span class="o">.</span><span class="n">bar</span> <span class="o">:=</span> <span class="mf">11.</span><span class="n">U</span>
<span class="n">printf</span><span class="o">(</span><span class="n">p</span><span class="s">&quot;myBundle = \$myBundle\n&quot;</span><span class="o">)</span>
<span class="c1">// myBundle = Bundle(a -&gt; 3, b -&gt; 11)</span>
</pre></div>
</div>
<p>Users can override the default behavior of <cite>.toPrintable</cite> in custom <a class="reference internal" href="core/core.html#attr-case class BundleLitBinding(litMap: Map[Data, LitArg]) extends LitBinding" title="attr-case class BundleLitBinding(litMap: Map[Data, LitArg]) extends LitBinding"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Bundle</span></code></a>  and <a class="reference internal" href="core/core.html#attr-abstract class Record(private[chisel3] implicit val compileOptions: CompileOptions) extends Aggregate" title="attr-abstract class Record(private[chisel3] implicit val compileOptions: CompileOptions) extends Aggregate"><code class="xref chisel chisel-reref docutils literal notranslate"><span class="pre">Record</span></code></a>
types.</p>
<dl class="attr">
<dt id="attr-def unpack(ctx: Component): (String, Iterable[String])">
<code class="descname">def unpack(ctx: Component): (String, Iterable[String])</code><a class="headerlink" href="#attr-def unpack(ctx: Component): (String, Iterable[String])" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack into format String and a List of String arguments (identifiers)
:note: This must be called after elaboration when Chisel nodes actually</p>
<blockquote>
<div>have names</div></blockquote>
</dd></dl>

<dl class="attr">
<dt id="attr-final def +(that: Printable): Printables">
<code class="descname">final def +(that: Printable): Printables</code><a class="headerlink" href="#attr-final def +(that: Printable): Printables" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow for appending Printables like Strings</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def +(that: String): Printables">
<code class="descname">final def +(that: String): Printables</code><a class="headerlink" href="#attr-final def +(that: String): Printables" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow for appending Strings to Printables</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-object Printable">
<code class="descname">object Printable</code><a class="headerlink" href="#attr-object Printable" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def pack(fmt: String, data: Data*): Printable =">
<code class="descname">def pack(fmt: String, data: Data*): Printable =</code><a class="headerlink" href="#attr-def pack(fmt: String, data: Data*): Printable =" title="Permalink to this definition">¶</a></dt>
<dd><p>Pack standard printf fmt, args* style into Printable</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-case class Printables(pables: Iterable[Printable]) extends Printable">
<code class="descname">case class Printables(pables: Iterable[Printable]) extends Printable</code><a class="headerlink" href="#attr-case class Printables(pables: Iterable[Printable]) extends Printable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-case class PString(str: String) extends Printable">
<code class="descname">case class PString(str: String) extends Printable</code><a class="headerlink" href="#attr-case class PString(str: String) extends Printable" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for printing Scala Strings</p>
</dd></dl>

<dl class="attr">
<dt id="attr-sealed abstract class FirrtlFormat(private[chisel3] val specifier: Char) extends Printable">
<code class="descname">sealed abstract class FirrtlFormat(private[chisel3] val specifier: Char) extends Printable</code><a class="headerlink" href="#attr-sealed abstract class FirrtlFormat(private[chisel3] val specifier: Char) extends Printable" title="Permalink to this definition">¶</a></dt>
<dd><p>Superclass for Firrtl format specifiers for Bits</p>
</dd></dl>

<dl class="attr">
<dt id="attr-object FirrtlFormat">
<code class="descname">object FirrtlFormat</code><a class="headerlink" href="#attr-object FirrtlFormat" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply(specifier: String, data: Data): FirrtlFormat =">
<code class="descname">def apply(specifier: String, data: Data): FirrtlFormat =</code><a class="headerlink" href="#attr-def apply(specifier: String, data: Data): FirrtlFormat =" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for constructing Firrtl Formats  Accepts data to simplify pack</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-case class Decimal(bits: Bits) extends FirrtlFormat('d')">
<code class="descname">case class Decimal(bits: Bits) extends FirrtlFormat('d')</code><a class="headerlink" href="#attr-case class Decimal(bits: Bits) extends FirrtlFormat('d')" title="Permalink to this definition">¶</a></dt>
<dd><p>Format bits as Decimal</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case class Hexadecimal(bits: Bits) extends FirrtlFormat('x')">
<code class="descname">case class Hexadecimal(bits: Bits) extends FirrtlFormat('x')</code><a class="headerlink" href="#attr-case class Hexadecimal(bits: Bits) extends FirrtlFormat('x')" title="Permalink to this definition">¶</a></dt>
<dd><p>Format bits as Hexidecimal</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case class Binary(bits: Bits) extends FirrtlFormat('b')">
<code class="descname">case class Binary(bits: Bits) extends FirrtlFormat('b')</code><a class="headerlink" href="#attr-case class Binary(bits: Bits) extends FirrtlFormat('b')" title="Permalink to this definition">¶</a></dt>
<dd><p>Format bits as Binary</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case class Character(bits: Bits) extends FirrtlFormat('c')">
<code class="descname">case class Character(bits: Bits) extends FirrtlFormat('c')</code><a class="headerlink" href="#attr-case class Character(bits: Bits) extends FirrtlFormat('c')" title="Permalink to this definition">¶</a></dt>
<dd><p>Format bits as Character</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case class Name(data: Data) extends Printable">
<code class="descname">case class Name(data: Data) extends Printable</code><a class="headerlink" href="#attr-case class Name(data: Data) extends Printable" title="Permalink to this definition">¶</a></dt>
<dd><p>Put innermost name (eg. field of bundle)</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case class FullName(data: Data) extends Printable">
<code class="descname">case class FullName(data: Data) extends Printable</code><a class="headerlink" href="#attr-case class FullName(data: Data) extends Printable" title="Permalink to this definition">¶</a></dt>
<dd><p>Put full name within parent namespace (eg. bundleName.field)</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case object Percent extends Printable">
<code class="descname">case object Percent extends Printable</code><a class="headerlink" href="#attr-case object Percent extends Printable" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents escaped percents</p>
</dd></dl>

</div>
<div class="section" id="clock-scala">
<h2>Clock.scala<a class="headerlink" href="#clock-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-object Clock">
<code class="descname">object Clock</code><a class="headerlink" href="#attr-object Clock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attr">
<dt id="attr-sealed class Clock(private[chisel3] val width: Width">
<code class="descname">sealed class Clock(private[chisel3] val width: Width</code><a class="headerlink" href="#attr-sealed class Clock(private[chisel3] val width: Width" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def toPrintable: Printable">
<code class="descname">def toPrintable: Printable</code><a class="headerlink" href="#attr-def toPrintable: Printable" title="Permalink to this definition">¶</a></dt>
<dd><p>Not really supported</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="blackbox-scala">
<h2>BlackBox.scala<a class="headerlink" href="#blackbox-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-sealed abstract class Param case class IntParam(value: BigInt) extends Param">
<code class="descname">sealed abstract class Param case class IntParam(value: BigInt) extends Param</code><a class="headerlink" href="#attr-sealed abstract class Param case class IntParam(value: BigInt) extends Param" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters for BlackBoxes</p>
</dd></dl>

<dl class="attr">
<dt id="attr-case class RawParam(value: String) extends Param">
<code class="descname">case class RawParam(value: String) extends Param</code><a class="headerlink" href="#attr-case class RawParam(value: String) extends Param" title="Permalink to this definition">¶</a></dt>
<dd><p>Unquoted String</p>
</dd></dl>

<dl class="attr">
<dt id="attr-abstract class ExtModule(val params: Map[String, Param] = Map.empty[String, Param]) extends BaseBlackBox">
<code class="descname">abstract class ExtModule(val params: Map[String, Param] = Map.empty[String, Param]) extends BaseBlackBox</code><a class="headerlink" href="#attr-abstract class ExtModule(val params: Map[String, Param] = Map.empty[String, Param]) extends BaseBlackBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a black box, which is a module that can be referenced from within       Chisel, but is not defined in the emitted Verilog. Useful for connecting
to RTL modules defined outside Chisel.</p>
<p>A variant of BlackBox, this has a more consistent naming scheme in allowing
multiple top-level IO and does not drop the top prefix.</p>
<p>&#64;example
Some design require a differential input clock to clock the all design.
With the xilinx FPGA for example, a Verilog template named IBUFDS must be
integrated to use differential input:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">IBUFDS</span> <span class="o">#(.</span><span class="nc">DIFF_TERM</span><span class="o">(</span><span class="s">&quot;TRUE&quot;</span><span class="o">),</span>
         <span class="o">.</span><span class="nc">IOSTANDARD</span><span class="o">(</span><span class="s">&quot;DEFAULT&quot;</span><span class="o">))</span> <span class="n">ibufds</span> <span class="o">(</span>
 <span class="o">.</span><span class="nc">IB</span><span class="o">(</span><span class="n">ibufds_IB</span><span class="o">),</span>
 <span class="o">.</span><span class="n">I</span><span class="o">(</span><span class="n">ibufds_I</span><span class="o">),</span>
 <span class="o">.</span><span class="n">O</span><span class="o">(</span><span class="n">ibufds_O</span><span class="o">)</span>
<span class="o">);</span>
</pre></div>
</div>
<p>To instantiate it, a BlackBox can be used like following:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">chisel3._</span>
<span class="k">import</span> <span class="nn">chisel3.experimental._</span>

<span class="c1">// Example with Xilinx differential buffer IBUFDS</span>
<span class="k">class</span> <span class="nc">IBUFDS</span> <span class="k">extends</span> <span class="nc">ExtModule</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;DIFF_TERM&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;TRUE&quot;</span><span class="o">,</span> <span class="c1">// Verilog parameters</span>
                                   <span class="s">&quot;IOSTANDARD&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;DEFAULT&quot;</span>
                     <span class="o">))</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">O</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nc">Output</span><span class="o">(</span><span class="nc">Clock</span><span class="o">()))</span>
  <span class="k">val</span> <span class="n">I</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nc">Input</span><span class="o">(</span><span class="nc">Clock</span><span class="o">()))</span>
  <span class="k">val</span> <span class="nc">IB</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nc">Input</span><span class="o">(</span><span class="nc">Clock</span><span class="o">()))</span>
<span class="o">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">The parameters API is experimental and may change</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-abstract class BlackBox(val params: Map[String, Param] = Map.empty[String, Param])(implicit compileOptions: CompileOptions) extends BaseBlackBox">
<code class="descname">abstract class BlackBox(val params: Map[String, Param] = Map.empty[String, Param])(implicit compileOptions: CompileOptions) extends BaseBlackBox</code><a class="headerlink" href="#attr-abstract class BlackBox(val params: Map[String, Param] = Map.empty[String, Param])(implicit compileOptions: CompileOptions) extends BaseBlackBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a black box, which is a module that can be referenced from within       Chisel, but is not defined in the emitted Verilog. Useful for connecting
to RTL modules defined outside Chisel.</p>
<p>&#64;example
Some design require a differential input clock to clock the all design.
With the xilinx FPGA for example, a Verilog template named IBUFDS must be
integrated to use differential input:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">IBUFDS</span> <span class="o">#(.</span><span class="nc">DIFF_TERM</span><span class="o">(</span><span class="s">&quot;TRUE&quot;</span><span class="o">),</span>
         <span class="o">.</span><span class="nc">IOSTANDARD</span><span class="o">(</span><span class="s">&quot;DEFAULT&quot;</span><span class="o">))</span> <span class="n">ibufds</span> <span class="o">(</span>
 <span class="o">.</span><span class="nc">IB</span><span class="o">(</span><span class="n">ibufds_IB</span><span class="o">),</span>
 <span class="o">.</span><span class="n">I</span><span class="o">(</span><span class="n">ibufds_I</span><span class="o">),</span>
 <span class="o">.</span><span class="n">O</span><span class="o">(</span><span class="n">ibufds_O</span><span class="o">)</span>
<span class="o">);</span>
</pre></div>
</div>
<p>To instantiate it, a BlackBox can be used like following:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">chisel3._</span>
<span class="k">import</span> <span class="nn">chisel3.experimental._</span>

<span class="c1">// Example with Xilinx differential buffer IBUFDS</span>
<span class="k">class</span> <span class="nc">IBUFDS</span> <span class="k">extends</span> <span class="nc">BlackBox</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;DIFF_TERM&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;TRUE&quot;</span><span class="o">,</span> <span class="c1">// Verilog parameters</span>
                                  <span class="s">&quot;IOSTANDARD&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;DEFAULT&quot;</span>
                     <span class="o">))</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">io</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">Bundle</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">O</span> <span class="k">=</span> <span class="nc">Output</span><span class="o">(</span><span class="nc">Clock</span><span class="o">())</span> <span class="c1">// IO names will be the same</span>
    <span class="k">val</span> <span class="n">I</span> <span class="k">=</span> <span class="nc">Input</span><span class="o">(</span><span class="nc">Clock</span><span class="o">())</span>  <span class="c1">// (without &#39;io_&#39; in prefix)</span>
    <span class="k">val</span> <span class="nc">IB</span> <span class="k">=</span> <span class="nc">Input</span><span class="o">(</span><span class="nc">Clock</span><span class="o">())</span> <span class="c1">//</span>
  <span class="o">})</span>
<span class="o">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">The parameters API is experimental and may change</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-abstract class BlackBox(val params: Map[String, Param]">
<code class="descname">abstract class BlackBox(val params: Map[String, Param]</code><a class="headerlink" href="#attr-abstract class BlackBox(val params: Map[String, Param]" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-scala">
<h2>Module.scala<a class="headerlink" href="#module-scala" title="Permalink to this headline">¶</a></h2>
<dl class="attr">
<dt id="attr-object Module extends SourceInfoDoc">
<code class="descname">object Module extends SourceInfoDoc</code><a class="headerlink" href="#attr-object Module extends SourceInfoDoc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attr">
<dt id="attr-def apply[T &lt;: BaseModule](bc: =&gt; T): T">
<code class="descname">def apply[T &lt;: BaseModule](bc: =&gt; T): T</code><a class="headerlink" href="#attr-def apply[T <: BaseModule](bc: => T): T" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper method that all Module instantiations must be wrapped in      (necessary to help Chisel track internal state).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param bc:</th><td class="field-body">the Module being created</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body">the input module <cite>m</cite> with Chisel metadata properly set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attr">
<dt id="attr-def do_apply[T &lt;: BaseModule](bc: =&gt; T) (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =">
<code class="descname">def do_apply[T &lt;: BaseModule](bc: =&gt; T) (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =</code><a class="headerlink" href="#attr-def do_apply[T <: BaseModule](bc: => T) (implicit sourceInfo: SourceInfo, compileOptions: CompileOptions): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;group SourceInfoTransformMacro</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def clock: Clock">
<code class="descname">def clock: Clock</code><a class="headerlink" href="#attr-def clock: Clock" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the implicit Clock</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def reset: Reset">
<code class="descname">def reset: Reset</code><a class="headerlink" href="#attr-def reset: Reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the implicit Reset</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def currentModule: Option[BaseModule]">
<code class="descname">def currentModule: Option[BaseModule]</code><a class="headerlink" href="#attr-def currentModule: Option[BaseModule]" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current Module</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def apply[T&lt;:Data](iodef: T): T =">
<code class="descname">def apply[T&lt;:Data](iodef: T): T =</code><a class="headerlink" href="#attr-def apply[T<:Data](iodef: T): T =" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a port for the current Module
This must wrap the datatype used to set the io field of any Module.
i.e. All concrete modules must have defined io in this form:
[lazy] val io[: io type] = IO(…[: io type])</p>
<p>Items in [] are optional.</p>
<p>The granted iodef must be a chisel type and not be bound to hardware.</p>
<p>Also registers a Data as a port, also performing bindings. Cannot be called once ports are
requested (so that all calls to ports will return the same information).
Internal API.</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="attr-abstract class BaseModule extends HasId">
<code class="descname">abstract class BaseModule extends HasId</code><a class="headerlink" href="#attr-abstract class BaseModule extends HasId" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for Modules, an instantiable organizational unit for RTL.</p>
<dl class="attr">
<dt id="attr-private[chisel3] def isClosed">
<code class="descname">private[chisel3] def isClosed</code><a class="headerlink" href="#attr-private[chisel3] def isClosed" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal check if a Module is closed</p>
</dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] def generateComponent(): Component">
<code class="descname">private[chisel3] def generateComponent(): Component</code><a class="headerlink" href="#attr-private[chisel3] def generateComponent(): Component" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the FIRRTL Component (Module or Blackbox) of this Module.     Also closes the module so no more construction can happen inside.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] def initializeInParent(parentCompileOptions: CompileOptions): Unit">
<code class="descname">private[chisel3] def initializeInParent(parentCompileOptions: CompileOptions): Unit</code><a class="headerlink" href="#attr-private[chisel3] def initializeInParent(parentCompileOptions: CompileOptions): Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up this module in the parent context</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def desiredName: String">
<code class="descname">def desiredName: String</code><a class="headerlink" href="#attr-def desiredName: String" title="Permalink to this definition">¶</a></dt>
<dd><p>Desired name of this module. Override this to give this module a custom, perhaps parametric,    name.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-final def toNamed: ModuleName">
<code class="descname">final def toNamed: ModuleName</code><a class="headerlink" href="#attr-final def toNamed: ModuleName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a FIRRTL ModuleName that references this object
:note: Should not be called until circuit elaboration is complete</p>
</dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] def getChiselPorts: Seq[(String, Data)] =">
<code class="descname">private[chisel3] def getChiselPorts: Seq[(String, Data)] =</code><a class="headerlink" href="#attr-private[chisel3] def getChiselPorts: Seq[(String, Data)] =" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Internal API. Returns a list of this module’s generated top-level ports as a map of a String</div></blockquote>
<p>(FIRRTL name) to the IO object. Only valid after the module is closed.</p>
<p>Note: for BlackBoxes (but not ExtModules), this returns the contents of the top-level io
object, consistent with what is emitted in FIRRTL.</p>
<p>TODO: Use SeqMap/VectorMap when those data structures become available.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-protected def nameIds(rootClass: Class[_]): HashMap[HasId, String] =">
<code class="descname">protected def nameIds(rootClass: Class[_]): HashMap[HasId, String] =</code><a class="headerlink" href="#attr-protected def nameIds(rootClass: Class[_]): HashMap[HasId, String] =" title="Permalink to this definition">¶</a></dt>
<dd><p>Called at the Module.apply(…) level after this Module has finished elaborating.       Returns a map of nodes -&gt; names, for named nodes.</p>
<p>Helper method.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def cleanName(name: String): String">
<code class="descname">def cleanName(name: String): String</code><a class="headerlink" href="#attr-def cleanName(name: String): String" title="Permalink to this definition">¶</a></dt>
<dd><p>Scala generates names like chisel3$util$Queue$$ram for private vals     This extracts the part after $$ for names like this and leaves names
without $$ unchanged</p>
</dd></dl>

<dl class="attr">
<dt id="attr-def _compatAutoWrapPorts()">
<code class="descname">def _compatAutoWrapPorts()</code><a class="headerlink" href="#attr-def _compatAutoWrapPorts()" title="Permalink to this definition">¶</a></dt>
<dd><p>Compatibility function. Allows Chisel2 code which had ports without the IO wrapper to   compile under Bindings checks. Does nothing in non-compatibility mode.</p>
<p>Should NOT be used elsewhere. This API will NOT last.</p>
<p>TODO: remove this, perhaps by removing Bindings checks in compatibility mode.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-protected def _bindIoInPlace(iodef: Data): Unit =">
<code class="descname">protected def _bindIoInPlace(iodef: Data): Unit =</code><a class="headerlink" href="#attr-protected def _bindIoInPlace(iodef: Data): Unit =" title="Permalink to this definition">¶</a></dt>
<dd><p>Chisel2 code didn’t require the IO(…) wrapper and would assign a Chisel type directly to      io, then do operations on it. This binds a Chisel type in-place (mutably) as an IO.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-private[chisel3] def bindIoInPlace(iodef: Data): Unit">
<code class="descname">private[chisel3] def bindIoInPlace(iodef: Data): Unit</code><a class="headerlink" href="#attr-private[chisel3] def bindIoInPlace(iodef: Data): Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Private accessor for _bindIoInPlace</p>
</dd></dl>

<dl class="attr">
<dt id="attr-protected def IO[T&lt;:Data](iodef: T): T">
<code class="descname">protected def IO[T&lt;:Data](iodef: T): T</code><a class="headerlink" href="#attr-protected def IO[T<:Data](iodef: T): T" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This must wrap the datatype used to set the io field of any Module.</div></blockquote>
<p>i.e. All concrete modules must have defined io in this form:
[lazy] val io[: io type] = IO(…[: io type])</p>
<p>Items in [] are optional.</p>
<p>The granted iodef must be a chisel type and not be bound to hardware.</p>
<p>Also registers a Data as a port, also performing bindings. Cannot be called once ports are
requested (so that all calls to ports will return the same information).
Internal API.</p>
<p>TODO(twigg): Specifically walk the Data definition to call out which nodes
are problematic.</p>
</dd></dl>

<dl class="attr">
<dt id="attr-override def instanceName: String">
<code class="descname">override def instanceName: String</code><a class="headerlink" href="#attr-override def instanceName: String" title="Permalink to this definition">¶</a></dt>
<dd><p>Signal name (for simulation).</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../contents.html">chisel-test</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../../src/src.html">src</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../../chiselFrontend.html">chiselFrontend</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../../../target/target.html">chiselFrontend/target</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../../src.html">chiselFrontend/src</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../contents.html">Documentation overview</a><ul>
  <li><a href="../../../../chiselFrontend.html">chiselFrontend</a><ul>
  <li><a href="../../../src.html">chiselFrontend/src</a><ul>
  <li><a href="../../main.html">chiselFrontend/src/main</a><ul>
  <li><a href="../scala.html">chiselFrontend/src/main/scala</a><ul>
      <li>Previous: <a href="../scala.html" title="previous chapter">chiselFrontend/src/main/scala</a></li>
      <li>Next: <a href="experimental/experimental.html" title="next chapter">chiselFrontend/src/main/scala/chisel3/experimental</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, John Andrews.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../../../_sources/chiselFrontend/src/main/scala/chisel3/chisel3.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>