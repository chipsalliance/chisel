------------------
src/test/scala/gcd
------------------

.. toctree::


GCDMain.scala
-------------
.. chisel:attr:: object GCDMain extends App

		This provides an alternate way to run tests, by executing then as a main
	From sbt (Note: the test: prefix is because this main is under the test package hierarchy):
	
	.. code-block:: scala 

		 test:runMain gcd.GCDMain
	
	To see all command line options use:
	
	.. code-block:: scala 

		 test:runMain gcd.GCDMain --help
	
	To run with verilator:
	
	.. code-block:: scala 

		 test:runMain gcd.GCDMain --backend-name verilator
	
	To run with verilator from your terminal shell use:
	
	.. code-block:: scala 

		 sbt 'test:runMain gcd.GCDMain --backend-name verilator'
	
  

.. chisel:attr:: object GCDRepl extends App

		This provides a way to run the firrtl-interpreter REPL (or shell)
	on the lowered firrtl generated by your circuit. You will be placed
	in an interactive shell. This can be very helpful as a debugging
	technique. Type help to see a list of commands.
	
	To run from sbt
	
	.. code-block:: scala 

		 test:runMain gcd.GCDRepl
	
	To run from sbt and see the half a zillion options try
	
	.. code-block:: scala 

		 test:runMain gcd.GCDRepl --help
	
  

GCDUnitTest.scala
-----------------
.. chisel:attr:: class GCDUnitTester(c: GCD) extends PeekPokeTester(c)


	.. chisel:attr:: def computeGcd(a: Int, b: Int): (Int, Int) =

	
			compute the gcd and the number of steps it should take to do it
		
		
		:param a: positive integer
		
		:param b: positive integer
		:return: the GCD of a and b
		    


.. chisel:attr:: class GCDTester extends ChiselFlatSpec

		This is a trivial example of how to run this Specification
	From within sbt use:
	
	.. code-block:: scala 

		 testOnly gcd.GCDTester
	
	From a terminal shell use:
	
	.. code-block:: scala 

		 sbt 'testOnly gcd.GCDTester'
	
  

