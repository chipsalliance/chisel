---
layout: docs
title:  "Naming Cookbook"
section: "chisel3"
---

```scala mdoc:invisible
import chisel3._
import circt.stage.ChiselStage
```
# Naming Cookbook

### I still have _T signals, can this be fixed?

See the next answer!

### I have so many wires with the same name, like `x`, `x_1` and `x_2`. How can I make them easier to understand?

Signals with `_T` names or names that Chisel has to uniquify
often are intermediate values generated within loops, function calls, or `when` predicates.
They can also be consumed by verification statements like `assert` or `prints`.
In these cases, the compiler plugin often can't find a good prefix for the generated
intermediate signals and can't name them at all or has to make up a unique name for them.

We recommend you manually insert calls to `prefix` to clarify these cases:

```scala mdoc:silent
import chisel3.experimental.prefix
class ExamplePrefix extends Module {

  Seq.tabulate{2} {i =>
    Seq.tabulate{2}{ j =>
      prefix(s"loop_${i}_${j}"){
        val x = WireInit((i*0x10+j).U(8.W))
        dontTouch(x)
      }
    }
  }
}
```
```scala mdoc:verilog
ChiselStage.emitSystemVerilog(new ExamplePrefix)
```
### How can I get better names for code generated by `when` clauses?

The `prefix` API can help with code inside `when` clauses:

```scala mdoc:silent
class ExampleWhenPrefix extends Module {

  val in = IO(Input(UInt(4.W)))
  val out = IO(Output(UInt(4.W)))

  out := DontCare

  Seq.tabulate{2}{ i =>
    val j = i + 1
    when (in === j.U) { prefix(s"clause_${j}"){
      val foo = Wire(UInt(4.W))
      foo := in +& j.U(4.W)
      out := foo
    }}
  }
}
```
```scala mdoc:verilog
ChiselStage.emitSystemVerilog(new ExampleWhenPrefix)
```

### I still see _GEN signals, can this be fixed?

`_GEN` signals are usually generated from the FIRRTL compiler, rather than the Chisel library. We are working on
renaming these signals with more context-dependent names, but it is a work in progress. Thanks for caring!

### My module names are super unstable - I change one thing and Module_1 becomes Module_42. Help!

This is an example of the module instability problem, which results from several modules all sharing the exact same name. To fix this, you must add more specificity to your `Module`'s name to avoid these name collisions.

This can be done by leveraging the `desiredName` and `typeName` APIs. 
`desiredName` is for indicating the names of `Modules` (e.g. influenced by the parameters passed in), and `typeName` is useful for modules which are type-parameterized by subclasses of `Data`. Overriding `desiredName` can reduce or even eliminate name collisions. For instance, suppose your module looks like the following:

```scala mdoc
class MyModule[T <: Data](gen: T) extends Module {
  val in = IO(Input(gen))
  val out = IO(Output(gen))
  out := in
}
```

We can override `desiredName` to include the type name of the `gen` parameter like so:

```scala mdoc
override def desiredName = s"MyModule_${gen.typeName}"
```

Any instances of your `MyModule` will now have Verilog module names containing the type parameter.

```scala mdoc
val foo = Module(new MyModule(UInt(4.W))) // MyModule_UInt4
val foo = Module(new MyModule(Vec(3, UInt(4.W)))) // MyModule_Vec3_UInt4
```


All Chisel built-in library modules, like `Queue` and `Pipe`, already have their `desiredName` overridden in this manner. Assuming that users of these also override the `typeName` of their Data type parameters in a distinct fashion, this will solve the `Queue` stability problem.

### I have already overriden `desiredName` to use a `typeName` but my module names are still conflicting!

You either must add additional information to the `desiredName`, or if you're using your own user-defined `Bundle`, increase the specificity of its own `typeName`. All `Data` types have a simple default implementation of `typeName` (which is simply their own name), but you can override this yourself, of course!

In general, the suggested pattern for `typeName`, and subsequently `desiredName`, is to fold single integer-like parameters with the name itself (for example, `Queue4`, `UInt3`, `MyBundle9`) and separate these with underscores (`Queue4_UInt3`, `FooBundle_BarType4`).

Integers should not occur with an underscore before it at the very end of the name (`MyBundle_1`) because this is the _same_ syntax used for duplicates, and so would cause confusion. Having to disambiguate modules all named `FooModule_MyBundle_4_1`, `FooModule_MyBundle_4_2`, `FooModule_MyBundle_4_3`, and so on would be undesirable, indeed!

### I want to add some hardware or assertions, but each time I do all the signal names get bumped!

This is the classic "ECO" problem, and we provide descriptions in [explanation](../explanations/naming). In short,
we recommend wrapping all additional logic in a prefix scope, which enables a unique namespace. This should prevent
name collisions, which are what triggers all those annoying signal name bumps!

### I want to force a signal (or instance) name to something, how do I do that?

Use the `.suggestName` method, which is on all classes which subtype `Data`.

### How can I omit the prefix in certain parts of the code?

You can use the `noPrefix { ... }` to strip the prefix from all signals generated in that scope.

```scala mdoc
import chisel3.experimental.noPrefix

class ExampleNoPrefix extends Module {
  val in = IO(Input(UInt(2.W)))
  val out = IO(Output(UInt()))

  val add = noPrefix { in + in + in }

  out := add
}
```
```scala mdoc:verilog
ChiselStage.emitSystemVerilog(new ExampleNoPrefix)
```

### I am still not getting the name I want. For example, inlining an instance changes my name!

In cases where a FIRRTL transform renames a signal/instance, you can use the `forcename` API:

```scala mdoc
import chisel3.util.experimental.{forceName, InlineInstance}

class WrapperExample extends Module {
  val in = IO(Input(UInt(3.W)))
  val out = IO(Output(UInt(3.W)))
  val inst = Module(new Wrapper)
  inst.in := in
  out := inst.out
}
class Wrapper extends Module with InlineInstance {
  val in = IO(Input(UInt(3.W)))
  val out = IO(Output(UInt(3.W)))
  val inst = Module(new MyLeaf)
  forceName(inst, "inst")
  inst.in := in
  out := inst.out
}
class MyLeaf extends Module {
  val in = IO(Input(UInt(3.W)))
  val out = IO(Output(UInt(3.W)))
  out := in
}
```
```scala mdoc:verilog
ChiselStage.emitSystemVerilog(new WrapperExample)
```

This can be used to rename instances and non-aggregate typed signals.
